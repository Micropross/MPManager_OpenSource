Index: ManagedOpenSsl/Core/Asn1Encoding.cs
===================================================================
--- ManagedOpenSsl/Core/Asn1Encoding.cs	(revision 0)
+++ ManagedOpenSsl/Core/Asn1Encoding.cs	(revision 47851)
@@ -0,0 +1,15 @@
+﻿using System;
+using System.Runtime.InteropServices;
+
+namespace OpenSSL
+{
+	
+	[StructLayout(LayoutKind.Sequential)]
+	internal struct Asn1Encoding
+	{
+		public IntPtr enc;
+		public int len;
+		public int modified;
+	}
+}
+
Index: ManagedOpenSsl/Core/Threading.cs
===================================================================
--- ManagedOpenSsl/Core/Threading.cs	(revision 0)
+++ ManagedOpenSsl/Core/Threading.cs	(revision 47851)
@@ -0,0 +1,105 @@
+﻿using System;
+using System.Threading;
+using System.Runtime.InteropServices;
+using System.Collections.Generic;
+
+namespace OpenSSL.Core
+{
+	/// <summary>
+	/// Threading.
+	/// </summary>
+    public class Threading
+    {
+		[StructLayout(LayoutKind.Sequential)]
+		struct CRYPTO_THREADID
+		{
+			public IntPtr ptr;
+			public uint val;
+		}
+
+		private const int CRYPTO_LOCK = 1;
+
+		// These are used to pin the functions down so they don't get yanked while in use
+		static Native.CRYPTO_locking_callback _ptrOnLocking = OnLocking;
+		static Native.CRYPTO_id_callback _ptrOnThreadId = OnThreadId;
+
+		private static List<object> lock_objects;
+		private static List<uint> _threadIDs;
+
+		/// <summary>
+		/// Initialize this instance.
+		/// </summary>
+		public static void Initialize()
+		{
+			// Initialize the threading locks
+			var nLocks = Native.CRYPTO_num_locks();
+			lock_objects = new List<object>(nLocks);
+
+			for (var i = 0; i < nLocks; i++)
+			{
+				var obj = new object();
+				lock_objects.Add(obj);
+			}
+
+			// Initialize the internal thread id stack
+			_threadIDs = new List<uint>();
+
+			// Initialize the delegate for the locking callback
+			Native.CRYPTO_set_locking_callback(_ptrOnLocking);
+
+			// Initialize the thread id callback
+			Native.CRYPTO_THREADID_set_callback(_ptrOnThreadId);
+		}
+
+		/// <summary>
+		/// Cleanup this instance.
+		/// </summary>
+		public static void Cleanup()
+		{
+			// Cleanup the thread lock objects
+			Native.CRYPTO_set_locking_callback(null);
+			lock_objects.Clear();
+
+			// Clean up error state for each thread that was used by OpenSSL
+			if (_threadIDs != null)
+			{
+				foreach (var id in _threadIDs)
+				{
+					RemoveState(id);
+				}
+				_threadIDs.Clear();
+			}
+		}
+
+		private static void RemoveState(uint threadId)
+		{
+			var ptr = Marshal.AllocHGlobal(Marshal.SizeOf(typeof(CRYPTO_THREADID)));
+			Native.CRYPTO_THREADID_set_numeric(ptr, threadId);
+			Native.ERR_remove_thread_state(ptr);
+			Marshal.FreeHGlobal(ptr);
+		}
+
+		private static void OnLocking(int mode, int type, string file, int line)
+		{
+			if ((mode & CRYPTO_LOCK) == CRYPTO_LOCK)
+			{
+				Monitor.Enter(lock_objects[type]);
+			}
+			else
+			{
+				Monitor.Exit(lock_objects[type]);
+			}
+		}
+
+		private static void OnThreadId(IntPtr tid)
+		{
+			var threadId = (uint)Thread.CurrentThread.ManagedThreadId;
+			if (!_threadIDs.Contains(threadId))
+			{
+				_threadIDs.Add(threadId);
+			}
+			Native.CRYPTO_THREADID_set_numeric(tid, threadId);
+		}
+    }
+}
+
Index: ManagedOpenSsl/Core/Asn1DateTime.cs
===================================================================
--- ManagedOpenSsl/Core/Asn1DateTime.cs	(revision 47839)
+++ ManagedOpenSsl/Core/Asn1DateTime.cs	(revision 47851)
@@ -24,8 +24,6 @@
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Globalization;
 
 namespace OpenSSL.Core
@@ -48,7 +46,7 @@
 
 		protected override void OnDispose()
 		{
-			Native.ASN1_TIME_free(this.ptr);
+			Native.ASN1_TIME_free(ptr);
 		}
 
 		public DateTime DateTime
@@ -55,12 +53,12 @@
 		{
 			get
 			{
-				return ToDateTime(this.ptr);
+				return ToDateTime(ptr);
 			}
 			set
 			{
-				long time_t = DateTimeToTimeT(value.ToUniversalTime());
-				Native.ASN1_TIME_set(this.ptr, time_t);
+				var time_t = DateTimeToTimeT(value.ToUniversalTime());
+				Native.ASN1_TIME_set(ptr, time_t);
 			}
 		}
 
@@ -71,9 +69,11 @@
 
 		private long DateTimeToTimeT(DateTime value)
 		{
-			DateTime dt1970 = new DateTime(1970, 1, 1, 0, 0, 0, 0);
+			var dt1970 = new DateTime(1970, 1, 1, 0, 0, 0, 0);
+
 			// # of 100 nanoseconds since 1970
-			long ticks = (value.Ticks - dt1970.Ticks) / 10000000L;
+			var ticks = (value.Ticks - dt1970.Ticks) / 10000000L;
+			
 			return ticks;
 		}
 
@@ -80,16 +80,19 @@
 		private static DateTime AsnTimeToDateTime(IntPtr ptr)
 		{
 			string str;
-			using (BIO bio = BIO.MemoryBuffer())
+
+			using (var bio = BIO.MemoryBuffer())
 			{
 				Native.ExpectSuccess(Native.ASN1_UTCTIME_print(bio.Handle, ptr));
 				str = bio.ReadString();
 			}
+
 			string[] fmts = 
 			{ 
 				"MMM  d HH:mm:ss yyyy G\\MT",
 				"MMM dd HH:mm:ss yyyy G\\MT"
 			};
+
 			return DateTime.ParseExact(str, fmts, new DateTimeFormatInfo(), DateTimeStyles.AssumeUniversal | DateTimeStyles.AdjustToUniversal);
 		}
 	}
Index: ManagedOpenSsl/Core/Asn1Integer.cs
===================================================================
--- ManagedOpenSsl/Core/Asn1Integer.cs	(revision 47839)
+++ ManagedOpenSsl/Core/Asn1Integer.cs	(revision 47851)
@@ -24,9 +24,6 @@
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
-using System.Globalization;
 
 namespace OpenSSL.Core
 {
@@ -43,18 +40,18 @@
 		public Asn1Integer(int value)
 			: this()
 		{
-			this.Value = value;
+			Value = value;
 		}
 
 		protected override void OnDispose()
 		{
-			Native.ASN1_TIME_free(this.ptr);
+			Native.ASN1_INTEGER_free(ptr);
 		}
 
 		public int Value
 		{
-			get { return Native.ASN1_INTEGER_get(this.ptr); }
-			set { Native.ExpectSuccess(Native.ASN1_INTEGER_set(this.ptr, value)); }
+			get { return Native.ASN1_INTEGER_get(ptr); }
+			set { Native.ExpectSuccess(Native.ASN1_INTEGER_set(ptr, value)); }
 		}
 
 		public static int ToInt32(IntPtr ptr)
Index: ManagedOpenSsl/Core/Asn1Object.cs
===================================================================
--- ManagedOpenSsl/Core/Asn1Object.cs	(revision 47839)
+++ ManagedOpenSsl/Core/Asn1Object.cs	(revision 47851)
@@ -23,11 +23,13 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-using System;
 using System.Runtime.InteropServices;
 
 namespace OpenSSL.Core
 {
+	/// <summary>
+	/// Asn1 object.
+	/// </summary>
 	public class Asn1Object
 	{
 		[StructLayout(LayoutKind.Sequential)]
@@ -42,44 +44,95 @@
 		}
 		
 		private int nid;
-		
-		public Asn1Object(int nid) {
+
+		/// <summary>
+		/// Initializes a new instance of the <see cref="OpenSSL.Core.Asn1Object"/> class.
+		/// </summary>
+		/// <param name="nid">Nid.</param>
+		public Asn1Object(int nid) 
+		{
 			this.nid = nid;
 		}
-		
-		public Asn1Object(string sn) {
-			this.nid = Native.OBJ_sn2nid(sn);
+
+		/// <summary>
+		/// Initializes a new instance of the <see cref="OpenSSL.Core.Asn1Object"/> class.
+		/// </summary>
+		/// <param name="sn">Sn.</param>
+		public Asn1Object(string sn) 
+		{
+			nid = Native.OBJ_sn2nid(sn);
 		}
 
-		public int NID { 
-			get { return this.nid; } 
+		/// <summary>
+		/// Gets the NID.
+		/// </summary>
+		/// <value>The NID.</value>
+		public int NID 
+		{ 
+			get { return nid; } 
 		}
-		
-		public string ShortName {
-			get { return Native.OBJ_nid2sn(this.nid); }
+
+		/// <summary>
+		/// Gets the short name.
+		/// </summary>
+		/// <value>The short name.</value>
+		public string ShortName 
+		{
+			get { return Native.StaticString(Native.OBJ_nid2sn(nid)); }
 		}
-		
-		public string LongName {
-			get { return Native.OBJ_nid2ln(this.nid); }
+
+		/// <summary>
+		/// Gets the long name.
+		/// </summary>
+		/// <value>The long name.</value>
+		public string LongName 
+		{
+			get { return Native.StaticString(Native.OBJ_nid2ln(nid)); }
 		}
-		
-		public static Asn1Object FromShortName(string sn) {
+
+		/// <summary>
+		/// Froms the short name.
+		/// </summary>
+		/// <returns>The short name.</returns>
+		/// <param name="sn">Sn.</param>
+		public static Asn1Object FromShortName(string sn) 
+		{
 			return new Asn1Object(sn);
 		}
 
-		public static Asn1Object FromLongName(string sn) {
+		/// <summary>
+		/// Froms the long name.
+		/// </summary>
+		/// <returns>The long name.</returns>
+		/// <param name="sn">Sn.</param>
+		public static Asn1Object FromLongName(string sn) 
+		{
 			return new Asn1Object(Native.OBJ_ln2nid(sn));
 		}
-		
-		public override bool Equals(object obj) {
-			Asn1Object rhs = obj as Asn1Object;
+
+		/// <summary>
+		/// Determines whether the specified <see cref="System.Object"/> is equal to the current <see cref="OpenSSL.Core.Asn1Object"/>.
+		/// </summary>
+		/// <param name="obj">The <see cref="System.Object"/> to compare with the current <see cref="OpenSSL.Core.Asn1Object"/>.</param>
+		/// <returns><c>true</c> if the specified <see cref="System.Object"/> is equal to the current
+		/// <see cref="OpenSSL.Core.Asn1Object"/>; otherwise, <c>false</c>.</returns>
+		public override bool Equals(object obj) 
+		{
+			var rhs = obj as Asn1Object;
+
 			if (rhs == null)
 				return false;
-			return this.nid == rhs.nid;
+			
+			return nid == rhs.nid;
 		}
-		
-		public override int GetHashCode() {
-			return this.nid;
+
+		/// <summary>
+		/// Serves as a hash function for a <see cref="OpenSSL.Core.Asn1Object"/> object.
+		/// </summary>
+		/// <returns>A hash code for this instance that is suitable for use in hashing algorithms and data structures such as a hash table.</returns>
+		public override int GetHashCode() 
+		{
+			return nid;
 		}
 	}
 }
Index: ManagedOpenSsl/Core/Asn1String.cs
===================================================================
--- ManagedOpenSsl/Core/Asn1String.cs	(revision 47839)
+++ ManagedOpenSsl/Core/Asn1String.cs	(revision 47851)
@@ -24,8 +24,6 @@
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Runtime.InteropServices;
 
 namespace OpenSSL.Core
@@ -33,9 +31,9 @@
 	/// <summary>
 	/// Wraps ASN1_STRING_*
 	/// </summary>
-	public class Asn1String : BaseValueType, IComparable<Asn1String>
+	public class Asn1String : BaseValue, IComparable<Asn1String>
 	{
-		#region Intialization
+		#region Initialization
 		/// <summary>
 		/// Calls ASN1_STRING_type_new()
 		/// </summary>
@@ -61,7 +59,7 @@
 		public Asn1String(byte[] data)
 			: this()
 		{
-			Native.ExpectSuccess(Native.ASN1_STRING_set(this.ptr, data, data.Length));
+			Native.ExpectSuccess(Native.ASN1_STRING_set(ptr, data, data.Length));
 		}
 		#endregion
 
@@ -71,7 +69,7 @@
 		/// </summary>
 		public int Length
 		{
-			get { return Native.ASN1_STRING_length(this.ptr); }
+			get { return Native.ASN1_STRING_length(ptr); }
 		}
 
 		/// <summary>
@@ -81,9 +79,11 @@
 		{
 			get
 			{
-				IntPtr pData = Native.ASN1_STRING_data(this.ptr);
-				byte[] ret = new byte[this.Length];
+				var pData = Native.ASN1_STRING_data(ptr);
+				var ret = new byte[Length];
+
 				Marshal.Copy(pData, ret, 0, ret.Length);
+
 				return ret;
 			}
 		}
@@ -93,7 +93,7 @@
 
 		internal override IntPtr DuplicateHandle()
 		{
-			return Native.ASN1_STRING_dup(this.ptr);
+			return Native.ASN1_STRING_dup(ptr);
 		}
 
 		/// <summary>
@@ -101,7 +101,7 @@
 		/// </summary>
 		protected override void OnDispose()
 		{
-			Native.ASN1_STRING_free(this.ptr);
+			Native.ASN1_STRING_free(ptr);
 		}
 
 		#endregion
@@ -115,7 +115,7 @@
 		/// <returns></returns>
 		public int CompareTo(Asn1String other)
 		{
-			return Native.ASN1_STRING_cmp(this.ptr, other.Handle);
+			return Native.ASN1_STRING_cmp(ptr, other.Handle);
 		}
 
 		#endregion
Index: ManagedOpenSsl/Core/BIO.cs
===================================================================
--- ManagedOpenSsl/Core/BIO.cs	(revision 47839)
+++ ManagedOpenSsl/Core/BIO.cs	(revision 47851)
@@ -23,11 +23,10 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Crypto;
 using System;
-using System.Collections.Generic;
+using System.IO;
 using System.Text;
-using System.IO;
-using OpenSSL.Crypto;
 
 namespace OpenSSL.Core
 {
@@ -37,19 +36,22 @@
 	public class BIO : Base
 	{
 		#region Initialization
-		internal BIO(IntPtr ptr, bool owner) : base(ptr, owner) { }
+		internal BIO(IntPtr ptr, bool owner) : base(ptr, owner) 
+		{ 
+		}
 
 		/// <summary>
-		/// Calls BIO_new_mem_buf() from the specified buffer.
+		/// Calls BIO_new(BIO_s_mem()) and then BIO_write() the buf
 		/// </summary>
 		/// <param name="buf"></param>
 		public BIO(byte[] buf)
-			: base(Native.ExpectNonNull(Native.BIO_new_mem_buf(buf, buf.Length)), true)
+			: base(Native.ExpectNonNull(Native.BIO_new(Native.BIO_s_mem())), true)
 		{
+			Write(buf);
 		}
 
 		/// <summary>
-		/// Calls BIO_new_mem_buf() from the specified string.
+		/// Calls BIO_new(BIO_s_mem()) and then BIO_write() the str
 		/// </summary>
 		/// <param name="str"></param>
 		public BIO(string str)
@@ -64,7 +66,7 @@
 		/// <returns></returns>
 		public static BIO MemoryBuffer(bool takeOwnership)
 		{
-			IntPtr ptr = Native.ExpectNonNull(Native.BIO_new(Native.BIO_s_mem()));
+			var ptr = Native.ExpectNonNull(Native.BIO_new(Native.BIO_s_mem()));
 			return new BIO(ptr, takeOwnership);
 		}
 
@@ -85,7 +87,7 @@
 		/// <returns></returns>
 		public static BIO File(string filename, string mode)
 		{
-			IntPtr ptr = Native.ExpectNonNull(Native.BIO_new_file(filename, mode));
+			var ptr = Native.ExpectNonNull(Native.BIO_new_file(filename, mode));
 			return new BIO(ptr, true);
 		}
 
@@ -100,8 +102,9 @@
 		/// <returns></returns>
 		public static BIO MessageDigest(MessageDigest md)
 		{
-			IntPtr ptr = Native.ExpectNonNull(Native.BIO_new(Native.BIO_f_md()));
+			var ptr = Native.ExpectNonNull(Native.BIO_new(Native.BIO_f_md()));
 			Native.BIO_set_md(ptr, md.Handle);
+
 			return new BIO(ptr, true);
 		}
 
@@ -120,7 +123,7 @@
 		/// </summary>
 		public uint NumberRead
 		{
-			get { return Native.BIO_number_read(this.Handle); }
+			get { return Native.BIO_number_read(Handle); }
 		}
 
 		/// <summary>
@@ -128,7 +131,7 @@
 		/// </summary>
 		public uint NumberWritten
 		{
-			get { return Native.BIO_number_written(this.Handle); }
+			get { return Native.BIO_number_written(Handle); }
 		}
 
 		/// <summary>
@@ -136,7 +139,7 @@
 		/// </summary>
 		public uint BytesPending
 		{
-			get { return Native.BIO_ctrl_pending(this.Handle); }
+			get { return Native.BIO_ctrl_pending(Handle); }
 		}
 
 		#endregion
@@ -153,7 +156,7 @@
 			/// </summary>
 			NoClose = 0,
 			/// <summary>
-			/// Close on freee
+			/// Close on free
 			/// </summary>
 			Close = 1
 		}
@@ -164,7 +167,7 @@
 		/// <param name="opt"></param>
 		public void SetClose(CloseOption opt)
 		{
-			Native.BIO_set_close(this.ptr, (int)opt);
+			Native.BIO_set_close(ptr, (int)opt);
 		}
 
 		/// <summary>
@@ -173,7 +176,7 @@
 		/// <param name="bio"></param>
 		public void Push(BIO bio)
 		{
-			Native.ExpectNonNull(Native.BIO_push(this.ptr, bio.Handle));
+			Native.ExpectNonNull(Native.BIO_push(ptr, bio.Handle));
 		}
 
 		/// <summary>
@@ -182,7 +185,7 @@
 		/// <param name="buf"></param>
 		public void Write(byte[] buf)
 		{
-			if (Native.BIO_write(this.ptr, buf, buf.Length) != buf.Length)
+			if (Native.BIO_write(ptr, buf, buf.Length) != buf.Length)
 				throw new OpenSslException();
 		}
 
@@ -193,7 +196,7 @@
 		/// <param name="len"></param>
 		public void Write(byte[] buf, int len)
 		{
-			if (Native.BIO_write(this.ptr, buf, len) != len)
+			if (Native.BIO_write(ptr, buf, len) != len)
 				throw new OpenSslException();
 		}
 
@@ -203,7 +206,7 @@
 		/// <param name="value"></param>
 		public void Write(byte value)
 		{
-			byte[] buf = new byte[1];
+			var buf = new byte[1];
 			buf[0] = value;
 			Write(buf);
 		}
@@ -214,10 +217,12 @@
 		/// <param name="value"></param>
 		public void Write(ushort value)
 		{
-			MemoryStream ms = new MemoryStream();
-			BinaryWriter br = new BinaryWriter(ms);
+			var ms = new MemoryStream();
+			var br = new BinaryWriter(ms);
+
 			br.Write(value);
-			byte[] buf = ms.ToArray();
+			var buf = ms.ToArray();
+			
 			Write(buf);
 		}
 
@@ -227,10 +232,12 @@
 		/// <param name="value"></param>
 		public void Write(uint value)
 		{
-			MemoryStream ms = new MemoryStream();
-			BinaryWriter br = new BinaryWriter(ms);
+			var ms = new MemoryStream();
+			var br = new BinaryWriter(ms);
+
 			br.Write(value);
-			byte[] buf = ms.ToArray();
+			var buf = ms.ToArray();
+
 			Write(buf);
 		}
 
@@ -240,7 +247,8 @@
 		/// <param name="str"></param>
 		public void Write(string str)
 		{
-			byte[] buf = Encoding.ASCII.GetBytes(str);
+			var buf = Encoding.ASCII.GetBytes(str);
+
 			if (Native.BIO_puts(this.ptr, buf) != buf.Length)
 				throw new OpenSslException();
 		}
@@ -252,8 +260,9 @@
 		/// <returns></returns>
 		public ArraySegment<byte> ReadBytes(int count)
 		{
-			byte[] buf = new byte[count];
-			int ret = Native.BIO_read(this.ptr, buf, buf.Length);
+			var buf = new byte[count];
+			var ret = Native.BIO_read(ptr, buf, buf.Length);
+
 			if (ret < 0)
 				throw new OpenSslException();
 
@@ -266,13 +275,14 @@
 		/// <returns></returns>
 		public string ReadString()
 		{
-			StringBuilder sb = new StringBuilder();
+			var sb = new StringBuilder();
 			const int BLOCK_SIZE = 64;
-			byte[] buf = new byte[BLOCK_SIZE];
-			int ret = 0;
+			var buf = new byte[BLOCK_SIZE];
+			var ret = 0;
+
 			while (true)
 			{
-				ret = Native.BIO_gets(this.ptr, buf, buf.Length);
+				ret = Native.BIO_gets(ptr, buf, buf.Length);
 				if (ret == 0)
 					break;
 				if (ret < 0)
@@ -280,6 +290,7 @@
 
 				sb.Append(Encoding.ASCII.GetString(buf, 0, ret));
 			}
+
 			return sb.ToString();
 		}
 
@@ -301,7 +312,7 @@
 		/// </summary>
 		protected override void OnDispose()
 		{
-			Native.BIO_free(this.ptr);
+			Native.BIO_free(ptr);
 		}
 
 		#endregion
Index: ManagedOpenSsl/Core/Base.cs
===================================================================
--- ManagedOpenSsl/Core/Base.cs	(revision 47839)
+++ ManagedOpenSsl/Core/Base.cs	(revision 47851)
@@ -1,269 +1,252 @@
-﻿// Copyright (c) 2006-2009 Frank Laub
-// All rights reserved.
-
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-using System;
-using System.Collections.Generic;
-using System.Text;
-using System.Runtime.InteropServices;
-using System.Reflection;
-
-namespace OpenSSL.Core
-{
-	/// <summary>
-	/// Base class for all openssl wrapped objects. 
-	/// Contains the raw unmanaged pointer and has a Handle property to get access to it. 
-	/// Also overloads the ToString() method with a BIO print.
-	/// </summary>
-	public abstract class Base : IDisposable
-	{
-		/// <summary>
-		/// Constructor which takes the raw unmanged pointer. 
-		/// This is the only way to construct this object and all dervied types.
-		/// </summary>
-		/// <param name="ptr"></param>
-		/// <param name="takeOwnership"></param>
-		protected Base(IntPtr ptr, bool takeOwnership)
-		{
-			this.ptr = ptr;
-			this.owner = takeOwnership;
-			if (this.ptr != IntPtr.Zero)
-			{
-				this.OnNewHandle(this.ptr);
-			}
-		}
-
-		/// <summary>
-		/// This finalizer just calls Dispose().
-		/// </summary>
-		~Base()
-		{
-			Dispose();
-		}
-
-		/// <summary>
-		/// This method is used by the ToString() implementation. A great number of
-		/// openssl objects support printing, so this is a conveinence method.
-		/// Dervied types should override this method and not ToString().
-		/// </summary>
-		/// <param name="bio">The BIO stream object to print into</param>
-		public virtual void Print(BIO bio) { }
-
-		/// <summary>
-		/// Override of ToString() which uses Print() into a BIO memory buffer.
-		/// </summary>
-		/// <returns></returns>
-		public override string ToString() {
-			try {
-				if (this.ptr == IntPtr.Zero)
-					return "(null)";
-
-				using (BIO bio = BIO.MemoryBuffer()) {
-					this.Print(bio);
-					return bio.ReadString();
-				}
-			}
-			catch (Exception) {
-				return "<exception>";
-			}
-		}
-
-		/// <summary>
-		/// This method must be implemented in derived classes.
-		/// </summary>
-		protected abstract void OnDispose();
-
-		/// <summary>
-		/// Do nothing in the base class.
-		/// </summary>
-		/// <param name="ptr"></param>
-		internal virtual void OnNewHandle(IntPtr ptr)
-		{
-		}
-
-		#region IDisposable Members
-
-		/// <summary>
-		/// Implementation of the IDisposable interface.
-		/// If the native pointer is not null, we haven't been disposed, and we are the owner,
-		/// then call the virtual OnDispose() method.
-		/// </summary>
-		public void Dispose() {
-			if (!this.isDisposed && this.owner && this.ptr != IntPtr.Zero) {
-				this.OnDispose();
-				DoAfterDispose();
-			}
-			this.isDisposed = true;
-		}
-
-		#endregion
-
-		/// <summary>
-		/// gets/sets whether the object owns the Native pointer
-		/// </summary>
-		public virtual bool IsOwner
-		{
-			get { return owner; }
-			internal set { owner = value; }
-		}
-
-		/// <summary>
-		/// Access to the raw unmanaged pointer.
-		/// </summary>
-		public virtual IntPtr Handle
-		{
-			get { return this.ptr; }
-		}
-
-		/// <summary>
-		/// Throws NotImplementedException
-		/// </summary>
-		internal virtual void AddRef()
-		{
-			throw new NotImplementedException();
-		}
-
-		private void DoAfterDispose()
-		{
-			this.ptr = IntPtr.Zero;
-			GC.SuppressFinalize(this);
-		}
-
-		/// <summary>
-		/// Raw unmanaged pointer
-		/// </summary>
-		protected IntPtr ptr;
-
-		/// <summary>
-		/// If this object is the owner, then call the appropriate native free function.
-		/// </summary>
-		protected bool owner = false;
-
-		/// <summary>
-		/// This is to prevent double-deletion issues.
-		/// </summary>
-		protected bool isDisposed = false;
-
-	}
-
-	/// <summary>
-	/// Helper type that handles the AddRef() method.
-	/// Derived classes must implement the <code>LockType</code> and <code>RawReferenceType</code> properties
-	/// </summary>
-	public abstract class BaseReferenceType : Base
-	{
-		internal BaseReferenceType(IntPtr ptr, bool takeOwnership)
-			: base(ptr, takeOwnership)
-		{
-			this.baseOffset = Marshal.OffsetOf(RawReferenceType, "references");
-		}
-
-		internal override void AddRef()
-		{
-			IntPtr offset = GetReferencesOffset();
-			Native.CRYPTO_add_lock(offset, 1, LockType, "Base.cs", 0);
-		}
-
-		/// <summary>
-		/// Prints the current underlying reference count
-		/// </summary>
-		public void PrintRefCount()
-		{
-			IntPtr offset = GetReferencesOffset();
-			int count = Marshal.ReadInt32(offset);
-			Console.WriteLine("{0} ptr: {1}, ref_count: {2}", this.GetType().Name, this.ptr, count);
-		}
-
-		private IntPtr GetReferencesOffset()
-		{
-			return new IntPtr((long)this.ptr + (long)this.baseOffset);
-		}
-
-		/// <summary>
-		/// Derived classes must return a <code>CryptoLockTypes</code> for this type
-		/// </summary>
-		internal abstract CryptoLockTypes LockType { get; }
-
-		/// <summary>
-		/// Derived classes must return a <code>Type</code> that matches the underlying type
-		/// </summary>
-		internal abstract Type RawReferenceType { get; }
-
-		private IntPtr baseOffset;
-	}
-
-	/// <summary>
-	/// Implements the CopyRef() method
-	/// </summary>
-	/// <typeparam name="T"></typeparam>
-	public abstract class BaseCopyableRef<T> : BaseReferenceType where T : BaseCopyableRef<T>
-	{
-		internal BaseCopyableRef(IntPtr ptr, bool takeOwnership)
-			: base(ptr, takeOwnership)
-		{
-		}
-
-		internal T CopyRef()
-		{
-			object[] args = new object[] {
-				this.ptr,
-				true
-			};
-			BindingFlags flags =
-				BindingFlags.NonPublic |
-				BindingFlags.Public |
-				BindingFlags.Instance;
-			T ret = (T)Activator.CreateInstance(typeof(T), flags, null, args, null);
-			ret.AddRef();
-			return ret;
-		}
-	}
-
-	/// <summary>
-	/// Helper base class that handles the AddRef() method by using a _dup() method.
-	/// </summary>
-	public abstract class BaseValueType : Base
-	{
-		internal BaseValueType(IntPtr ptr, bool takeOwnership)
-			: base(ptr, takeOwnership)
-		{
-		}
-
-		internal override void AddRef()
-		{
-			this.ptr = DuplicateHandle();
-			this.owner = true;
-			if (this.ptr != IntPtr.Zero)
-			{
-				this.OnNewHandle(this.ptr);
-			}
-		}
-
-		/// <summary>
-		/// Derived classes must use a _dup() method to make a copy of the underlying native data structure.
-		/// </summary>
-		/// <returns></returns>
-		internal abstract IntPtr DuplicateHandle();
-	}
-}
+﻿// Copyright (c) 2006-2009 Frank Laub
+// All rights reserved.
+
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+using System;
+using System.Reflection;
+using System.Runtime.InteropServices;
+
+namespace OpenSSL.Core
+{
+	/// <summary>
+	/// Base class for all openssl wrapped objects. 
+	/// Contains the raw unmanaged pointer and has a Handle property to get access to it. 
+	/// Also overloads the ToString() method with a BIO print.
+	/// </summary>
+	public abstract class Base : IDisposable
+	{
+		/// <summary>
+		/// Constructor which takes the raw unmanaged pointer. 
+		/// This is the only way to construct this object and all derived types.
+		/// </summary>
+		/// <param name="ptr"></param>
+		/// <param name="takeOwnership"></param>
+		protected Base(IntPtr ptr, bool takeOwnership)
+		{
+			this.ptr = ptr;
+			owner = takeOwnership;
+			if (this.ptr != IntPtr.Zero)
+			{
+				OnNewHandle(this.ptr);
+			}
+		}
+
+		/// <summary>
+		/// This finalizer just calls Dispose().
+		/// </summary>
+		~Base()
+		{
+			Dispose();
+		}
+
+		/// <summary>
+		/// This method is used by the ToString() implementation. A great number of
+		/// openssl objects support printing, so this is a convenience method.
+		/// Derived types should override this method and not ToString().
+		/// </summary>
+		/// <param name="bio">The BIO stream object to print into</param>
+		public virtual void Print(BIO bio)
+		{
+		}
+
+		/// <summary>
+		/// Override of ToString() which uses Print() into a BIO memory buffer.
+		/// </summary>
+		/// <returns></returns>
+		public override string ToString()
+		{
+			try
+			{
+				if (ptr == IntPtr.Zero)
+					return "(null)";
+
+				using (var bio = BIO.MemoryBuffer())
+				{
+					Print(bio);
+					return bio.ReadString();
+				}
+			}
+			catch (Exception)
+			{
+				return "<exception>";
+			}
+		}
+
+		/// <summary>
+		/// This method must be implemented in derived classes.
+		/// </summary>
+		protected abstract void OnDispose();
+
+		/// <summary>
+		/// Do nothing in the base class.
+		/// </summary>
+		/// <param name="ptr"></param>
+		internal virtual void OnNewHandle(IntPtr ptr)
+		{
+		}
+
+		#region IDisposable Members
+
+		/// <summary>
+		/// Implementation of the IDisposable interface.
+		/// If the native pointer is not null, we haven't been disposed, and we are the owner,
+		/// then call the virtual OnDispose() method.
+		/// </summary>
+		public void Dispose()
+		{
+			if (!isDisposed && owner && ptr != IntPtr.Zero)
+			{
+				OnDispose();
+				DoAfterDispose();
+			}
+
+			isDisposed = true;
+		}
+
+		#endregion
+
+		/// <summary>
+		/// gets/sets whether the object owns the Native pointer
+		/// </summary>
+		public virtual bool IsOwner
+		{
+			get { return owner; }
+			internal set { owner = value; }
+		}
+
+		/// <summary>
+		/// Access to the raw unmanaged pointer.
+		/// </summary>
+		public virtual IntPtr Handle
+		{
+			get { return ptr; }
+		}
+
+		private void DoAfterDispose()
+		{
+			ptr = IntPtr.Zero;
+			GC.SuppressFinalize(this);
+		}
+
+		/// <summary>
+		/// Raw unmanaged pointer
+		/// </summary>
+		protected IntPtr ptr;
+
+		/// <summary>
+		/// If this object is the owner, then call the appropriate native free function.
+		/// </summary>
+		protected bool owner = false;
+
+		/// <summary>
+		/// This is to prevent double-deletion issues.
+		/// </summary>
+		protected bool isDisposed = false;
+	}
+
+	/// <summary>
+	/// Helper type that handles the AddRef() method.
+	/// </summary>
+	public abstract class BaseReference : Base
+	{
+		internal BaseReference(IntPtr ptr, bool takeOwnership)
+			: base(ptr, takeOwnership)
+		{
+		}
+
+		internal abstract void AddRef();
+	}
+
+	/// <summary>
+	/// Derived classes must implement the <code>LockType</code> and <code>RawReferenceType</code> properties
+	/// </summary>
+	public abstract class BaseReferenceImpl : BaseReference
+	{
+		internal BaseReferenceImpl(IntPtr ptr, bool takeOwnership)
+			: base(ptr, takeOwnership)
+		{
+			var offset = Marshal.OffsetOf(RawReferenceType, "references");
+			refPtr = new IntPtr((long)ptr + (long)offset);
+		}
+
+		/// <summary>
+		/// Prints the current underlying reference count 
+		/// </summary>
+		public void PrintRefCount()
+		{
+			var count = Marshal.ReadInt32(refPtr);
+			Console.WriteLine("{0} ptr: {1}, ref_count: {2}", 
+				this.GetType().Name, this.ptr, count
+			);
+		}
+
+		/// <summary>
+		/// Gets the reference count.
+		/// </summary>
+		/// <value>The reference count.</value>
+		public int RefCount
+		{
+			get { return Marshal.ReadInt32(refPtr); }
+		}
+
+		internal override void AddRef()
+		{
+			Native.CRYPTO_add_lock(refPtr, 1, LockType, "Base.cs", 0);
+		}
+	
+		internal abstract CryptoLockTypes LockType { get; }
+
+		internal abstract Type RawReferenceType { get; }
+
+		private IntPtr refPtr;
+	}
+
+	/// <summary>
+	/// Helper base class that handles the AddRef() method by using a _dup() method.
+	/// </summary>
+	public abstract class BaseValue : BaseReference
+	{
+		internal BaseValue(IntPtr ptr, bool takeOwnership)
+			: base(ptr, takeOwnership)
+		{
+		}
+
+		internal override void AddRef()
+		{
+			ptr = DuplicateHandle();
+			owner = true;
+
+			if (ptr != IntPtr.Zero)
+			{
+				OnNewHandle(ptr);
+			}
+		}
+
+		/// <summary>
+		/// Derived classes must use a _dup() method to make a copy of the underlying native data structure.
+		/// </summary>
+		/// <returns></returns>
+		internal abstract IntPtr DuplicateHandle();
+	}
+}
Index: ManagedOpenSsl/Core/BigNumber.cs
===================================================================
--- ManagedOpenSsl/Core/BigNumber.cs	(revision 47839)
+++ ManagedOpenSsl/Core/BigNumber.cs	(revision 47851)
@@ -1,450 +1,495 @@
-// Copyright (c) 2006-2012 Frank Laub
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-using System;
-using System.Collections.Generic;
-using System.Text;
-using System.Runtime.InteropServices;
-using System.Diagnostics;
-
-namespace OpenSSL.Core
-{
-	/// <summary>
-	/// Wraps the BN_* set of functions.
-	/// </summary>
-	public class BigNumber : Base, IComparable<BigNumber>
-	{
-		#region Predefined Values
-		/// <summary>
-		/// Creates a BigNumber object by calling BN_value_one()
-		/// </summary>
-		public static BigNumber One = new BigNumber(Native.BN_value_one(), false);
-
-		/// <summary>
-		/// Calls BN_options()
-		/// </summary>
-		public static string Options
-		{
-			get { return Native.BN_options(); }
-		}
-		#endregion
-
-		#region Initialization
-		internal BigNumber(IntPtr ptr, bool owner) : base(ptr, owner) { }
-		/// <summary>
-		/// Calls BN_new()
-		/// </summary>
-		public BigNumber()
-			: base(Native.ExpectNonNull(Native.BN_new()), true)
-		{
-		}
-
-		/// <summary>
-		/// Calls BN_dup() on the BigNumber passed in.
-		/// </summary>
-		/// <param name="rhs"></param>
-		public BigNumber(BigNumber rhs)
-			: base(Native.BN_dup(rhs.ptr), true)
-		{
-		}
-
-		/// <summary>
-		/// Creates a BigNumber by calling BN_set_word()
-		/// </summary>
-		/// <param name="value"></param>
-		public BigNumber(uint value)
-			: this()
-		{
-			Native.ExpectSuccess(Native.BN_set_word(this.ptr, value));
-		}
-		#endregion
-
-		#region Conversion
-		/// <summary>
-		/// Calls BN_dec2bn()
-		/// </summary>
-		/// <param name="str"></param>
-		/// <returns></returns>
-		public static BigNumber FromDecimalString(string str)
-		{
-			byte[] buf = Encoding.ASCII.GetBytes(str);
-			IntPtr ptr;
-            int ret = Native.BN_dec2bn(out ptr, buf);
-            if (ret <= 0)
-                throw new OpenSslException();
-            return new BigNumber(ptr, true);
-		}
-
-		/// <summary>
-		/// Calls BN_hex2bn()
-		/// </summary>
-		/// <param name="str"></param>
-		/// <returns></returns>
-		public static BigNumber FromHexString(string str)
-		{
-			byte[] buf = Encoding.ASCII.GetBytes(str);
-			IntPtr ptr;
-            int ret = Native.BN_hex2bn(out ptr, buf);
-            if (ret <= 0)
-                throw new OpenSslException();
-			return new BigNumber(ptr, true);
-		}
-
-		/// <summary>
-		/// Calls BN_bin2bn()
-		/// </summary>
-		/// <param name="buf"></param>
-		/// <returns></returns>
-		public static BigNumber FromArray(byte[] buf)
-		{
-			IntPtr ptr = Native.BN_bin2bn(buf, buf.Length, IntPtr.Zero);
-			return new BigNumber(Native.ExpectNonNull(ptr), true);
-		}
-
-		/// <summary>
-		/// Calls BN_bn2dec()
-		/// </summary>
-		/// <returns></returns>
-		public string ToDecimalString()
-		{
-			return Native.PtrToStringAnsi(Native.BN_bn2dec(this.ptr), true);
-		}
-
-		/// <summary>
-		/// Calls BN_bn2hex()
-		/// </summary>
-		/// <returns></returns>
-		public string ToHexString()
-		{
-			return Native.PtrToStringAnsi(Native.BN_bn2hex(this.ptr), true);
-		}
-
-		/// <summary>
-		/// Calls BN_get_word()
-		/// </summary>
-		/// <param name="rhs"></param>
-		/// <returns></returns>
-		public static implicit operator uint(BigNumber rhs)
-		{
-			return Native.BN_get_word(rhs.ptr);
-		}
-
-		/// <summary>
-		/// Creates a new BigNumber object from a uint.
-		/// </summary>
-		/// <param name="value"></param>
-		/// <returns></returns>
-		public static implicit operator BigNumber(uint value)
-		{
-			return new BigNumber(value);
-		}
-
-		/// <summary>
-		/// Calls BN_bn2bin()
-		/// </summary>
-		/// <param name="rhs"></param>
-		/// <returns></returns>
-		public static implicit operator byte[](BigNumber rhs)
-		{
-			byte[] bytes = new byte[rhs.Bytes];
-			Native.ExpectSuccess(Native.BN_bn2bin(rhs.ptr, bytes));
-			return bytes;
-		}
-		
+// Copyright (c) 2006-2012 Frank Laub
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+using System;
+using System.Text;
+
+namespace OpenSSL.Core
+{
+	/// <summary>
+	/// Wraps the BN_* set of functions.
+	/// </summary>
+	public class BigNumber : Base, IComparable<BigNumber>
+	{
+		#region Predefined Values
 		/// <summary>
+		/// Creates a BigNumber object by calling BN_value_one()
+		/// </summary>
+		public static BigNumber One = new BigNumber(Native.BN_value_one(), false);
+
+		/// <summary>
+		/// Calls BN_options()
+		/// </summary>
+		public static string Options
+		{
+			get { return Native.StaticString(Native.BN_options()); }
+		}
+		#endregion
+
+		#region Initialization
+		internal BigNumber(IntPtr ptr, bool owner) : base(ptr, owner) { }
+		/// <summary>
+		/// Calls BN_new()
+		/// </summary>
+		public BigNumber()
+			: base(Native.ExpectNonNull(Native.BN_new()), true)
+		{
+		}
+
+		/// <summary>
+		/// Calls BN_dup() on the BigNumber passed in.
+		/// </summary>
+		/// <param name="rhs"></param>
+		public BigNumber(BigNumber rhs)
+			: base(Native.BN_dup(rhs.ptr), true)
+		{
+		}
+
+		/// <summary>
+		/// Creates a BigNumber by calling BN_set_word()
+		/// </summary>
+		/// <param name="value"></param>
+		public BigNumber(uint value)
+			: this()
+		{
+			Native.ExpectSuccess(Native.BN_set_word(ptr, value));
+		}
+		#endregion
+
+		#region Conversion
+		/// <summary>
+		/// Calls BN_dec2bn()
+		/// </summary>
+		/// <param name="str"></param>
+		/// <returns></returns>
+		public static BigNumber FromDecimalString(string str)
+		{
+			var buf = Encoding.ASCII.GetBytes(str);
+			IntPtr ptr;
+
+			var ret = Native.BN_dec2bn(out ptr, buf);
+			if (ret <= 0)
+				throw new OpenSslException();
+
+			return new BigNumber(ptr, true);
+		}
+
+		/// <summary>
+		/// Calls BN_hex2bn()
+		/// </summary>
+		/// <param name="str"></param>
+		/// <returns></returns>
+		public static BigNumber FromHexString(string str)
+		{
+			var buf = Encoding.ASCII.GetBytes(str);
+			IntPtr ptr;
+
+			var ret = Native.BN_hex2bn(out ptr, buf);
+			if (ret <= 0)
+				throw new OpenSslException();
+
+			return new BigNumber(ptr, true);
+		}
+
+		/// <summary>
+		/// Calls BN_bin2bn()
+		/// </summary>
+		/// <param name="buf"></param>
+		/// <returns></returns>
+		public static BigNumber FromArray(byte[] buf)
+		{
+			var ptr = Native.BN_bin2bn(buf, buf.Length, IntPtr.Zero);
+			return new BigNumber(Native.ExpectNonNull(ptr), true);
+		}
+
+		/// <summary>
+		/// Calls BN_bn2dec()
+		/// </summary>
+		/// <returns></returns>
+		public string ToDecimalString()
+		{
+			return Native.PtrToStringAnsi(Native.BN_bn2dec(ptr), true);
+		}
+
+		/// <summary>
+		/// Calls BN_bn2hex()
+		/// </summary>
+		/// <returns></returns>
+		public string ToHexString()
+		{
+			return Native.PtrToStringAnsi(Native.BN_bn2hex(ptr), true);
+		}
+
+		/// <summary>
+		/// Calls BN_get_word()
+		/// </summary>
+		/// <param name="rhs"></param>
+		/// <returns></returns>
+		public static implicit operator uint(BigNumber rhs)
+		{
+			return Native.BN_get_word(rhs.ptr);
+		}
+
+		/// <summary>
+		/// Creates a new BigNumber object from a uint.
+		/// </summary>
+		/// <param name="value"></param>
+		/// <returns></returns>
+		public static implicit operator BigNumber(uint value)
+		{
+			return new BigNumber(value);
+		}
+
+		/// <summary>
 		/// Calls BN_bn2bin()
 		/// </summary>
-		/// <param name="bytes"></param>
-		public void ToBytes(byte[] bytes)
-		{
-			Native.ExpectSuccess(Native.BN_bn2bin(this.ptr, bytes));
-		}
-
-		#endregion
-
-		#region Properties
-		/// <summary>
-		/// Returns BN_num_bits()
-		/// </summary>
-		public int Bits
-		{
-			get { return Native.BN_num_bits(this.ptr); }
-		}
-
-		/// <summary>
-		/// Converts the result of Bits into the number of bytes.
-		/// </summary>
-		public int Bytes
-		{
-			get { return (this.Bits + 7) / 8; }
-		}
-		#endregion
-
-		#region Methods
-		/// <summary>
-		/// Calls BN_clear()
-		/// </summary>
-		public void Clear()
-		{
-			Native.BN_clear(this.ptr);
-		}
-
-		/// <summary>
-		/// Calls BN_rand_range()
-		/// </summary>
-		/// <param name="range"></param>
-		/// <returns></returns>
-		public static BigNumber NextRange(BigNumber range)
-		{
-			BigNumber bn = new BigNumber();
-			Native.ExpectSuccess(Native.BN_rand_range(bn.Handle, range.Handle));
-			return bn;
-		}
-
-		/// <summary>
-		/// Calls BN_pseudo_rand()
-		/// </summary>
-		/// <param name="bits"></param>
-		/// <param name="top"></param>
-		/// <param name="bottom"></param>
-		/// <returns></returns>
-		public static BigNumber PseudoNext(int bits, int top, int bottom)
-		{
-			BigNumber bn = new BigNumber();
-			Native.ExpectSuccess(Native.BN_pseudo_rand(bn.Handle, bits, top, bottom));
-			return bn;
-		}
-
-		/// <summary>
-		/// Calls BN_pseudo_rand_range()
-		/// </summary>
-		/// <param name="range"></param>
-		/// <returns></returns>
-		public static BigNumber PseudoNextRange(BigNumber range)
-		{
-			BigNumber bn = new BigNumber();
-			Native.ExpectSuccess(Native.BN_pseudo_rand_range(bn.Handle, range.Handle));
-			return bn;
-		}
-		
-		
-		#endregion
-
-		#region Operators
-		/// <summary>
-		/// Calls BN_add()
-		/// </summary>
-		/// <param name="lhs"></param>
-		/// <param name="rhs"></param>
-		/// <returns></returns>
-		public static BigNumber operator + (BigNumber lhs, BigNumber rhs)
-		{
-			BigNumber ret = new BigNumber();
-			Native.ExpectSuccess(Native.BN_add(ret.Handle, lhs.Handle, rhs.Handle));
-			return ret;
-		}
-
-		/// <summary>
-		/// Calls BN_sub()
-		/// </summary>
-		/// <param name="lhs"></param>
-		/// <param name="rhs"></param>
-		/// <returns></returns>
-		public static BigNumber operator -(BigNumber lhs, BigNumber rhs)
-		{
-			BigNumber ret = new BigNumber();
-			Native.ExpectSuccess(Native.BN_sub(ret.Handle, lhs.Handle, rhs.Handle));
-			return ret;
-		}
-
-		/// <summary>
-		/// Determines if lhs is by-value equal to rhs
-		/// </summary>
-		/// <param name="lhs"></param>
-		/// <param name="rhs"></param>
-		/// <returns></returns>
-        public static bool operator ==(BigNumber lhs, BigNumber rhs)
-        {
-			if (object.ReferenceEquals(lhs, rhs))
-				return true;
-			if ((object)lhs == null || (object)rhs == null)
-				return false;
-			return lhs.Equals(rhs);
-        }
-
-		/// <summary>
-		/// Determines if lhs is by-value different than rhs
-		/// </summary>
-		/// <param name="lhs"></param>
-		/// <param name="rhs"></param>
-		/// <returns></returns>
-        public static bool operator !=(BigNumber lhs, BigNumber rhs)
-        {
-			return !(lhs == rhs);
-        }
-		#endregion
-
-		#region Overrides
-		/// <summary>
-		/// Calls BN_cmp()
-		/// </summary>
-		/// <param name="obj"></param>
-		/// <returns></returns>
-		public override bool Equals(object obj)
-		{
-			BigNumber rhs = obj as BigNumber;
-			if ((object)rhs == null)
-				return false;
-			return Native.BN_cmp(this.ptr, rhs.ptr) == 0;
-		}
-
-		/// <summary>
-		/// Creates a hash code by converting this object to a decimal string and 
-		/// returns the hash code of that string.
-		/// </summary>
-		/// <returns></returns>
-		public override int GetHashCode()
-		{
-			return ToDecimalString().GetHashCode();
-		}
-
-		/// <summary>
-		/// Calls BN_print()
-		/// </summary>
-		/// <param name="bio"></param>
-		public override void Print(BIO bio)
-		{
-			Native.ExpectSuccess(Native.BN_print(bio.Handle, this.ptr));
-		}
-		#endregion
-
-		#region IDisposable Members
-
-		/// <summary>
-		/// Calls BN_free()
-		/// </summary>
-		protected override void OnDispose() {
-			Native.BN_free(this.ptr);
-		}
-
-		#endregion
-
-		#region IComparable<BigNumber> Members
-
-		/// <summary>
-		/// Calls BN_cmp()
-		/// </summary>
-		/// <param name="other"></param>
-		/// <returns></returns>
-		public int CompareTo(BigNumber other)
-		{
-			return Native.BN_cmp(this.ptr, other.ptr);
-		}
-
-		#endregion
-
-		#region Callbacks
-
-		/// <summary>
-		/// Generator callback. Used mostly for status indications for long-
-		/// running generator functions.
-		/// </summary>
-		/// <param name="p"></param>
-		/// <param name="n"></param>
-		/// <param name="arg"></param>
-		/// <returns></returns>
-		public delegate int GeneratorHandler(int p, int n, object arg);
-
-		internal class GeneratorThunk
-		{
-			private Native.bn_gencb_st gencb = new Native.bn_gencb_st();
-			private GeneratorHandler OnGenerator;
-			private object arg;
-
-			public Native.bn_gencb_st CallbackStruct
-			{
-				get { return this.gencb; }
-			}
-
-			public GeneratorThunk(GeneratorHandler client, object arg) 
-			{
-				this.OnGenerator = client;
-				this.arg = arg;
-
-				this.gencb.ver = 2;
-				this.gencb.arg = IntPtr.Zero;
-				this.gencb.cb = this.OnGeneratorThunk;
-			}
-
-			internal int OnGeneratorThunk(int p, int n, IntPtr arg)
-			{
-                if (OnGenerator != null)
-                {
-                    try
-                    {
-                        return OnGenerator(p, n, this.arg);
-                    }
-                    catch (Exception)
-                    {
-                        return 0;
-                    }
-                }
-                else
-                {
-                    // return 1 to allow generation to succeed with
-                    // no user callback
-                    return 1;
-                }
-			}
-		}
-
-		#endregion
-		
-		#region Context
-		public class Context : Base
-		{
-			public Context()
-				: base(Native.ExpectNonNull(Native.BN_CTX_new()), true) {
-			}
-			
-			public BigNumber BigNumber {
-				get { return new BigNumber(Native.ExpectNonNull(Native.BN_CTX_get(this.ptr)), false); }
-			}
-			
-			public void Start() {
-				Native.BN_CTX_start(this.ptr);
-			}
-			
-			public void End() {
-				Native.BN_CTX_end(this.ptr);
-			}
-			
-			protected override void OnDispose() {
-				Native.BN_CTX_free(this.ptr);
-			}
-		}
-		#endregion
-	}
-}
\ No newline at end of file
+		/// <param name="rhs"></param>
+		/// <returns></returns>
+		public static implicit operator byte[](BigNumber rhs)
+		{
+			var bytes = new byte[rhs.Bytes];
+			Native.ExpectSuccess(Native.BN_bn2bin(rhs.ptr, bytes));
+
+			return bytes;
+		}
+
+		/// <summary>
+		/// Calls BN_bn2bin()
+		/// </summary>
+		/// <param name="bytes"></param>
+		public void ToBytes(byte[] bytes)
+		{
+			Native.ExpectSuccess(Native.BN_bn2bin(ptr, bytes));
+		}
+
+		#endregion
+
+		#region Properties
+		/// <summary>
+		/// Returns BN_num_bits()
+		/// </summary>
+		public int Bits
+		{
+			get { return Native.BN_num_bits(ptr); }
+		}
+
+		/// <summary>
+		/// Converts the result of Bits into the number of bytes.
+		/// </summary>
+		public int Bytes
+		{
+			get { return (Bits + 7) / 8; }
+		}
+		#endregion
+
+		#region Methods
+		/// <summary>
+		/// Calls BN_clear()
+		/// </summary>
+		public void Clear()
+		{
+			Native.BN_clear(ptr);
+		}
+
+		/// <summary>
+		/// Calls BN_rand_range()
+		/// </summary>
+		/// <param name="range"></param>
+		/// <returns></returns>
+		public static BigNumber NextRange(BigNumber range)
+		{
+			BigNumber bn = new BigNumber();
+			Native.ExpectSuccess(Native.BN_rand_range(bn.Handle, range.Handle));
+			return bn;
+		}
+
+		/// <summary>
+		/// Calls BN_pseudo_rand()
+		/// </summary>
+		/// <param name="bits"></param>
+		/// <param name="top"></param>
+		/// <param name="bottom"></param>
+		/// <returns></returns>
+		public static BigNumber PseudoNext(int bits, int top, int bottom)
+		{
+			var bn = new BigNumber();
+			Native.ExpectSuccess(Native.BN_pseudo_rand(bn.Handle, bits, top, bottom));
+
+			return bn;
+		}
+
+		/// <summary>
+		/// Calls BN_pseudo_rand_range()
+		/// </summary>
+		/// <param name="range"></param>
+		/// <returns></returns>
+		public static BigNumber PseudoNextRange(BigNumber range)
+		{
+			var bn = new BigNumber();
+			Native.ExpectSuccess(Native.BN_pseudo_rand_range(bn.Handle, range.Handle));
+
+			return bn;
+		}
+		#endregion
+
+		#region Operators
+        /// <summary>
+        /// Calls BN_add()
+        /// </summary>
+        /// <param name="lhs"></param>
+        /// <param name="rhs"></param>
+        /// <returns></returns>
+        public static BigNumber operator +(BigNumber lhs, BigNumber rhs)
+        {
+            var ret = new BigNumber();
+            Native.ExpectSuccess(Native.BN_add(ret.Handle, lhs.Handle, rhs.Handle));
+
+            return ret;
+        }
+
+	    /// <summary>
+	    /// Calls BN_mul()
+	    /// </summary>
+	    /// <param name="lhs"></param>
+	    /// <param name="rhs"></param>
+	    /// <param name="ctx"></param>
+	    /// <returns></returns>
+	    public static BigNumber Multiply(BigNumber lhs, BigNumber rhs, Context ctx)
+        {
+            var ret = new BigNumber();
+            Native.ExpectSuccess(Native.BN_mul(ret.Handle, lhs.Handle, rhs.Handle, ctx.Handle));
+
+            return ret;
+        }
+
+		/// <summary>
+		/// Calls BN_sub()
+		/// </summary>
+		/// <param name="lhs"></param>
+		/// <param name="rhs"></param>
+		/// <returns></returns>
+		public static BigNumber operator -(BigNumber lhs, BigNumber rhs)
+		{
+			var ret = new BigNumber();
+			Native.ExpectSuccess(Native.BN_sub(ret.Handle, lhs.Handle, rhs.Handle));
+
+			return ret;
+		}
+
+		/// <summary>
+		/// Determines if lhs is by-value equal to rhs
+		/// </summary>
+		/// <param name="lhs"></param>
+		/// <param name="rhs"></param>
+		/// <returns></returns>
+		public static bool operator ==(BigNumber lhs, BigNumber rhs)
+		{
+			if (ReferenceEquals(lhs, rhs))
+				return true;
+			if ((object)lhs == null || (object)rhs == null)
+				return false;
+
+			return lhs.Equals(rhs);
+		}
+
+		/// <summary>
+		/// Determines if lhs is by-value different than rhs
+		/// </summary>
+		/// <param name="lhs"></param>
+		/// <param name="rhs"></param>
+		/// <returns></returns>
+		public static bool operator !=(BigNumber lhs, BigNumber rhs)
+		{
+			return !(lhs == rhs);
+		}
+		#endregion
+
+		#region Overrides
+		/// <summary>
+		/// Calls BN_cmp()
+		/// </summary>
+		/// <param name="obj"></param>
+		/// <returns></returns>
+		public override bool Equals(object obj)
+		{
+			var rhs = obj as BigNumber;
+			if ((object)rhs == null)
+				return false;
+
+			return Native.BN_cmp(ptr, rhs.ptr) == 0;
+		}
+
+		/// <summary>
+		/// Creates a hash code by converting this object to a decimal string and 
+		/// returns the hash code of that string.
+		/// </summary>
+		/// <returns></returns>
+		public override int GetHashCode()
+		{
+			return ToDecimalString().GetHashCode();
+		}
+
+		/// <summary>
+		/// Calls BN_print()
+		/// </summary>
+		/// <param name="bio"></param>
+		public override void Print(BIO bio)
+		{
+			Native.ExpectSuccess(Native.BN_print(bio.Handle, ptr));
+		}
+		#endregion
+
+		#region IDisposable Members
+
+		/// <summary>
+		/// Calls BN_free()
+		/// </summary>
+		protected override void OnDispose()
+		{
+			Native.BN_free(ptr);
+		}
+
+		#endregion
+
+		#region IComparable<BigNumber> Members
+
+		/// <summary>
+		/// Calls BN_cmp()
+		/// </summary>
+		/// <param name="other"></param>
+		/// <returns></returns>
+		public int CompareTo(BigNumber other)
+		{
+			return Native.BN_cmp(ptr, other.ptr);
+		}
+
+		#endregion
+
+		#region Callbacks
+
+		/// <summary>
+		/// Generator callback. Used mostly for status indications for long-
+		/// running generator functions.
+		/// </summary>
+		/// <param name="p"></param>
+		/// <param name="n"></param>
+		/// <param name="arg"></param>
+		/// <returns></returns>
+		public delegate int GeneratorHandler(int p, int n, object arg);
+
+		internal class GeneratorThunk
+		{
+			private Native.bn_gencb_st gencb = new Native.bn_gencb_st();
+			private GeneratorHandler OnGenerator;
+			private object arg;
+
+			public Native.bn_gencb_st CallbackStruct
+			{
+				get { return gencb; }
+			}
+
+			public GeneratorThunk(GeneratorHandler client, object arg)
+			{
+				OnGenerator = client;
+				this.arg = arg;
+
+				gencb.ver = 2;
+				gencb.arg = IntPtr.Zero;
+				gencb.cb = OnGeneratorThunk;
+			}
+
+			internal int OnGeneratorThunk(int p, int n, IntPtr arg)
+			{
+				if (OnGenerator != null)
+				{
+					try
+					{
+						return OnGenerator(p, n, this.arg);
+					}
+					catch (Exception)
+					{
+						return 0;
+					}
+				}
+				else
+				{
+					// return 1 to allow generation to succeed with
+					// no user callback
+					return 1;
+				}
+			}
+		}
+
+		#endregion
+
+		#region Context
+		/// <summary>
+		/// Wraps BN_CTX
+		/// </summary>
+		public class Context : Base
+		{
+			/// <summary>
+			/// Calls BN_CTX_new()
+			/// </summary>
+			public Context()
+				: base(Native.ExpectNonNull(Native.BN_CTX_new()), true)
+			{
+			}
+
+			/// <summary>
+			/// Returns BN_CTX_get()
+			/// </summary>
+			public BigNumber BigNumber
+			{
+				get { return new BigNumber(Native.ExpectNonNull(Native.BN_CTX_get(ptr)), false); }
+			}
+
+			/// <summary>
+			/// Calls BN_CTX_start()
+			/// </summary>
+			public void Start()
+			{
+				Native.BN_CTX_start(ptr);
+			}
+
+			/// <summary>
+			/// Calls BN_CTX_end()
+			/// </summary>
+			public void End()
+			{
+				Native.BN_CTX_end(ptr);
+			}
+
+			/// <summary>
+			/// Calls BN_CTX_free()
+			/// </summary>
+			protected override void OnDispose()
+			{
+				Native.BN_CTX_free(ptr);
+			}
+		}
+		#endregion
+	}
+}
Index: ManagedOpenSsl/Core/Crypto.cs
===================================================================
--- ManagedOpenSsl/Core/Crypto.cs	(revision 47839)
+++ ManagedOpenSsl/Core/Crypto.cs	(revision 47851)
@@ -24,9 +24,9 @@
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 using System;
+using System.Runtime.InteropServices;
 using System.Collections.Generic;
-using System.Text;
-using System.Runtime.InteropServices;
+using System.Threading;
 
 namespace OpenSSL.Core
 {
@@ -92,7 +92,7 @@
 		/// </summary>
 		public static string MD2_Options
 		{
-			get { return Native.MD2_options(); }
+			get { return Native.StaticString(Native.MD2_options()); }
 		}
 
 		/// <summary>
@@ -100,7 +100,7 @@
 		/// </summary>
 		public static string RC4_Options
 		{
-			get { return Native.RC4_options(); }
+			get { return Native.StaticString(Native.RC4_options()); }
 		}
 
 		/// <summary>
@@ -108,7 +108,7 @@
 		/// </summary>
 		public static string DES_Options
 		{
-			get { return Native.DES_options(); }
+			get { return Native.StaticString(Native.DES_options()); }
 		}
 
 		/// <summary>
@@ -116,7 +116,7 @@
 		/// </summary>
 		public static string Idea_Options
 		{
-			get { return Native.idea_options(); }
+			get { return Native.StaticString(Native.idea_options()); }
 		}
 
 		/// <summary>
@@ -124,36 +124,10 @@
 		/// </summary>
 		public static string Blowfish_Options
 		{
-			get { return Native.BF_options(); }
+			get { return Native.StaticString(Native.BF_options()); }
 		}
 
 		/// <summary>
-		/// Calls CRYPTO_malloc_debug_init()
-		/// </summary>
-		public static void MallocDebugInit()
-		{
-			Native.CRYPTO_malloc_debug_init();
-		}
-
-		/// <summary>
-		/// Calls CRYPTO_dbg_set_options()
-		/// </summary>
-		/// <param name="options"></param>
-		public static void SetDebugOptions(DebugOptions options)
-		{
-			Native.CRYPTO_dbg_set_options((int)options);
-		}
-
-		/// <summary>
-		/// Calls CRYPTO_mem_ctrl()
-		/// </summary>
-		/// <param name="options"></param>
-		public static void SetMemoryCheck(MemoryCheck options)
-		{
-			Native.CRYPTO_mem_ctrl((int)options);
-		}
-
-		/// <summary>
 		/// Calls CRYPTO_cleanup_all_ex_data()
 		/// </summary>
 		public static void Cleanup()
@@ -162,32 +136,26 @@
 		}
 
 		/// <summary>
-		/// Calls ERR_remove_state()
+		/// Calls ERR_clear_error()
 		/// </summary>
-		/// <param name="value"></param>
-		public static void RemoveState(uint value)
+		public static void ClearErrors()
 		{
-			Native.ERR_remove_state(value);
+			Native.ERR_clear_error();
 		}
 
 		/// <summary>
-		/// CRYPTO_MEM_LEAK_CB
+		/// Calls ERR_print_errors_cb()
 		/// </summary>
-		/// <param name="order"></param>
-		/// <param name="file"></param>
-		/// <param name="line"></param>
-		/// <param name="num_bytes"></param>
-		/// <param name="addr"></param>
-		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
-		public delegate void MemoryLeakHandler(uint order, IntPtr file, int line, int num_bytes, IntPtr addr);
-
-		/// <summary>
-		/// Calls CRYPTO_mem_leaks_cb()
-		/// </summary>
-		/// <param name="callback"></param>
-		public static void CheckMemoryLeaks(MemoryLeakHandler callback)
+		/// <value>The errors.</value>
+		public static List<string> GetErrors()
 		{
-			Native.CRYPTO_mem_leaks_cb(callback);
+			var errors = new List<string>();
+			Native.ERR_print_errors_cb((IntPtr str, uint len, IntPtr u) =>
+			{
+				errors.Add(Native.StaticString(str));
+				return 0;
+			}, IntPtr.Zero);
+			return errors;
 		}
 	}
 }
Index: ManagedOpenSsl/Core/MemoryTracker.cs
===================================================================
--- ManagedOpenSsl/Core/MemoryTracker.cs	(revision 47839)
+++ ManagedOpenSsl/Core/MemoryTracker.cs	(revision 47851)
@@ -1,21 +1,108 @@
 ﻿using System;
 using System.Collections.Generic;
-using System.Text;
-using System.Threading;
+using System.Diagnostics;
+using System.Runtime.InteropServices;
 
 namespace OpenSSL.Core
 {
 	/// <summary>
+	/// 
+	/// </summary>
+	public enum MemoryProblemType
+	{
+		/// <summary>
+		/// 
+		/// </summary>
+		Leaked,
+		/// <summary>
+		/// 
+		/// </summary>
+		MultipleFree,
+	}
+
+	/// <summary>
+	/// 
+	/// </summary>
+	public class MemoryProblem
+	{
+		/// <summary>
+		/// 
+		/// </summary>
+		public MemoryProblemType Type { get; set; }
+		/// <summary>
+		/// 
+		/// </summary>
+		public uint Size { get; set; }
+		/// <summary>
+		/// 
+		/// </summary>
+		public int FreeCount { get; set; }
+		/// <summary>
+		/// 
+		/// </summary>
+		public StackTrace StackTrace { get; set; }
+		/// <summary>
+		/// 
+		/// </summary>
+		public string File { get; set; }
+		/// <summary>
+		/// 
+		/// </summary>
+		public int Line { get; set; }
+
+		/// <summary>
+		/// 
+		/// </summary>
+		/// <returns></returns>
+		public override string ToString()
+		{
+			return string.Format("{0}: {1} bytes, {2} count, {3}, {4}:{5}",
+				Type,
+				Size,
+				FreeCount,
+				StackTrace.GetFrame(0).GetMethod().Name,
+				File,
+				Line
+			);
+		}
+	}
+
+	/// <summary>
 	/// Useful for tracking down memory leaks
 	/// </summary>
 	public class MemoryTracker
 	{
-		private static int leaked = 0;
+		class Block
+		{
+			public string file;
+			public int line;
+			public StackTrace stack;
+			public uint bytes;
+			public IntPtr ptr;
+			public bool skip;
+			public int count;
 
+			public override string ToString()
+			{
+				return string.Format("{0}{1}: {2} bytes at {3}:{4}", skip ? "*" : " ", count, bytes, file, line);
+			}
+		}
+
+		// These are used to pin the functions down so they don't get yanked while in use
+		static Native.MallocFunctionPtr _ptrMalloc = malloc;
+		static Native.ReallocFunctionPtr _ptrRealloc = realloc;
+		static Native.FreeFunctionPtr _ptrFree = free;
+
+		static bool _tracking = false;
+		static Dictionary<IntPtr, Block> _memory = new Dictionary<IntPtr, Block>();
+
 		/// <summary>
-		/// Returns the number of bytes leaked between Start() and Finish()
+		/// Initialize memory routines
 		/// </summary>
-		public static int Leaked { get { return leaked; } }
+		public static void Init()
+		{
+			Native.CRYPTO_set_mem_ex_functions(_ptrMalloc, _ptrRealloc, _ptrFree);
+		}
 
 		/// <summary>
 		/// Begins memory tracking
@@ -22,16 +109,20 @@
 		/// </summary>
 		public static void Start()
 		{
-			leaked = 0;
-			CryptoUtil.MallocDebugInit();
-			CryptoUtil.SetDebugOptions(DebugOptions.All);
-			CryptoUtil.SetMemoryCheck(MemoryCheck.On);
+			lock (_memory)
+			{
+				_tracking = true;
+				foreach (var item in _memory)
+				{
+					item.Value.skip = true;
+				}
+			}
 		}
 
 		/// <summary>
 		/// Stops memory tracking and reports any leaks found since Start() was called.
 		/// </summary>
-		public static void Finish()
+		public static List<MemoryProblem> Finish()
 		{
 			GC.Collect();
 			GC.WaitForPendingFinalizers();
@@ -38,29 +129,120 @@
 			GC.Collect();
 
 			CryptoUtil.Cleanup();
-			CryptoUtil.RemoveState(0);
+			CryptoUtil.ClearErrors();
+			Native.ERR_remove_thread_state(IntPtr.Zero);
 
-			CryptoUtil.SetMemoryCheck(MemoryCheck.Off);
+			GC.Collect();
+			GC.WaitForPendingFinalizers();
+			GC.Collect();
 
-			CryptoUtil.CheckMemoryLeaks(OnMemoryLeak);
-			if (leaked > 0)
-				Console.WriteLine("Leaked total bytes: {0}", leaked);
+			_tracking = false;
+
+			return Flush();
 		}
 
-		private static void OnMemoryLeak(uint order, IntPtr file, int line, int num_bytes, IntPtr addr)
+		static List<MemoryProblem> Flush()
 		{
-			string filename;
-			if(file != IntPtr.Zero)
+			var problems = new List<MemoryProblem>();
+
+			lock (_memory)
 			{
-				filename = Native.PtrToStringAnsi(file, false);
+				var frees = new List<Block>();
+
+				foreach (var item in _memory)
+				{
+					var block = item.Value;
+					if (block.skip)
+						continue;
+
+					if (block.count == 0)
+						block.skip = true;
+
+					if (block.count > 0)
+						frees.Add(block);
+
+					if (block.count == 0 || block.count > 1)
+					{
+						var problem = new MemoryProblem
+						{
+							Type = block.count == 0 ? MemoryProblemType.Leaked : MemoryProblemType.MultipleFree,
+							Size = block.bytes,
+							FreeCount = block.count,
+							StackTrace = block.stack,
+							File = block.file,
+							Line = block.line,
+						};
+						Console.WriteLine(problem);
+						problems.Add(problem);
+					}
+				}
+
+				foreach (var block in frees)
+				{
+					Marshal.FreeHGlobal(block.ptr);
+					_memory.Remove(block.ptr);
+				}
 			}
-			else
+
+			return problems;
+		}
+
+		static IntPtr malloc(uint num, IntPtr file, int line)
+		{
+			lock (_memory)
 			{
-				filename = "<null>";
+				var block = new Block
+				{
+					file = Native.StaticString(file),
+					line = line,
+					stack = new StackTrace(1, true),
+					bytes = num,
+					ptr = Marshal.AllocHGlobal((int)num),
+				};
+				_memory.Add(block.ptr, block);
+				return block.ptr;
 			}
+		}
 
-			Console.WriteLine("[{0}] file: {1} line: {2} bytes: {3}", order, filename, line, num_bytes);
-			leaked += num_bytes;
+		static void free(IntPtr addr)
+		{
+			lock (_memory)
+			{
+				Block block;
+				if (!_memory.TryGetValue(addr, out block))
+					return;
+
+				if (_tracking)
+				{
+					block.count++;
+				}
+				else
+				{
+					Marshal.FreeHGlobal(addr);
+					_memory.Remove(addr);
+				}
+			}
 		}
+
+		static IntPtr realloc(IntPtr addr, uint num, IntPtr file, int line)
+		{
+			lock (_memory)
+			{
+				if (!_memory.Remove(addr))
+					return malloc(num, file, line);
+
+				var block = new Block
+				{
+					stack = new StackTrace(1, true),
+					file = Native.StaticString(file),
+					line = line,
+					bytes = num,
+					ptr = Marshal.ReAllocHGlobal(addr, (IntPtr)num),
+				};
+
+				_memory.Add(block.ptr, block);
+				return block.ptr;
+			}
+		}
 	}
 }
Index: ManagedOpenSsl/Core/Native.cs
===================================================================
--- ManagedOpenSsl/Core/Native.cs	(revision 47839)
+++ ManagedOpenSsl/Core/Native.cs	(revision 47851)
@@ -1,2657 +1,3033 @@
-// Copyright (c) 2006-2012 Frank Laub
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-using System.Text;
-using System;
-using System.Security.Cryptography;
-using System.Runtime.InteropServices;
-using System.Globalization;
-using System.Reflection;
-using System.Collections.Generic;
-using System.Threading;
-
-namespace OpenSSL.Core
-{
-	/// <summary>
-	/// 
-	/// </summary>
-	public static class FIPS
-	{
-		/// <summary>
-		/// 
-		/// </summary>
-		public static bool Enabled { get; set; }
-	}
-
-	internal enum CryptoLockTypes
-	{
-		CRYPTO_LOCK_ERR = 1,
-		CRYPTO_LOCK_EX_DATA = 2,
-		CRYPTO_LOCK_X509 = 3,
-		CRYPTO_LOCK_X509_INFO = 4,
-		CRYPTO_LOCK_X509_PKEY = 5,
-		CRYPTO_LOCK_X509_CRL = 6,
-		CRYPTO_LOCK_X509_REQ = 7,
-		CRYPTO_LOCK_DSA = 8,
-		CRYPTO_LOCK_RSA = 9,
-		CRYPTO_LOCK_EVP_PKEY = 10,
-		CRYPTO_LOCK_X509_STORE = 11,
-		CRYPTO_LOCK_SSL_CTX = 12,
-		CRYPTO_LOCK_SSL_CERT = 13,
-		CRYPTO_LOCK_SSL_SESSION = 14,
-		CRYPTO_LOCK_SSL_SESS_CERT = 15,
-		CRYPTO_LOCK_SSL = 16,
-		CRYPTO_LOCK_SSL_METHOD = 17,
-		CRYPTO_LOCK_RAND = 18,
-		CRYPTO_LOCK_RAND2 = 19,
-		CRYPTO_LOCK_MALLOC = 20,
-		CRYPTO_LOCK_BIO = 21,
-		CRYPTO_LOCK_GETHOSTBYNAME = 22,
-		CRYPTO_LOCK_GETSERVBYNAME = 23,
-		CRYPTO_LOCK_READDIR = 24,
-		CRYPTO_LOCK_RSA_BLINDING = 25,
-		CRYPTO_LOCK_DH = 26,
-		CRYPTO_LOCK_MALLOC2 = 27,
-		CRYPTO_LOCK_DSO = 28,
-		CRYPTO_LOCK_DYNLOCK = 29,
-		CRYPTO_LOCK_ENGINE = 30,
-		CRYPTO_LOCK_UI = 31,
-		CRYPTO_LOCK_ECDSA = 32,
-		CRYPTO_LOCK_EC = 33,
-		CRYPTO_LOCK_ECDH = 34,
-		CRYPTO_LOCK_BN = 35,
-		CRYPTO_LOCK_EC_PRE_COMP = 36,
-		CRYPTO_LOCK_STORE = 37,
-		CRYPTO_LOCK_COMP = 38,
-		CRYPTO_LOCK_FIPS = 39,
-		CRYPTO_LOCK_FIPS2 = 40,
-		CRYPTO_NUM_LOCKS = 41,
-	}
-
-	/// <summary>
-	/// static class for initialize OpenSSL/Crypto libraries for threading
-	/// </summary>
-	public class ThreadInitialization
-	{
-		/// <summary>
-		/// Calls Native.InitializeThreads()
-		/// </summary>
-		public static void InitializeThreads()
-		{
-			Native.InitializeThreads();
-		}
-
-		/// <summary>
-		/// Calls Native.UninitializeThreads()
-		/// </summary>
-		public static void UninitializeThreads()
-		{
-			Native.UninitializeThreads();
-		}
-	}
-
-	/// <summary>
-	/// This is the low-level C-style interface to the crypto API.
-	/// Use this interface with caution.
-	/// </summary>
-	internal class Native
-	{
-		/// <summary>
-		/// This is the name of the DLL that P/Invoke loads and tries to bind all of
-		/// these native functions to.
-		/// </summary>
-		const string DLLNAME = "libeay32";
-		const string SSLDLLNAME = "ssleay32";
-
-		#region Delegates
-		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
-		public delegate int pem_password_cb(IntPtr buf, int size, int rwflag, IntPtr userdata);
-
-		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
-		public delegate int GeneratorHandler(int p, int n, IntPtr arg);
-
-		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
-		public delegate void ObjectNameHandler(IntPtr name, IntPtr arg);
-
-		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
-		public delegate void CRYPTO_locking_callback(int mode, int type, string file, int line);
-
-		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
-		public delegate uint CRYPTO_id_callback();
-
-		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
-		public delegate int VerifyCertCallback(int ok, IntPtr x509_store_ctx);
-
-		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
-		public delegate int client_cert_cb(IntPtr ssl, out IntPtr x509, out IntPtr pkey);
-
-		#endregion
-
-		#region Initialization
-		static Native()
-		{
-			Version lib = Version.Library;
-			Version wrapper = Version.Wrapper;
-			uint mmf = lib.Raw & 0xfffff000;
-			if (mmf != wrapper.Raw)
-				throw new Exception(string.Format("Invalid version of {0}, expecting {1}, got: {2}",
-					DLLNAME, wrapper, lib));
-
-			// Enable FIPS mode
-			if (FIPS.Enabled)
-			{
-				if (FIPS_mode_set(1) == 0)
-				{
-					throw new Exception("Failed to initialize FIPS mode");
-				}
-			}
-
-			ERR_load_crypto_strings();
-			SSL_load_error_strings();
-
-			OPENSSL_add_all_algorithms_noconf();
-
-			// Initialize SSL library
-			Native.ExpectSuccess(SSL_library_init());
-
-			byte[] seed = new byte[128];
-			RandomNumberGenerator rng = RandomNumberGenerator.Create();
-			rng.GetBytes(seed);
-			RAND_seed(seed, seed.Length);
-		}
-
-		public static void InitializeThreads()
-		{
-			// Initialize the threading locks
-			int nLocks = CRYPTO_num_locks();
-			lock_objects = new List<object>(nLocks);
-			for (int i = 0; i < nLocks; i++)
-			{
-				object obj = new object();
-				lock_objects.Add(obj);
-			}
-			// Initialize the internal thread id stack
-			threadIDs = new System.Collections.Generic.Stack<uint>();
-			// Initialize the delegate for the locking callback
-			CRYPTO_locking_callback_delegate = new CRYPTO_locking_callback(LockingCallback);
-			CRYPTO_set_locking_callback(CRYPTO_locking_callback_delegate);
-			// Initialze the thread id callback
-			CRYPTO_id_callback_delegate = new CRYPTO_id_callback(ThreadIDCallback);
-			CRYPTO_set_id_callback(CRYPTO_id_callback_delegate);
-		}
-
-		public static void UninitializeThreads()
-		{
-			// Cleanup the thread lock objects
-			CRYPTO_set_locking_callback(null);
-			lock_objects.Clear();
-			CRYPTO_set_id_callback(null);
-			// Clean up error state for each thread that was used by OpenSSL
-			if (threadIDs != null)
-			{
-				foreach (uint id in threadIDs)
-				{
-					Native.ERR_remove_state(id);
-				}
-			}
-		}
-
-		#endregion
-
-		#region Version
-		public const uint Wrapper = 0x10000000;
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static string SSLeay_version(int type);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static uint SSLeay();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static string BN_options();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static string MD2_options();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static string RC4_options();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static string DES_options();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static string idea_options();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static string BF_options();
-
-		#endregion
-
-		#region Threading
-		private static List<object> lock_objects;
-		private static CRYPTO_locking_callback CRYPTO_locking_callback_delegate;
-		private static CRYPTO_id_callback CRYPTO_id_callback_delegate;
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void CRYPTO_set_id_callback(CRYPTO_id_callback cb);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void CRYPTO_set_locking_callback(CRYPTO_locking_callback cb);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int CRYPTO_num_locks();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int CRYPTO_add_lock(IntPtr ptr, int amount, CryptoLockTypes type, string file, int line);
-
-		public const int CRYPTO_LOCK = 1;
-
-		public static void LockingCallback(int mode, int type, string file, int line)
-		{
-			if ((mode & CRYPTO_LOCK) == CRYPTO_LOCK)
-			{
-				Monitor.Enter(lock_objects[type]);
-			}
-			else
-			{
-				Monitor.Exit(lock_objects[type]);
-			}
-		}
-
-		private static System.Collections.Generic.Stack<uint> threadIDs;
-
-		public static uint ThreadIDCallback()
-		{
-			uint threadID = (uint)Thread.CurrentThread.ManagedThreadId;
-			if (!threadIDs.Contains(threadID))
-			{
-				threadIDs.Push(threadID);
-			}
-			return threadID;
-		}
-
-		#endregion
-
-		#region CRYPTO
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void OPENSSL_add_all_algorithms_noconf();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void OPENSSL_add_all_algorithms_conf();
-
-		/// <summary>
-		/// #define OPENSSL_free(addr) CRYPTO_free(addr)
-		/// </summary>
-		/// <param name="p"></param>
-		public static void OPENSSL_free(IntPtr p)
-		{
-			CRYPTO_free(p);
-		}
-
-		/// <summary>
-		/// #define OPENSSL_malloc(num)	CRYPTO_malloc((int)num,__FILE__,__LINE__)
-		/// </summary>
-		/// <param name="cbSize"></param>
-		/// <returns></returns>
-		public static IntPtr OPENSSL_malloc(int cbSize)
-		{
-			return CRYPTO_malloc(cbSize, Assembly.GetExecutingAssembly().FullName, 0);
-		}
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void CRYPTO_free(IntPtr p);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr CRYPTO_malloc(int num, string file, int line);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr CRYPTO_realloc(IntPtr ptr, int num, string file, int line);
-
-		private static MallocFunctionPtr ptr_CRYPTO_dbg_malloc = CRYPTO_dbg_malloc;
-		private static ReallocFunctionPtr ptr_CRYPTO_dbg_realloc = CRYPTO_dbg_realloc;
-		private static FreeFunctionPtr ptr_CRYPTO_dbg_free = CRYPTO_dbg_free;
-		private static SetOptionsFunctionPtr ptr_CRYPTO_dbg_set_options = CRYPTO_dbg_set_options;
-		private static GetOptionsFunctionPtr ptr_CRYPTO_dbg_get_options = CRYPTO_dbg_get_options;
-
-		//!! - Expose the default CRYPTO_malloc_debug_init() - this method hooks up the default 
-		//!! - debug functions in the crypto library, this allows us to utilize the MemoryTracker
-		//!! - on non-Windows systems as well.
-		public static void CRYPTO_malloc_debug_init() {
-			CRYPTO_set_mem_debug_functions(
-				ptr_CRYPTO_dbg_malloc,
-				ptr_CRYPTO_dbg_realloc,
-				ptr_CRYPTO_dbg_free,
-				ptr_CRYPTO_dbg_set_options,
-				ptr_CRYPTO_dbg_get_options);
-		}
-
-
-		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
-		public delegate void MallocFunctionPtr(IntPtr addr, int num, IntPtr file, int line, int before_p);
-
-		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
-		public delegate void ReallocFunctionPtr(IntPtr addr1, IntPtr addr2, int num, IntPtr file, int line, int before_p);
-
-		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
-		public delegate void FreeFunctionPtr(IntPtr addr, int before_p);
-
-		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
-		public delegate void SetOptionsFunctionPtr(int bits);
-
-		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
-		public delegate int GetOptionsFunctionPtr();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void CRYPTO_dbg_malloc(IntPtr addr, int num, IntPtr file, int line, int before_p);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void CRYPTO_dbg_realloc(IntPtr addr1, IntPtr addr2, int num, IntPtr file, int line, int before_p);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void CRYPTO_dbg_free(IntPtr addr, int before_p);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void CRYPTO_dbg_set_options(int bits);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int CRYPTO_dbg_get_options();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int CRYPTO_set_mem_debug_functions(
-			MallocFunctionPtr m, 
-			ReallocFunctionPtr r, 
-			FreeFunctionPtr f, 
-			SetOptionsFunctionPtr so, 
-			GetOptionsFunctionPtr go);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int CRYPTO_mem_ctrl(int mode);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void CRYPTO_cleanup_all_ex_data();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void CRYPTO_mem_leaks(IntPtr bio);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void CRYPTO_mem_leaks_cb(CryptoUtil.MemoryLeakHandler cb);
-
-		#endregion
-
-		#region OBJ
-		public const int NID_undef = 0;
-
-		public const int OBJ_undef = 0;
-
-		public const int OBJ_NAME_TYPE_UNDEF = 0x00;
-		public const int OBJ_NAME_TYPE_MD_METH = 0x01;
-		public const int OBJ_NAME_TYPE_CIPHER_METH = 0x02;
-		public const int OBJ_NAME_TYPE_PKEY_METH = 0x03;
-		public const int OBJ_NAME_TYPE_COMP_METH = 0x04;
-		public const int OBJ_NAME_TYPE_NUM = 0x05;
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void OBJ_NAME_do_all(int type, ObjectNameHandler fn, IntPtr arg);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void OBJ_NAME_do_all_sorted(int type, ObjectNameHandler fn, IntPtr arg);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int OBJ_txt2nid(string s);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr OBJ_nid2obj(int n);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static string OBJ_nid2ln(int n);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static string OBJ_nid2sn(int n);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int OBJ_obj2nid(IntPtr o);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr OBJ_txt2obj(string s, int no_name);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int OBJ_ln2nid(string s);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int OBJ_sn2nid(string s);
-		#endregion
-
-		#region stack
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr sk_new_null();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int sk_num(IntPtr stack);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int sk_find(IntPtr stack, IntPtr data);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int sk_insert(IntPtr stack, IntPtr data, int where);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr sk_shift(IntPtr stack);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int sk_unshift(IntPtr stack, IntPtr data);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int sk_push(IntPtr stack, IntPtr data);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr sk_pop(IntPtr stack);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr sk_delete(IntPtr stack, int loc);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr sk_delete_ptr(IntPtr stack, IntPtr p);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr sk_value(IntPtr stack, int index);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr sk_set(IntPtr stack, int index, IntPtr data);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr sk_dup(IntPtr stack);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void sk_zero(IntPtr stack);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void sk_free(IntPtr stack);
-
-		#endregion
-
-		#region SHA
-		public const int SHA_DIGEST_LENGTH = 20;
-		#endregion
-
-		#region ASN1
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr ASN1_INTEGER_new();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void ASN1_INTEGER_free(IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int ASN1_INTEGER_set(IntPtr a, int v);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int ASN1_INTEGER_get(IntPtr a);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr ASN1_TIME_set(IntPtr s, long t);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int ASN1_UTCTIME_print(IntPtr bp, IntPtr a);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr ASN1_TIME_new();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void ASN1_TIME_free(IntPtr x);
-
-		public const int V_ASN1_OCTET_STRING = 4;
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr ASN1_STRING_type_new(int type);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr ASN1_STRING_dup(IntPtr a);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void ASN1_STRING_free(IntPtr a);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int ASN1_STRING_cmp(IntPtr a, IntPtr b);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int ASN1_STRING_set(IntPtr str, byte[] data, int len);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr ASN1_STRING_data(IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int ASN1_STRING_length(IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void ASN1_OBJECT_free(IntPtr obj);
-
-		#endregion
-
-		#region X509_REQ
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_REQ_new();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_REQ_set_version(IntPtr x, int version);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_REQ_set_pubkey(IntPtr x, IntPtr pkey);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_REQ_get_pubkey(IntPtr req);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_REQ_set_subject_name(IntPtr x, IntPtr name);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_REQ_sign(IntPtr x, IntPtr pkey, IntPtr md);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_REQ_verify(IntPtr x, IntPtr pkey);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_REQ_digest(IntPtr data, IntPtr type, byte[] md, ref uint len);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void X509_REQ_free(IntPtr a);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_REQ_to_X509(IntPtr r, int days, IntPtr pkey);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_REQ_print_ex(IntPtr bp, IntPtr x, uint nmflag, uint cflag);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_REQ_print(IntPtr bp, IntPtr x);
-		#endregion
-
-		#region X509
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_new();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_dup(IntPtr x509);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_cmp(IntPtr a, IntPtr b);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_sign(IntPtr x, IntPtr pkey, IntPtr md);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_check_private_key(IntPtr x509, IntPtr pkey);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_verify(IntPtr x, IntPtr pkey);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_pubkey_digest(IntPtr data, IntPtr type, byte[] md, ref uint len);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_digest(IntPtr data, IntPtr type, byte[] md, ref uint len);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_set_version(IntPtr x, int version);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_set_serialNumber(IntPtr x, IntPtr serial);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_get_serialNumber(IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_set_issuer_name(IntPtr x, IntPtr name);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_get_issuer_name(IntPtr a);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_set_subject_name(IntPtr x, IntPtr name);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_get_subject_name(IntPtr a);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_set_notBefore(IntPtr x, IntPtr tm);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_set_notAfter(IntPtr x, IntPtr tm);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_set_pubkey(IntPtr x, IntPtr pkey);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_get_pubkey(IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void X509_free(IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_verify_cert(IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_verify_cert_error_string(int n);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_to_X509_REQ(IntPtr x, IntPtr pkey, IntPtr md);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_print_ex(IntPtr bp, IntPtr x, uint nmflag, uint cflag);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_print(IntPtr bp, IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_find_by_issuer_and_serial(IntPtr sk, IntPtr name, IntPtr serial);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_find_by_subject(IntPtr sk, IntPtr name);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_check_trust(IntPtr x, int id, int flags);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_time_adj(IntPtr s, int adj, ref long t);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_gmtime_adj(IntPtr s, int adj);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr d2i_X509_bio(IntPtr bp, ref IntPtr x509);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int i2d_X509_bio(IntPtr bp, IntPtr x509);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void X509_PUBKEY_free(IntPtr pkey);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void X509_OBJECT_up_ref_count(IntPtr a);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void X509_OBJECT_free_contents(IntPtr a);
-
-		#endregion
-
-		#region X509_EXTENSION
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_EXTENSION_new();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void X509_EXTENSION_free(IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_EXTENSION_dup(IntPtr ex);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509V3_EXT_print(IntPtr bio, IntPtr ext, uint flag, int indent);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509V3_EXT_get_nid(int nid);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_add_ext(IntPtr x, IntPtr ex, int loc);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_add1_ext_i2d(IntPtr x, int nid, byte[] value, int crit, uint flags);
-
-		//X509_EXTENSION* X509V3_EXT_conf_nid(LHASH* conf, X509V3_CTX* ctx, int ext_nid, char* value);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509V3_EXT_conf_nid(IntPtr conf, IntPtr ctx, int ext_nid, string value);
-
-		//X509_EXTENSION* X509_EXTENSION_create_by_NID(X509_EXTENSION** ex, int nid, int crit, ASN1_OCTET_STRING* data);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_EXTENSION_create_by_NID(IntPtr ex, int nid, int crit, IntPtr data);
-
-		//X509_EXTENSION* X509_EXTENSION_create_by_OBJ(X509_EXTENSION** ex, ASN1_OBJECT* obj, int crit, ASN1_OCTET_STRING* data);
-		//int X509_EXTENSION_set_object(X509_EXTENSION* ex, ASN1_OBJECT* obj);
-		//int X509_EXTENSION_set_critical(X509_EXTENSION* ex, int crit);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_EXTENSION_set_critical(IntPtr ex, int crit);
-
-		//int X509_EXTENSION_set_data(X509_EXTENSION* ex, ASN1_OCTET_STRING* data);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_EXTENSION_set_data(IntPtr ex, IntPtr data);
-
-		//ASN1_OBJECT* X509_EXTENSION_get_object(X509_EXTENSION* ex);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_EXTENSION_get_object(IntPtr ex);
-
-		//ASN1_OCTET_STRING* X509_EXTENSION_get_data(X509_EXTENSION* ne);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_EXTENSION_get_data(IntPtr ne);
-
-		//int X509_EXTENSION_get_critical(X509_EXTENSION* ex);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_EXTENSION_get_critical(IntPtr ex);
-
-		#endregion
-
-		#region X509_STORE
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_STORE_new();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_STORE_add_cert(IntPtr ctx, IntPtr x);
-
-		//[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		//void X509_STORE_set_flags();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void X509_STORE_free(IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_STORE_CTX_new();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_STORE_CTX_init(IntPtr ctx, IntPtr store, IntPtr x509, IntPtr chain);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void X509_STORE_CTX_free(IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_STORE_CTX_get_current_cert(IntPtr x509_store_ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_STORE_CTX_get_error_depth(IntPtr x509_store_ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_STORE_CTX_get_error(IntPtr x509_store_ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void X509_STORE_CTX_set_error(IntPtr x509_store_ctx, int error);
-
-		#endregion
-
-		#region X509_INFO
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void X509_INFO_free(IntPtr a);
-		#endregion
-
-		#region X509_NAME
-		public const int MBSTRING_FLAG = 0x1000;
-
-		public const int MBSTRING_ASC = MBSTRING_FLAG | 1;
-
-		public const int ASN1_STRFLGS_RFC2253 =
-			ASN1_STRFLGS_ESC_2253 |
-			ASN1_STRFLGS_ESC_CTRL |
-			ASN1_STRFLGS_ESC_MSB |
-			ASN1_STRFLGS_UTF8_CONVERT |
-			ASN1_STRFLGS_DUMP_UNKNOWN |
-			ASN1_STRFLGS_DUMP_DER;
-
-		public const int ASN1_STRFLGS_ESC_2253 = 1;
-		public const int ASN1_STRFLGS_ESC_CTRL = 2;
-		public const int ASN1_STRFLGS_ESC_MSB = 4;
-		public const int ASN1_STRFLGS_ESC_QUOTE = 8;
-		public const int ASN1_STRFLGS_UTF8_CONVERT = 0x10;
-		public const int ASN1_STRFLGS_DUMP_UNKNOWN = 0x100;
-		public const int ASN1_STRFLGS_DUMP_DER = 0x200;
-		public const int XN_FLAG_SEP_COMMA_PLUS = (1 << 16);
-		public const int XN_FLAG_FN_SN = 0;
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_NAME_new();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void X509_NAME_free(IntPtr a);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_NAME_dup(IntPtr xn);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_NAME_cmp(IntPtr a, IntPtr b);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_NAME_entry_count(IntPtr name);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_NAME_add_entry_by_NID(IntPtr name, int nid, int type, byte[] bytes, int len, int loc, int set);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_NAME_add_entry_by_txt(IntPtr name, byte[] field, int type, byte[] bytes, int len, int loc, int set);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_NAME_get_text_by_NID(IntPtr name, int nid, byte[] buf, int len);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_NAME_get_entry(IntPtr name, int loc);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_NAME_delete_entry(IntPtr name, int loc);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_NAME_get_index_by_NID(IntPtr name, int nid, int lastpos);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_NAME_digest(IntPtr data, IntPtr type, byte[] md, ref uint len);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr X509_NAME_oneline(IntPtr a, byte[] buf, int size);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_NAME_print(IntPtr bp, IntPtr name, int obase);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509_NAME_print_ex(IntPtr bp, IntPtr nm, int indent, uint flags);
-		#endregion
-
-		#region RAND
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int RAND_set_rand_method(IntPtr meth);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr RAND_get_rand_method();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void RAND_cleanup();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void RAND_seed(byte[] buf, int len);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int RAND_pseudo_bytes(byte[] buf, int len);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int RAND_bytes(byte[] buf, int num);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void RAND_add(byte[] buf, int num, double entropy);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int RAND_load_file(string file, int max_bytes);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int RAND_write_file(string file);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static string RAND_file_name(byte[] buf, uint num);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int RAND_status();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int RAND_query_egd_bytes(string path, byte[] buf, int bytes);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int RAND_egd(string path);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int RAND_egd_bytes(string path, int bytes);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int RAND_poll();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BN_rand(IntPtr rnd, int bits, int top, int bottom);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BN_pseudo_rand(IntPtr rnd, int bits, int top, int bottom);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BN_rand_range(IntPtr rnd, IntPtr range);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BN_pseudo_rand_range(IntPtr rnd, IntPtr range);
-		#endregion
-
-		#region DSA
-		//[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		//public extern static IntPtr DSA_generate_parameters(int bits, byte[] seed, int seed_len, IntPtr counter_ret, IntPtr h_ret, IntPtr callback, IntPtr cb_arg);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static
-		int DSA_generate_parameters_ex(IntPtr dsa,
-		                               int bits,
-		                               byte[] seed,
-		                               int seed_len,
-		                               out int counter_ret,
-		                               out IntPtr h_ret,
-		                               bn_gencb_st callback);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int DSA_generate_key(IntPtr dsa);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr DSA_new();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void DSA_free(IntPtr dsa);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int DSA_size(IntPtr dsa);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int DSAparams_print(IntPtr bp, IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int DSA_print(IntPtr bp, IntPtr x, int off);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int DSA_sign(int type, byte[] dgst, int dlen, byte[] sig, out uint siglen, IntPtr dsa);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int DSA_verify(int type, byte[] dgst, int dgst_len, byte[] sigbuf, int siglen, IntPtr dsa);
-		#endregion
-
-		#region RSA
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr RSA_new();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void RSA_free(IntPtr rsa);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int RSA_size(IntPtr rsa);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int RSA_generate_key_ex(IntPtr rsa, int bits, IntPtr e, bn_gencb_st cb);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int RSA_check_key(IntPtr rsa);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int RSA_public_encrypt(int flen, byte[] from, byte[] to, IntPtr rsa, int padding);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int RSA_private_encrypt(int flen, byte[] from, byte[] to, IntPtr rsa, int padding);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int RSA_public_decrypt(int flen, byte[] from, byte[] to, IntPtr rsa, int padding);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int RSA_private_decrypt(int flen, byte[] from, byte[] to, IntPtr rsa, int padding);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int RSA_sign(int type, byte[] m, uint m_length, byte[] sigret, out uint siglen, IntPtr rsa);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int RSA_verify(int type, byte[] m, uint m_length, byte[] sigbuf, uint siglen, IntPtr rsa);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int RSA_print(IntPtr bp, IntPtr r, int offset);
-		#endregion
-
-		#region DH
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr DH_generate_parameters(int prime_len, int generator, IntPtr callback, IntPtr cb_arg);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int DH_generate_parameters_ex(IntPtr dh, int prime_len, int generator, bn_gencb_st cb);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int DH_generate_key(IntPtr dh);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int DH_compute_key(byte[] key, IntPtr pub_key, IntPtr dh);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr DH_new();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void DH_free(IntPtr dh);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int DH_check(IntPtr dh, out int codes);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int DHparams_print(IntPtr bp, IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int DH_size(IntPtr dh);
-
-		#endregion
-
-		#region BIGNUM
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr BN_value_one();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr BN_CTX_new();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void BN_CTX_init(IntPtr c);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void BN_CTX_free(IntPtr c);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void BN_CTX_start(IntPtr ctx);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr BN_CTX_get(IntPtr ctx);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void BN_CTX_end(IntPtr ctx);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr BN_new();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void BN_free(IntPtr a);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void BN_init(IntPtr a);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr BN_bin2bn(byte[] s, int len, IntPtr ret);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BN_bn2bin(IntPtr a, byte[] to);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void BN_clear_free(IntPtr a);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void BN_clear(IntPtr a);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr BN_dup(IntPtr a);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr BN_copy(IntPtr a, IntPtr b);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void BN_swap(IntPtr a, IntPtr b);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BN_cmp(IntPtr a, IntPtr b);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BN_sub(IntPtr r, IntPtr a, IntPtr b);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BN_add(IntPtr r, IntPtr a, IntPtr b);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BN_mul(IntPtr r, IntPtr a, IntPtr b, IntPtr ctx);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BN_num_bits(IntPtr a);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BN_sqr(IntPtr r, IntPtr a, IntPtr ctx);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BN_div(IntPtr dv, IntPtr rem, IntPtr m, IntPtr d, IntPtr ctx);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BN_print(IntPtr fp, IntPtr a);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr BN_bn2hex(IntPtr a);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr BN_bn2dec(IntPtr a);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BN_hex2bn(out IntPtr a, byte[] str);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BN_dec2bn(out IntPtr a, byte[] str);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static uint BN_mod_word(IntPtr a, uint w);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static uint BN_div_word(IntPtr a, uint w);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BN_mul_word(IntPtr a, uint w);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BN_add_word(IntPtr a, uint w);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BN_sub_word(IntPtr a, uint w);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BN_set_word(IntPtr a, uint w);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static uint BN_get_word(IntPtr a);
-		//#define BN_GENCB_set(gencb, callback, cb_arg) { \
-		//        BN_GENCB *tmp_gencb = (gencb); \
-		//        tmp_gencb->ver = 2; \
-		//        tmp_gencb->arg = (cb_arg); \
-		//        tmp_gencb->cb.cb_2 = (callback); }
-
-		[StructLayout(LayoutKind.Sequential)]
-		public class bn_gencb_st
-		{
-			public uint ver; /// To handle binary (in)compatibility 
-			public IntPtr arg; /// callback-specific data 
-			public GeneratorHandler cb;
-		}
-		#endregion
-
-		#region DER
-		//#define d2i_DHparams_bio(bp,x) ASN1_d2i_bio_of(DH,DH_new,d2i_DHparams,bp,x)
-		//#define i2d_DHparams_bio(bp,x) ASN1_i2d_bio_of_const(DH,i2d_DHparams,bp,x)
-		//
-		//#define ASN1_d2i_bio_of(type,xnew,d2i,in,x) \
-		//    ((type*)ASN1_d2i_bio( CHECKED_NEW_OF(type, xnew), \
-		//              CHECKED_D2I_OF(type, d2i), \
-		//              in, \
-		//              CHECKED_PPTR_OF(type, x)))
-		//
-		//#define ASN1_i2d_bio_of_const(type,i2d,out,x) \
-		//    (ASN1_i2d_bio(CHECKED_I2D_OF(const type, i2d), \
-		//          out, \
-		//          CHECKED_PTR_OF(const type, x)))
-		//
-		//#define CHECKED_I2D_OF(type, i2d) \
-		//    ((i2d_of_void*) (1 ? i2d : ((I2D_OF(type))0)))
-		//
-		//#define I2D_OF(type) int (*)(type *,byte[] *)
-		//
-		//#define CHECKED_PTR_OF(type, p) \
-		//    ((void*) (1 ? p : (type*)0))
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public static extern IntPtr d2i_DHparams(out IntPtr a, IntPtr pp, int length);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int i2d_DHparams(IntPtr a, IntPtr pp);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr ASN1_d2i_bio(IntPtr xnew, IntPtr d2i, IntPtr bp, IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int ASN1_i2d_bio(IntPtr i2d, IntPtr bp, IntPtr x);
-		#endregion
-
-		#region PEM
-
-		#region X509
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int PEM_write_bio_X509(IntPtr bp, IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr PEM_read_bio_X509(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr PEM_read_bio_PKCS7(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr d2i_PKCS7_bio(IntPtr bp, IntPtr p7);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void PKCS7_free(IntPtr p7);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr d2i_PKCS12_bio(IntPtr bp, IntPtr p12);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int i2d_PKCS12_bio(IntPtr bp, IntPtr p12);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		//PKCS12 *PKCS12_create(char *pass, char *name, EVP_PKEY *pkey, X509 *cert, STACK_OF(X509) *ca, int nid_key, int nid_cert, int iter, int mac_iter, int keytype);
-		public extern static IntPtr PKCS12_create(string pass, string name, IntPtr pkey, IntPtr cert, IntPtr ca, int nid_key, int nid_cert, int iter, int mac_iter, int keytype);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		//int PKCS12_parse(PKCS12 *p12, const char *pass, EVP_PKEY **pkey, X509 **cert, STACK_OF(X509) **ca);
-		public extern static int PKCS12_parse(IntPtr p12, string pass, out IntPtr pkey, out IntPtr cert, out IntPtr ca);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void PKCS12_free(IntPtr p12);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		//!!int PEM_write_bio_PKCS8PrivateKey(BIO *bp, EVP_PKEY *x, const EVP_CIPHER *enc, char *kstr, int klen, pem_password_cb *cb, void *u);
-		public extern static int PEM_write_bio_PKCS8PrivateKey(IntPtr bp, IntPtr evp_pkey, IntPtr evp_cipher, IntPtr kstr, int klen, pem_password_cb cb, IntPtr user_data);
-
-		#endregion
-
-		#region X509_INFO
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int PEM_write_bio_X509_INFO(IntPtr bp, IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr PEM_read_bio_X509_INFO(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
-		#endregion
-
-		#region X509_AUX
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int PEM_write_bio_X509_AUX(IntPtr bp, IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr PEM_read_bio_X509_AUX(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
-		#endregion
-
-		#region X509_REQ
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int PEM_write_bio_X509_REQ(IntPtr bp, IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr PEM_read_bio_X509_REQ(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
-		#endregion
-
-		#region X509_REQ_NEW
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int PEM_write_bio_X509_REQ_NEW(IntPtr bp, IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr PEM_read_bio_X509_REQ_NEW(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
-		#endregion
-
-		#region X509_CRL
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int PEM_write_bio_X509_CRL(IntPtr bp, IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr PEM_read_bio_X509_CRL(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
-		#endregion
-
-		#region X509Chain
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr PEM_X509_INFO_read_bio(IntPtr bp, IntPtr sk, pem_password_cb cb, IntPtr u);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int PEM_X509_INFO_write_bio(IntPtr bp, IntPtr xi, IntPtr enc, byte[] kstr, int klen, IntPtr cd, IntPtr u);
-		#endregion
-
-		#region DSA
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int PEM_write_bio_DSAPrivateKey(IntPtr bp, IntPtr x, IntPtr enc, byte[] kstr, int klen, pem_password_cb cb, IntPtr u);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr PEM_read_bio_DSAPrivateKey(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int PEM_write_bio_DSA_PUBKEY(IntPtr bp, IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr PEM_read_bio_DSA_PUBKEY(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
-		#endregion
-
-		#region DSAparams
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int PEM_write_bio_DSAparams(IntPtr bp, IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr PEM_read_bio_DSAparams(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
-		#endregion
-
-		#region RSA
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int PEM_write_bio_RSA_PUBKEY(IntPtr bp, IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr PEM_read_bio_RSA_PUBKEY(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int PEM_write_bio_RSAPrivateKey(IntPtr bp, IntPtr x, IntPtr enc, byte[] kstr, int klen, pem_password_cb cb, IntPtr u);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr PEM_read_bio_RSAPrivateKey(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
-		#endregion
-
-		#region DHparams
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int PEM_write_bio_DHparams(IntPtr bp, IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr PEM_read_bio_DHparams(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
-		#endregion
-
-		#region PrivateKey
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int PEM_write_bio_PrivateKey(IntPtr bp, IntPtr x, IntPtr enc, byte[] kstr, int klen, pem_password_cb cb, IntPtr u);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr PEM_read_bio_PrivateKey(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
-		#endregion
-
-		#region PUBKEY
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int PEM_write_bio_PUBKEY(IntPtr bp, IntPtr x);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr PEM_read_bio_PUBKEY(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
-		#endregion
-
-		#endregion
-
-		#region EVP
-
-		#region Constants
-		public const int EVP_MAX_MD_SIZE = 64; //!!(16+20);
-		public const int EVP_MAX_KEY_LENGTH = 32;
-		public const int EVP_MAX_IV_LENGTH = 16;
-		public const int EVP_MAX_BLOCK_LENGTH = 32;
-
-		public const int EVP_CIPH_STREAM_CIPHER = 0x0;
-		public const int EVP_CIPH_ECB_MODE = 0x1;
-		public const int EVP_CIPH_CBC_MODE = 0x2;
-		public const int EVP_CIPH_CFB_MODE = 0x3;
-		public const int EVP_CIPH_OFB_MODE = 0x4;
-		public const int EVP_CIPH_MODE = 0x7;
-		public const int EVP_CIPH_VARIABLE_LENGTH = 0x8;
-		public const int EVP_CIPH_CUSTOM_IV = 0x10;
-		public const int EVP_CIPH_ALWAYS_CALL_INIT = 0x20;
-		public const int EVP_CIPH_CTRL_INIT = 0x40;
-		public const int EVP_CIPH_CUSTOM_KEY_LENGTH = 0x80;
-		public const int EVP_CIPH_NO_PADDING = 0x100;
-		public const int EVP_CIPH_FLAG_FIPS = 0x400;
-		public const int EVP_CIPH_FLAG_NON_FIPS_ALLOW = 0x800;
-		#endregion
-
-		#region Message Digests
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_md_null();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_md2();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_md4();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_md5();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_sha();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_sha1();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_sha224();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_sha256();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_sha384();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_sha512();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_dss();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_dss1();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_mdc2();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_ripemd160();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_ecdsa();
-		#endregion
-
-		#region HMAC
-		public const int HMAC_MAX_MD_CBLOCK = 128;
-
-		//!!void HMAC_CTX_init(HMAC_CTX *ctx);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void HMAC_CTX_init(IntPtr ctx);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void HMAC_CTX_set_flags(IntPtr ctx, uint flags);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void HMAC_CTX_cleanup(IntPtr ctx);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void HMAC_Init(IntPtr ctx, byte[] key, int len, IntPtr md); /* deprecated */
-		
-		//!!public extern static void HMAC_Init_ex(IntPtr ctx, const void *key, int len, const EVP_MD *md, ENGINE *impl);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void HMAC_Init_ex(IntPtr ctx, byte[] key, int len, IntPtr md, IntPtr engine_impl);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void HMAC_Update(IntPtr ctx, byte[] data, int len);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void HMAC_Final(IntPtr ctx, byte[] md, ref uint len);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr HMAC(IntPtr evp_md, byte[] key, int key_len, byte[] d, int n, byte[] md, ref uint md_len);
-		#endregion
-
-		#region Ciphers
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_get_cipherbyname(byte[] name);
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_enc_null();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_des_ecb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_des_ede();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_des_ede3();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_des_ede_ecb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_des_ede3_ecb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_des_cfb64();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_des_cfb1();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_des_cfb8();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_des_ede_cfb64();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_des_ede3_cfb64();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_des_ede3_cfb1();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_des_ede3_cfb8();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_des_ofb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_des_ede_ofb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_des_ede3_ofb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_des_cbc();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_des_ede_cbc();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_des_ede3_cbc();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_desx_cbc();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_rc4();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_rc4_40();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_idea_ecb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_idea_cfb64();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_idea_ofb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_idea_cbc();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_rc2_ecb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_rc2_cbc();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_rc2_40_cbc();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_rc2_64_cbc();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_rc2_cfb64();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_rc2_ofb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_bf_ecb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_bf_cbc();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_bf_cfb64();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_bf_ofb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_cast5_ecb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_cast5_cbc();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_cast5_cfb64();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_cast5_ofb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_rc5_32_12_16_cbc();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_rc5_32_12_16_ecb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_rc5_32_12_16_cfb64();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_rc5_32_12_16_ofb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_aes_128_ecb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_aes_128_cbc();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_aes_128_cfb1();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_aes_128_cfb8();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_aes_128_cfb128();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_aes_128_ofb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_aes_192_ecb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_aes_192_cbc();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_aes_192_cfb1();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_aes_192_cfb8();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_aes_192_cfb128();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_aes_192_ofb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_aes_256_ecb();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_aes_256_cbc();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_aes_256_cfb1();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_aes_256_cfb8();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_aes_256_cfb128();
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_aes_256_ofb();
-
-		#endregion
-
-		#region EVP_PKEY
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_PKEY_new();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void EVP_PKEY_free(IntPtr pkey);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_PKEY_cmp(IntPtr a, IntPtr b);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_PKEY_decrypt(byte[] dec_key, byte[] enc_key, int enc_key_len, IntPtr private_key);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_PKEY_encrypt(byte[] enc_key, byte[] key, int key_len, IntPtr pub_key);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_PKEY_type(int type);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_PKEY_bits(IntPtr pkey);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_PKEY_size(IntPtr pkey);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_PKEY_assign(IntPtr pkey, int type, byte[] key);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_PKEY_set1_DSA(IntPtr pkey, IntPtr key);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_PKEY_get1_DSA(IntPtr pkey);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_PKEY_set1_RSA(IntPtr pkey, IntPtr key);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_PKEY_get1_RSA(IntPtr pkey);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_PKEY_set1_DH(IntPtr pkey, IntPtr key);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_PKEY_get1_DH(IntPtr pkey);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_PKEY_copy_parameters(IntPtr to, IntPtr from);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_PKEY_missing_parameters(IntPtr pkey);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_PKEY_save_parameters(IntPtr pkey, int mode);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_PKEY_cmp_parameters(IntPtr a, IntPtr b);
-
-		#endregion
-
-		#region EVP_CIPHER
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void EVP_CIPHER_CTX_init(IntPtr a);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_CIPHER_CTX_set_padding(IntPtr x, int padding);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_CIPHER_CTX_set_key_length(IntPtr x, int keylen);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_CIPHER_CTX_ctrl(IntPtr ctx, int type, int arg, IntPtr ptr);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_CIPHER_CTX_cleanup(IntPtr a);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_CIPHER_type(IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_CipherInit_ex(IntPtr ctx, IntPtr type, IntPtr impl, byte[] key, byte[] iv, int enc);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_CipherUpdate(IntPtr ctx, byte[] outb, out int outl, byte[] inb, int inl);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_CipherFinal_ex(IntPtr ctx, byte[] outm, ref int outl);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_OpenInit(IntPtr ctx, IntPtr type, byte[] ek, int ekl, byte[] iv, IntPtr priv);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_OpenFinal(IntPtr ctx, byte[] outb, out int outl);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_SealInit(IntPtr ctx, IntPtr type, byte[][] ek, int[] ekl, byte[] iv, IntPtr[] pubk, int npubk);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_SealFinal(IntPtr ctx, byte[] outb, out int outl);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_DecryptUpdate(IntPtr ctx, byte[] output, out int outl, byte[] input, int inl);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_EncryptUpdate(IntPtr ctx, byte[] output, out int outl, byte[] input, int inl);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_BytesToKey(IntPtr type, IntPtr md, byte[] salt, byte[] data, int datal, int count, byte[] key, byte[] iv);
-
-		#endregion
-
-		#region EVP_MD
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_get_digestbyname(byte[] name);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void EVP_MD_CTX_init(IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_MD_CTX_cleanup(IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EVP_MD_CTX_create();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void EVP_MD_CTX_destroy(IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_DigestInit_ex(IntPtr ctx, IntPtr type, IntPtr impl);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_DigestUpdate(IntPtr ctx, byte[] d, uint cnt);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_DigestFinal_ex(IntPtr ctx, byte[] md, ref uint s);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_Digest(byte[] data, uint count, byte[] md, ref uint size, IntPtr type, IntPtr impl);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_SignFinal(IntPtr ctx, byte[] md, ref uint s, IntPtr pkey);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EVP_VerifyFinal(IntPtr ctx, byte[] sigbuf, uint siglen, IntPtr pkey);
-
-		#endregion
-
-		#endregion
-		
-		#region EC
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_get_builtin_curves(IntPtr r, int nitems);
-		
-		#region EC_METHOD
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_GFp_simple_method();
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_GFp_mont_method();
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_GFp_nist_method();
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_GF2m_simple_method();
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_METHOD_get_field_type(IntPtr meth);
-		#endregion
-		
-		#region EC_GROUP
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_GROUP_new(IntPtr meth);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void EC_GROUP_free(IntPtr group);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void EC_GROUP_clear_free(IntPtr group);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_GROUP_copy(IntPtr dst, IntPtr src);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_GROUP_dup(IntPtr src);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_GROUP_method_of(IntPtr group);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_GROUP_set_generator(IntPtr group, IntPtr generator, IntPtr order, IntPtr cofactor);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_GROUP_get0_generator(IntPtr group);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_GROUP_get_order(IntPtr group, IntPtr order, IntPtr ctx);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_GROUP_get_cofactor(IntPtr group, IntPtr cofactor, IntPtr ctx);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void EC_GROUP_set_curve_name(IntPtr group, int nid);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_GROUP_get_curve_name(IntPtr group);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void EC_GROUP_set_asn1_flag(IntPtr group, int flag);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_GROUP_get_asn1_flag(IntPtr group);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void EC_GROUP_set_point_conversion_form(IntPtr x, int y);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_GROUP_get_point_conversion_form(IntPtr x);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static byte[] EC_GROUP_get0_seed(IntPtr x);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_GROUP_get_seed_len(IntPtr x);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_GROUP_set_seed(IntPtr x, byte[] buf, int len);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_GROUP_set_curve_GFp(IntPtr group, IntPtr p, IntPtr a, IntPtr b, IntPtr ctx);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_GROUP_get_curve_GFp(IntPtr group, IntPtr p, IntPtr a, IntPtr b, IntPtr ctx);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_GROUP_set_curve_GF2m(IntPtr group, IntPtr p, IntPtr a, IntPtr b, IntPtr ctx);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_GROUP_get_curve_GF2m(IntPtr group, IntPtr p, IntPtr a, IntPtr b, IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_GROUP_get_degree(IntPtr group);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_GROUP_check(IntPtr group, IntPtr ctx);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_GROUP_check_discriminant(IntPtr group, IntPtr ctx);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_GROUP_cmp(IntPtr a, IntPtr b, IntPtr ctx);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_GROUP_new_curve_GFp(IntPtr p, IntPtr a, IntPtr b, IntPtr ctx);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_GROUP_new_curve_GF2m(IntPtr p, IntPtr a, IntPtr b, IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_GROUP_new_by_curve_name(int nid);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_GROUP_precompute_mult(IntPtr group, IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_GROUP_have_precompute_mult(IntPtr group);
-		#endregion
-
-		#region EC_POINT
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_POINT_new(IntPtr group);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void EC_POINT_free(IntPtr point);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void EC_POINT_clear_free(IntPtr point);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINT_copy(IntPtr dst, IntPtr src);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_POINT_dup(IntPtr src, IntPtr group);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_POINT_method_of(IntPtr point);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINT_set_to_infinity(IntPtr group, IntPtr point);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINT_set_Jprojective_coordinates_GFp(IntPtr group, IntPtr p, IntPtr x, IntPtr y, IntPtr z, IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINT_get_Jprojective_coordinates_GFp(IntPtr group, IntPtr p, IntPtr x, IntPtr y, IntPtr z, IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINT_set_affine_coordinates_GFp(IntPtr group, IntPtr p, IntPtr x, IntPtr y, IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINT_get_affine_coordinates_GFp(IntPtr group, IntPtr p, IntPtr x, IntPtr y, IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINT_set_compressed_coordinates_GFp(IntPtr group, IntPtr p, IntPtr x, int y_bit, IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINT_set_affine_coordinates_GF2m(IntPtr group, IntPtr p, IntPtr x, IntPtr y, IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINT_get_affine_coordinates_GF2m(IntPtr group, IntPtr p, IntPtr x, IntPtr y, IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINT_set_compressed_coordinates_GF2m(IntPtr group, IntPtr p, IntPtr x, int y_bit, IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINT_point2oct(IntPtr group, IntPtr p, int form, byte[] buf, int len, IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINT_oct2point(IntPtr group, IntPtr p, byte[] buf, int len, IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_POINT_point2bn(IntPtr a, IntPtr b, int form, IntPtr c, IntPtr d);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_POINT_bn2point(IntPtr a, IntPtr b, IntPtr c, IntPtr d);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static string EC_POINT_point2hex(IntPtr a, IntPtr b, int form, IntPtr c);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_POINT_hex2point(IntPtr a, string s, IntPtr b, IntPtr c);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINT_add(IntPtr group, IntPtr r, IntPtr a, IntPtr b, IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINT_dbl(IntPtr group, IntPtr r, IntPtr a, IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINT_invert(IntPtr group, IntPtr a, IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINT_is_at_infinity(IntPtr group, IntPtr p);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINT_is_on_curve(IntPtr group, IntPtr point, IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINT_cmp(IntPtr group, IntPtr a, IntPtr b, IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINT_make_affine(IntPtr a, IntPtr b, IntPtr c);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINTs_make_affine(IntPtr a, int num, IntPtr[] b, IntPtr c);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINTs_mul(IntPtr group, IntPtr r, IntPtr n, int num, IntPtr[] p, IntPtr[] m, IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_POINT_mul(IntPtr group, IntPtr r, IntPtr n, IntPtr q, IntPtr m, IntPtr ctx);
-		#endregion
-		
-		#region EC_KEY
-		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
-		public delegate IntPtr EC_KEY_dup_func(IntPtr x);
-
-		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
-		public delegate void EC_KEY_free_func(IntPtr x);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_KEY_new();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_KEY_new_by_curve_name(int nid);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void EC_KEY_free(IntPtr key);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_KEY_copy(IntPtr dst, IntPtr src);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_KEY_dup(IntPtr src);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_KEY_up_ref(IntPtr key);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_KEY_get0_group(IntPtr key);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_KEY_set_group(IntPtr key, IntPtr group);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_KEY_get0_private_key(IntPtr key);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_KEY_set_private_key(IntPtr key, IntPtr prv);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_KEY_get0_public_key(IntPtr key);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_KEY_set_public_key(IntPtr key, IntPtr pub);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static uint EC_KEY_get_enc_flags(IntPtr key);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void EC_KEY_set_enc_flags(IntPtr x, uint y);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_KEY_get_conv_form(IntPtr x);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void EC_KEY_set_conv_form(IntPtr x, int y);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr EC_KEY_get_key_method_data(IntPtr x, EC_KEY_dup_func dup_func, EC_KEY_free_func free_func, EC_KEY_free_func clear_free_func);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void EC_KEY_insert_key_method_data(IntPtr x, IntPtr data, EC_KEY_dup_func dup_func, EC_KEY_free_func free_func, EC_KEY_free_func clear_free_func);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void EC_KEY_set_asn1_flag(IntPtr x, int y);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_KEY_precompute_mult(IntPtr key, IntPtr ctx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_KEY_generate_key(IntPtr key);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int EC_KEY_check_key(IntPtr key);
-		#endregion
-		
-		#region ECDSA
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr ECDSA_SIG_new();
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void ECDSA_SIG_free(IntPtr sig);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int i2d_ECDSA_SIG(IntPtr sig, byte[] pp);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr d2i_ECDSA_SIG(IntPtr sig, byte[] pp, long len);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr ECDSA_do_sign(byte[] dgst, int dgst_len, IntPtr eckey);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr ECDSA_do_sign_ex(byte[] dgst, int dgstlen, IntPtr kinv, IntPtr rp, IntPtr eckey);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int ECDSA_do_verify(byte[] dgst, int dgst_len, IntPtr sig, IntPtr eckey);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr ECDSA_OpenSSL();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void ECDSA_set_default_method(IntPtr meth);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr ECDSA_get_default_method();
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int ECDSA_set_method(IntPtr eckey, IntPtr meth);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int ECDSA_size(IntPtr eckey);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int ECDSA_sign_setup(IntPtr eckey, IntPtr ctx, IntPtr kinv, IntPtr rp);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int ECDSA_sign(int type, byte[] dgst, int dgstlen, byte[] sig, ref uint siglen, IntPtr eckey);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int ECDSA_sign_ex(int type, byte[] dgst, int dgstlen, byte[] sig, ref uint siglen, IntPtr kinv, IntPtr rp, IntPtr eckey);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int ECDSA_verify(int type, byte[] dgst, int dgstlen, byte[] sig, int siglen, IntPtr eckey);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int ECDSA_get_ex_new_index(IntPtr argl, IntPtr argp, IntPtr new_func, IntPtr dup_func, IntPtr free_func);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int ECDSA_set_ex_data(IntPtr d, int idx, IntPtr arg);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr ECDSA_get_ex_data(IntPtr d, int idx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void ERR_load_ECDSA_strings();
-		#endregion
-		
-		#region ECDH
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr ECDH_OpenSSL();
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void ECDH_set_default_method(IntPtr method);
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr ECDH_get_default_method();
-		
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int ECDH_set_method(IntPtr key, IntPtr method);
-
-		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
-		public delegate IntPtr ECDH_KDF([MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)] byte[] pin,
-		                                int inlen,
-		                                IntPtr pout, 
-		                                ref int outlen);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int ECDH_compute_key(byte[] pout, int outlen, IntPtr pub_key, IntPtr ecdh, ECDH_KDF kdf);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int ECDH_get_ex_new_index(IntPtr argl, IntPtr argp, IntPtr new_func, IntPtr dup_func, IntPtr free_func);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int ECDH_set_ex_data(IntPtr d, int idx, IntPtr arg);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr ECDH_get_ex_data(IntPtr d, int idx);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void ERR_load_ECDH_strings();
-		#endregion
-
-		#endregion
-
-		#region BIO
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		//!!public extern static IntPtr BIO_new_file(byte[] filename, byte[] mode);
-		public extern static IntPtr BIO_new_file(string filename, string mode);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr BIO_new_mem_buf(byte[] buf, int len);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr BIO_s_mem();
-
-		// Unsupported!
-		//[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		//public extern static IntPtr BIO_s_fd();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr BIO_f_md();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr BIO_f_null();
-
-		const int BIO_C_SET_FD = 104;
-		const int BIO_C_SET_MD = 111;
-		const int BIO_C_GET_MD = 112;
-		const int BIO_C_GET_MD_CTX = 120;
-		const int BIO_C_SET_MD_CTX = 148;
-
-		public const int BIO_NOCLOSE = 0x00;
-		public const int BIO_CLOSE = 0x01;
-
-		public static void BIO_set_md(IntPtr bp, IntPtr md)
-		{
-			Native.ExpectSuccess(BIO_ctrl(bp, BIO_C_SET_MD, 0, md));
-		}
-
-		// Unsupported!
-		//public static void BIO_set_fd(IntPtr bp, int fd, int c)
-		//{
-		//    Native.ExpectSuccess(BIO_int_ctrl(bp, BIO_C_SET_FD, c, fd));
-		//}
-
-		public static IntPtr BIO_get_md(IntPtr bp)
-		{
-			IntPtr ptr = Marshal.AllocHGlobal(4);
-			try
-			{
-				ExpectSuccess(BIO_ctrl(bp, BIO_C_GET_MD, 0, ptr));
-				return Marshal.ReadIntPtr(ptr);
-			}
-			finally
-			{
-				Marshal.FreeHGlobal(ptr);
-			}
-		}
-
-		public static IntPtr BIO_get_md_ctx(IntPtr bp)
-		{
-			IntPtr ptr = Marshal.AllocHGlobal(4);
-			try
-			{
-				ExpectSuccess(BIO_ctrl(bp, BIO_C_GET_MD_CTX, 0, ptr));
-				return Marshal.ReadIntPtr(ptr);
-			}
-			finally
-			{
-				Marshal.FreeHGlobal(ptr);
-			}
-		}
-
-		public static void BIO_set_md_ctx(IntPtr bp, IntPtr mdcp)
-		{
-			Native.ExpectSuccess(BIO_ctrl(bp, BIO_C_SET_MD_CTX, 0, mdcp));
-		}
-
-		const int BIO_CTRL_SET_CLOSE = 9;  /* man - set the 'close' on free */
-
-		//#define BIO_set_close(b,c)	(int)BIO_ctrl(b,BIO_CTRL_SET_CLOSE,(c),NULL)
-		public static int BIO_set_close(IntPtr bp, int arg)
-		{
-			return BIO_ctrl(bp, BIO_CTRL_SET_CLOSE, arg, IntPtr.Zero);
-		}
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr BIO_push(IntPtr bp, IntPtr append);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BIO_ctrl(IntPtr bp, int cmd, int larg, IntPtr parg);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BIO_int_ctrl(IntPtr bp, int cmd, int larg, int parg);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr BIO_new(IntPtr type);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BIO_read(IntPtr b, byte[] buf, int len);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BIO_write(IntPtr b, byte[] buf, int len);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BIO_puts(IntPtr b, byte[] buf);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int BIO_gets(IntPtr b, byte[] buf, int len);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void BIO_free(IntPtr bio);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static uint BIO_number_read(IntPtr bio);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static uint BIO_number_written(IntPtr bio);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static uint BIO_ctrl_pending(IntPtr bio);
-
-		#endregion
-
-		#region ERR
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void ERR_load_crypto_strings();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static uint ERR_get_error();
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void ERR_error_string_n(uint e, byte[] buf, int len);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr ERR_lib_error_string(uint e);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr ERR_func_error_string(uint e);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr ERR_reason_error_string(uint e);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void ERR_remove_state(uint pid);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void ERR_clear_error();
-
-		#endregion
-
-		#region NCONF
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr NCONF_new(IntPtr meth);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void NCONF_free(IntPtr conf);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		//!!public extern static int NCONF_load(IntPtr conf, byte[] file, ref int eline);
-		public extern static int NCONF_load(IntPtr conf, string file, ref int eline);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr NCONF_get_string(IntPtr conf, byte[] group, byte[] name);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void X509V3_set_ctx(IntPtr ctx, IntPtr issuer, IntPtr subject, IntPtr req, IntPtr crl, int flags);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void X509V3_set_nconf(IntPtr ctx, IntPtr conf);
-
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int X509V3_EXT_add_nconf(IntPtr conf, IntPtr ctx, byte[] section, IntPtr cert);
-
-		#endregion
-
-		#region FIPS
-		[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int FIPS_mode_set(int onoff);
-
-		#endregion
-
-		#region SSL Routines
-		#region Initialization
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void SSL_load_error_strings();
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_library_init();
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void ERR_free_strings();
-
-		#endregion
-
-		#region SSL Methods
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr SSLv2_method();
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr SSLv2_server_method();
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr SSLv2_client_method();
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr SSLv3_method();
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr SSLv3_server_method();
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr SSLv3_client_method();
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr SSLv23_method();
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr SSLv23_server_method();
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr SSLv23_client_method();
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr TLSv1_method();
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr TLSv1_client_method();
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr TLSv1_server_method();
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr DTLSv1_method();
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr DTLSv1_client_method();
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr DTLSv1_server_method();
-
-		#endregion
-
-		#region SSL_CTX
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr SSL_CTX_new(IntPtr sslMethod);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void SSL_CTX_free(IntPtr ctx);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_CTX_ctrl(IntPtr ctx, int cmd, int arg, IntPtr parg);
-
-		public const int SSL_CTRL_OPTIONS = 32;
-		public const int SSL_CTRL_MODE = 33;
-
-		public const int SSL_OP_MICROSOFT_SESS_ID_BUG = 0x00000001;
-		public const int SSL_OP_NETSCAPE_CHALLENGE_BUG = 0x00000002;
-		public const int SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = 0x00000008;
-		public const int SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG = 0x00000010;
-		public const int SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER = 0x00000020;
-		public const int SSL_OP_MSIE_SSLV2_RSA_PADDING = 0x00000040; /* no effect since 0.9.7h and 0.9.8b */
-		public const int SSL_OP_SSLEAY_080_CLIENT_DH_BUG = 0x00000080;
-		public const int SSL_OP_TLS_D5_BUG = 0x00000100;
-		public const int SSL_OP_TLS_BLOCK_PADDING_BUG = 0x00000200;
-
-		/* Disable SSL 3.0/TLS 1.0 CBC vulnerability workaround that was added
-		 * in OpenSSL 0.9.6d.  Usually (depending on the application protocol)
-		 * the workaround is not needed.  Unfortunately some broken SSL/TLS
-		 * implementations cannot handle it at all, which is why we include
-		 * it in SSL_OP_ALL. */
-		public const int SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS = 0x00000800; /* added in 0.9.6e */
-
-		/* SSL_OP_ALL: various bug workarounds that should be rather harmless.
-		 *             This used to be 0x000FFFFFL before 0.9.7. */
-		public const int SSL_OP_ALL = (0x00000FFF ^ SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG);
-
-		/* As server, disallow session resumption on renegotiation */
-		public const int SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION = 0x00010000;
-		/* If set, always create a new key when using tmp_dh parameters */
-		public const int SSL_OP_SINGLE_DH_USE = 0x00100000;
-		/* Set to always use the tmp_rsa key when doing RSA operations,
-		 * even when this violates protocol specs */
-		public const int SSL_OP_EPHEMERAL_RSA = 0x00200000;
-		/* Set on servers to choose the cipher according to the server's
-		 * preferences */
-		public const int SSL_OP_CIPHER_SERVER_PREFERENCE = 0x00400000;
-		/* If set, a server will allow a client to issue a SSLv3.0 version number
-		 * as latest version supported in the premaster secret, even when TLSv1.0
-		 * (version 3.1) was announced in the client hello. Normally this is
-		 * forbidden to prevent version rollback attacks. */
-		public const int SSL_OP_TLS_ROLLBACK_BUG = 0x00800000;
-
-		public const int SSL_OP_NO_SSLv2 = 0x01000000;
-		public const int SSL_OP_NO_SSLv3 = 0x02000000;
-		public const int SSL_OP_NO_TLSv1 = 0x04000000;
-
-		/* The next flag deliberately changes the ciphertest, this is a check
-		 * for the PKCS#1 attack */
-		public const int SSL_OP_PKCS1_CHECK_1 = 0x08000000;
-		public const int SSL_OP_PKCS1_CHECK_2 = 0x10000000;
-		public const int SSL_OP_NETSCAPE_CA_DN_BUG = 0x20000000;
-		public const int SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG = 0x40000000;
-
-
-		/* Allow SSL_write(..., n) to return r with 0 < r < n (i.e. report success
-		 * when just a single record has been written): */
-		public const int SSL_MODE_ENABLE_PARTIAL_WRITE = 0x00000001;
-		/* Make it possible to retry SSL_write() with changed buffer location
-		 * (buffer contents must stay the same!); this is not the default to avoid
-		 * the misconception that non-blocking SSL_write() behaves like
-		 * non-blocking write(): */
-		public const int SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER = 0x00000002;
-		/* Never bother the application with retries if the transport
-		 * is blocking: */
-		public const int SSL_MODE_AUTO_RETRY = 0x00000004;
-		/* Don't attempt to automatically build certificate chain */
-		public const int SSL_MODE_NO_AUTO_CHAIN = 0x00000008;
-
-		/// <summary>
-		/// #define SSL_CTX_ctrl in ssl.h - calls SSL_CTX_ctrl()
-		/// </summary>
-		/// <param name="ctx"></param>
-		/// <param name="op"></param>
-		/// <returns></returns>
-		public static int SSL_CTX_set_mode(IntPtr ctx, int op)
-		{
-			return SSL_CTX_ctrl(ctx, SSL_CTRL_MODE, op, IntPtr.Zero);
-		}
-
-		/// <summary>
-		/// #define SSL_CTX_set_options in ssl.h - calls SSL_CTX_ctrl
-		/// </summary>
-		/// <param name="ctx"></param>
-		/// <param name="op"></param>
-		/// <returns></returns>
-		public static int SSL_CTX_set_options(IntPtr ctx, int op)
-		{
-			return SSL_CTX_ctrl(ctx, SSL_CTRL_OPTIONS, op, IntPtr.Zero);
-		}
-
-		/// <summary>
-		/// #define SSL_CTX_get_mode in ssl.h - calls SSL_CTX_ctrl
-		/// </summary>
-		/// <param name="ctx"></param>
-		/// <returns></returns>
-		public static int SSL_CTX_get_mode(IntPtr ctx)
-		{
-			return SSL_CTX_ctrl(ctx, SSL_CTRL_OPTIONS, 0, IntPtr.Zero);
-		}
-
-		/// <summary>
-		/// #define SSL_CTX_get_options in ssl.h - calls SSL_CTX_ctrl
-		/// </summary>
-		/// <param name="ctx"></param>
-		/// <returns>Int32 representation of options set in the context</returns>
-		public static int SSL_CTX_get_options(IntPtr ctx)
-		{
-			return SSL_CTX_ctrl(ctx, SSL_CTRL_OPTIONS, 0, IntPtr.Zero);
-		}
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void SSL_CTX_set_cert_store(IntPtr ctx, IntPtr cert_store);
-
-		public const int SSL_VERIFY_NONE = 0x00;
-		public const int SSL_VERIFY_PEER = 0x01;
-		public const int SSL_VERIFY_FAIL_IF_NO_PEER_CERT = 0x02;
-		public const int SSL_VERIFY_CLIENT_ONCE = 0x04;
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void SSL_CTX_set_verify(IntPtr ctx, int mode, VerifyCertCallback callback);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void SSL_CTX_set_verify_depth(IntPtr ctx, int depth);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void SSL_CTX_set_client_CA_list(IntPtr ctx, IntPtr name_list);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr SSL_CTX_get_client_CA_list(IntPtr ctx);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_CTX_load_verify_locations(IntPtr ctx, string file, string path);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_CTX_set_default_verify_paths(IntPtr ctx);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_CTX_set_cipher_list(IntPtr ctx, string cipher_string);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_CTX_use_certificate_chain_file(IntPtr ctx, string file);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_CTX_use_certificate(IntPtr ctx, IntPtr cert);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_CTX_use_PrivateKey(IntPtr ctx, IntPtr pkey);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_CTX_use_PrivateKey_file(IntPtr ctx, string file, int type);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_CTX_check_private_key(IntPtr ctx);
-
-		public const int SSL_MAX_SID_CTX_LENGTH = 32;
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_CTX_set_session_id_context(IntPtr ctx, byte[] sid_ctx, uint sid_ctx_len);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void SSL_CTX_set_default_passwd_cb_userdata(IntPtr ssl, IntPtr data);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void SSL_CTX_set_default_passwd_cb(IntPtr ssl, pem_password_cb callback);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void SSL_CTX_set_client_cert_cb(IntPtr ssl_ctx, client_cert_cb callback);
-
-		#endregion
-
-		#region SSL functions
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr SSL_CIPHER_description(IntPtr ssl_cipher, byte[] buf, int buf_len);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static string SSL_CIPHER_name(IntPtr ssl_cipher);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_CIPHER_get_bits(IntPtr ssl_cipher, out int alg_bits);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr SSL_get_current_cipher(IntPtr ssl);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_get_verify_result(IntPtr ssl);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_set_verify_result(IntPtr ssl, int v);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr SSL_get_peer_certificate(IntPtr ssl);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_get_error(IntPtr ssl, int ret_code);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_accept(IntPtr ssl);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_shutdown(IntPtr ssl);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_write(IntPtr ssl, byte[] buf, int len);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_read(IntPtr ssl, byte[] buf, int len);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_renegotiate(IntPtr ssl);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_set_session_id_context(IntPtr ssl, byte[] sid_ctx, uint sid_ctx_len);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_do_handshake(IntPtr ssl);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void SSL_set_connect_state(IntPtr ssl);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void SSL_set_accept_state(IntPtr ssl);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_connect(IntPtr ssl);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr SSL_new(IntPtr ctx);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void SSL_free(IntPtr ssl);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void SSL_set_bio(IntPtr ssl, IntPtr read_bio, IntPtr write_bio);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_use_certificate_file(IntPtr ssl, string file, int type);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_use_PrivateKey_file(IntPtr ssl, string file, int type);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_clear(IntPtr ssl);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr SSL_load_client_CA_file(string file);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr SSL_get_client_CA_list(IntPtr ssl);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static void SSL_set_client_CA_list(IntPtr ssl, IntPtr name_list);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static IntPtr SSL_get_certificate(IntPtr ssl);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_use_certificate(IntPtr ssl, IntPtr x509);
-
-		[DllImport(SSLDLLNAME, CallingConvention=CallingConvention.Cdecl)]
-		public extern static int SSL_use_PrivateKey(IntPtr ssl, IntPtr evp_pkey);
-
-		#endregion
-
-		#endregion
-
-		#region Utilties
-		public static string PtrToStringAnsi(IntPtr ptr, bool hasOwnership)
-		{
-			int len = 0;
-			for (int i = 0; i < 1024; i++, len++)
-			{
-				byte octet = Marshal.ReadByte(ptr, i);
-				if (octet == 0)
-					break;
-			}
-
-			if (len == 1024)
-				return "Invalid string";
-
-			byte[] buf = new byte[len];
-			Marshal.Copy(ptr, buf, 0, len);
-			if (hasOwnership)
-				Native.OPENSSL_free(ptr);
-			return Encoding.ASCII.GetString(buf, 0, len);
-		}
-
-		public static IntPtr ExpectNonNull(IntPtr ptr)
-		{
-			if (ptr == IntPtr.Zero)
-				throw new OpenSslException();
-			return ptr;
-		}
-
-		public static int ExpectSuccess(int ret)
-		{
-			if (ret <= 0)
-				throw new OpenSslException();
-			return ret;
-		}
-
-		public static int TextToNID(string text)
-		{
-			int nid = Native.OBJ_txt2nid(text);
-			if (nid == Native.NID_undef)
-				throw new OpenSslException();
-			return nid;
-		}
-		#endregion
-	}
-
-	class NameCollector
-	{
-		[StructLayout(LayoutKind.Sequential)]
-		struct OBJ_NAME
-		{
-			public int type;
-			public int alias;
-			public IntPtr name;
-			public IntPtr data;
-		};
-
-		private List<string> list = new List<string>();
-		public List<string> Result { get { return this.list; } }
-
-		public NameCollector(int type, bool isSorted)
-		{
-			if (isSorted)
-				Native.OBJ_NAME_do_all_sorted(type, this.OnObjectName, IntPtr.Zero);
-			else
-				Native.OBJ_NAME_do_all(type, this.OnObjectName, IntPtr.Zero);
-		}
-
-		private void OnObjectName(IntPtr ptr, IntPtr arg)
-		{
-			OBJ_NAME name = (OBJ_NAME)Marshal.PtrToStructure(ptr, typeof(OBJ_NAME));
-			string str = Native.PtrToStringAnsi(name.name, false);
-			this.list.Add(str);
-		}
-	}
-}
+// Copyright (c) 2006-2012 Frank Laub
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+using System;
+using System.Collections.Generic;
+using System.Reflection;
+using System.Runtime.InteropServices;
+using System.Security.Cryptography;
+using System.Text;
+using System.Threading;
+
+namespace OpenSSL.Core
+{
+	/// <summary>
+	/// 
+	/// </summary>
+	public static class FIPS
+	{
+		/// <summary>
+		/// 
+		/// </summary>
+		public static bool Enabled { get; set; }
+	}
+
+	internal enum CryptoLockTypes
+	{
+		CRYPTO_LOCK_ERR = 1,
+		CRYPTO_LOCK_EX_DATA = 2,
+		CRYPTO_LOCK_X509 = 3,
+		CRYPTO_LOCK_X509_INFO = 4,
+		CRYPTO_LOCK_X509_PKEY = 5,
+		CRYPTO_LOCK_X509_CRL = 6,
+		CRYPTO_LOCK_X509_REQ = 7,
+		CRYPTO_LOCK_DSA = 8,
+		CRYPTO_LOCK_RSA = 9,
+		CRYPTO_LOCK_EVP_PKEY = 10,
+		CRYPTO_LOCK_X509_STORE = 11,
+		CRYPTO_LOCK_SSL_CTX = 12,
+		CRYPTO_LOCK_SSL_CERT = 13,
+		CRYPTO_LOCK_SSL_SESSION = 14,
+		CRYPTO_LOCK_SSL_SESS_CERT = 15,
+		CRYPTO_LOCK_SSL = 16,
+		CRYPTO_LOCK_SSL_METHOD = 17,
+		CRYPTO_LOCK_RAND = 18,
+		CRYPTO_LOCK_RAND2 = 19,
+		CRYPTO_LOCK_MALLOC = 20,
+		CRYPTO_LOCK_BIO = 21,
+		CRYPTO_LOCK_GETHOSTBYNAME = 22,
+		CRYPTO_LOCK_GETSERVBYNAME = 23,
+		CRYPTO_LOCK_READDIR = 24,
+		CRYPTO_LOCK_RSA_BLINDING = 25,
+		CRYPTO_LOCK_DH = 26,
+		CRYPTO_LOCK_MALLOC2 = 27,
+		CRYPTO_LOCK_DSO = 28,
+		CRYPTO_LOCK_DYNLOCK = 29,
+		CRYPTO_LOCK_ENGINE = 30,
+		CRYPTO_LOCK_UI = 31,
+		CRYPTO_LOCK_ECDSA = 32,
+		CRYPTO_LOCK_EC = 33,
+		CRYPTO_LOCK_ECDH = 34,
+		CRYPTO_LOCK_BN = 35,
+		CRYPTO_LOCK_EC_PRE_COMP = 36,
+		CRYPTO_LOCK_STORE = 37,
+		CRYPTO_LOCK_COMP = 38,
+		CRYPTO_LOCK_FIPS = 39,
+		CRYPTO_LOCK_FIPS2 = 40,
+		CRYPTO_NUM_LOCKS = 41,
+	}
+
+	/// <summary>
+	/// This is the low-level C-style interface to the crypto API.
+	/// Use this interface with caution.
+	/// </summary>
+	internal class Native
+	{
+		/// <summary>
+		/// This is the name of the DLL that P/Invoke loads and tries to bind all of
+		/// these native functions to.
+		/// </summary>
+		const string DLLNAME = "libeay32";
+		const string SSLDLLNAME = "ssleay32";
+
+		#region Delegates
+
+		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
+		public delegate int err_cb(IntPtr str, uint len, IntPtr u);
+
+		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
+		public delegate int pem_password_cb(IntPtr buf, int size, int rwflag, IntPtr userdata);
+
+		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
+		public delegate int GeneratorHandler(int p, int n, IntPtr arg);
+
+		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
+		public delegate void ObjectNameHandler(IntPtr name, IntPtr arg);
+
+		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
+		public delegate void CRYPTO_locking_callback(int mode, int type, string file, int line);
+
+		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
+		public delegate void CRYPTO_id_callback(IntPtr tid);
+
+		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
+		public delegate int VerifyCertCallback(int ok, IntPtr x509_store_ctx);
+
+		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
+		public delegate int client_cert_cb(IntPtr ssl, out IntPtr x509, out IntPtr pkey);
+
+		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
+		public delegate int alpn_cb(
+			IntPtr ssl, 
+			out string selProto, 
+			out byte selProtoLen,
+			IntPtr inProtos, 
+			int inProtosLen, 
+			IntPtr arg
+		);
+
+		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
+		public delegate IntPtr MallocFunctionPtr(uint num, IntPtr file, int line);
+
+		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
+		public delegate IntPtr ReallocFunctionPtr(IntPtr addr, uint num, IntPtr file, int line);
+
+		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
+		public delegate void FreeFunctionPtr(IntPtr addr);
+
+		#endregion
+
+		#region Initialization
+
+		static Native()
+		{
+			var lib = Version.Library;
+			var wrapper = Version.Wrapper;
+			if (lib.Raw < wrapper.Raw)
+				throw new Exception(string.Format("Invalid version of {0}, expecting {1}, got: {2}",
+					DLLNAME, wrapper, lib));
+
+#if MEMORY_TRACKER
+			MemoryTracker.Init();
+#endif
+
+			// Enable FIPS mode
+			if (FIPS.Enabled)
+			{
+				if (FIPS_mode_set(1) == 0)
+				{
+					throw new Exception("Failed to initialize FIPS mode");
+				}
+			}
+
+			ERR_load_crypto_strings();
+			SSL_load_error_strings();
+
+			OPENSSL_add_all_algorithms_noconf();
+
+			// Initialize SSL library
+			Native.ExpectSuccess(SSL_library_init());
+
+			var seed = new byte[128];
+			var rng = RandomNumberGenerator.Create();
+			rng.GetBytes(seed);
+			RAND_seed(seed, seed.Length);
+		}
+
+		#endregion
+
+		#region Version
+
+		// 1.0.2a Release
+		public const uint Wrapper = 0x1000201F;
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSLeay_version(int type);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static uint SSLeay();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr BN_options();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr MD2_options();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr RC4_options();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr DES_options();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr idea_options();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr BF_options();
+
+		#endregion
+
+		#region Threading
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int CRYPTO_THREADID_set_callback(CRYPTO_id_callback cb);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void CRYPTO_THREADID_set_numeric(IntPtr id, uint val);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void CRYPTO_set_locking_callback(CRYPTO_locking_callback cb);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int CRYPTO_num_locks();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int CRYPTO_add_lock(IntPtr ptr, int amount, CryptoLockTypes type, string file, int line);
+
+		#endregion
+
+		#region CRYPTO
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void OPENSSL_add_all_algorithms_noconf();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void OPENSSL_add_all_algorithms_conf();
+
+		/// <summary>
+		/// #define OPENSSL_malloc(num)	CRYPTO_malloc((int)num,__FILE__,__LINE__)
+		/// </summary>
+		/// <param name="cbSize"></param>
+		/// <returns></returns>
+		public static IntPtr OPENSSL_malloc(int cbSize)
+		{
+			return CRYPTO_malloc(cbSize, Assembly.GetExecutingAssembly().FullName, 0);
+		}
+
+		/// <summary>
+		/// #define OPENSSL_free(addr) CRYPTO_free(addr)
+		/// </summary>
+		/// <param name="p"></param>
+		public static void OPENSSL_free(IntPtr p)
+		{
+			CRYPTO_free(p);
+		}
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void CRYPTO_free(IntPtr p);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr CRYPTO_malloc(int num, string file, int line);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int CRYPTO_set_mem_ex_functions(
+			MallocFunctionPtr m, 
+			ReallocFunctionPtr r, 
+			FreeFunctionPtr f
+		);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void CRYPTO_cleanup_all_ex_data();
+
+		#endregion
+
+		#region OBJ
+
+		public const int NID_undef = 0;
+
+		public const int OBJ_undef = 0;
+
+		public const int OBJ_NAME_TYPE_UNDEF = 0x00;
+		public const int OBJ_NAME_TYPE_MD_METH = 0x01;
+		public const int OBJ_NAME_TYPE_CIPHER_METH = 0x02;
+		public const int OBJ_NAME_TYPE_PKEY_METH = 0x03;
+		public const int OBJ_NAME_TYPE_COMP_METH = 0x04;
+		public const int OBJ_NAME_TYPE_NUM = 0x05;
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void OBJ_NAME_do_all(int type, ObjectNameHandler fn, IntPtr arg);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void OBJ_NAME_do_all_sorted(int type, ObjectNameHandler fn, IntPtr arg);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int OBJ_txt2nid(string s);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr OBJ_nid2obj(int n);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr OBJ_nid2ln(int n);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr OBJ_nid2sn(int n);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int OBJ_obj2nid(IntPtr o);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr OBJ_txt2obj(string s, int no_name);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int OBJ_ln2nid(string s);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int OBJ_sn2nid(string s);
+
+		#endregion
+
+		#region stack
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr sk_new_null();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int sk_num(IntPtr stack);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int sk_find(IntPtr stack, IntPtr data);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int sk_insert(IntPtr stack, IntPtr data, int where);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr sk_shift(IntPtr stack);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int sk_unshift(IntPtr stack, IntPtr data);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int sk_push(IntPtr stack, IntPtr data);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr sk_pop(IntPtr stack);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr sk_delete(IntPtr stack, int loc);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr sk_delete_ptr(IntPtr stack, IntPtr p);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr sk_value(IntPtr stack, int index);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr sk_set(IntPtr stack, int index, IntPtr data);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr sk_dup(IntPtr stack);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void sk_zero(IntPtr stack);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void sk_free(IntPtr stack);
+
+		#endregion
+
+		#region SHA
+
+		public const int SHA_DIGEST_LENGTH = 20;
+
+		#endregion
+
+		#region ASN1
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr ASN1_INTEGER_new();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void ASN1_INTEGER_free(IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int ASN1_INTEGER_set(IntPtr a, int v);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int ASN1_INTEGER_get(IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr ASN1_TIME_set(IntPtr s, long t);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int ASN1_UTCTIME_print(IntPtr bp, IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr ASN1_TIME_new();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void ASN1_TIME_free(IntPtr x);
+
+		public const int V_ASN1_OCTET_STRING = 4;
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr ASN1_STRING_type_new(int type);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr ASN1_STRING_dup(IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void ASN1_STRING_free(IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int ASN1_STRING_cmp(IntPtr a, IntPtr b);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int ASN1_STRING_set(IntPtr str, byte[] data, int len);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr ASN1_STRING_data(IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int ASN1_STRING_length(IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void ASN1_OBJECT_free(IntPtr obj);
+
+		#endregion
+
+		#region X509_REQ
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_REQ_new();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_REQ_set_version(IntPtr x, int version);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_REQ_set_pubkey(IntPtr x, IntPtr pkey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_REQ_get_pubkey(IntPtr req);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_REQ_set_subject_name(IntPtr x, IntPtr name);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_REQ_sign(IntPtr x, IntPtr pkey, IntPtr md);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_REQ_verify(IntPtr x, IntPtr pkey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_REQ_digest(IntPtr data, IntPtr type, byte[] md, ref uint len);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void X509_REQ_free(IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_REQ_to_X509(IntPtr r, int days, IntPtr pkey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_REQ_print_ex(IntPtr bp, IntPtr x, uint nmflag, uint cflag);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_REQ_print(IntPtr bp, IntPtr x);
+
+		#endregion
+
+		#region X509
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_new();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_dup(IntPtr x509);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_cmp(IntPtr a, IntPtr b);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_sign(IntPtr x, IntPtr pkey, IntPtr md);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_check_private_key(IntPtr x509, IntPtr pkey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_verify(IntPtr x, IntPtr pkey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_pubkey_digest(IntPtr data, IntPtr type, byte[] md, ref uint len);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_digest(IntPtr data, IntPtr type, byte[] md, ref uint len);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_set_version(IntPtr x, int version);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_set_serialNumber(IntPtr x, IntPtr serial);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_get_serialNumber(IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_set_issuer_name(IntPtr x, IntPtr name);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_get_issuer_name(IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_set_subject_name(IntPtr x, IntPtr name);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_get_subject_name(IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_set_notBefore(IntPtr x, IntPtr tm);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_set_notAfter(IntPtr x, IntPtr tm);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_set_pubkey(IntPtr x, IntPtr pkey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_get_pubkey(IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void X509_free(IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_verify_cert(IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_verify_cert_error_string(int n);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_to_X509_REQ(IntPtr x, IntPtr pkey, IntPtr md);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_print_ex(IntPtr bp, IntPtr x, uint nmflag, uint cflag);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_print(IntPtr bp, IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_find_by_issuer_and_serial(IntPtr sk, IntPtr name, IntPtr serial);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_find_by_subject(IntPtr sk, IntPtr name);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_check_trust(IntPtr x, int id, int flags);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_time_adj(IntPtr s, int adj, ref long t);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_gmtime_adj(IntPtr s, int adj);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr d2i_X509_bio(IntPtr bp, ref IntPtr x509);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int i2d_X509_bio(IntPtr bp, IntPtr x509);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void X509_PUBKEY_free(IntPtr pkey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void X509_OBJECT_up_ref_count(IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void X509_OBJECT_free_contents(IntPtr a);
+
+		#endregion
+
+		#region X509_EXTENSION
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_EXTENSION_new();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void X509_EXTENSION_free(IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_EXTENSION_dup(IntPtr ex);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509V3_EXT_print(IntPtr bio, IntPtr ext, uint flag, int indent);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509V3_EXT_get_nid(int nid);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_add_ext(IntPtr x, IntPtr ex, int loc);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_add1_ext_i2d(IntPtr x, int nid, byte[] value, int crit, uint flags);
+
+		//X509_EXTENSION* X509V3_EXT_conf_nid(LHASH* conf, X509V3_CTX* ctx, int ext_nid, char* value);
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509V3_EXT_conf_nid(IntPtr conf, IntPtr ctx, int ext_nid, string value);
+
+		//X509_EXTENSION* X509_EXTENSION_create_by_NID(X509_EXTENSION** ex, int nid, int crit, ASN1_OCTET_STRING* data);
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_EXTENSION_create_by_NID(IntPtr ex, int nid, int crit, IntPtr data);
+
+		//X509_EXTENSION* X509_EXTENSION_create_by_OBJ(X509_EXTENSION** ex, ASN1_OBJECT* obj, int crit, ASN1_OCTET_STRING* data);
+		//int X509_EXTENSION_set_object(X509_EXTENSION* ex, ASN1_OBJECT* obj);
+		//int X509_EXTENSION_set_critical(X509_EXTENSION* ex, int crit);
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_EXTENSION_set_critical(IntPtr ex, int crit);
+
+		//int X509_EXTENSION_set_data(X509_EXTENSION* ex, ASN1_OCTET_STRING* data);
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_EXTENSION_set_data(IntPtr ex, IntPtr data);
+
+		//ASN1_OBJECT* X509_EXTENSION_get_object(X509_EXTENSION* ex);
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_EXTENSION_get_object(IntPtr ex);
+
+		//ASN1_OCTET_STRING* X509_EXTENSION_get_data(X509_EXTENSION* ne);
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_EXTENSION_get_data(IntPtr ne);
+
+		//int X509_EXTENSION_get_critical(X509_EXTENSION* ex);
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_EXTENSION_get_critical(IntPtr ex);
+
+		#endregion
+
+		#region X509_STORE
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_STORE_new();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_STORE_add_cert(IntPtr ctx, IntPtr x);
+
+		//[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
+		//void X509_STORE_set_flags();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void X509_STORE_free(IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_STORE_up_ref(IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_STORE_CTX_new();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_STORE_CTX_init(IntPtr ctx, IntPtr store, IntPtr x509, IntPtr chain);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void X509_STORE_CTX_free(IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_STORE_CTX_get_current_cert(IntPtr x509_store_ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_STORE_CTX_get_error_depth(IntPtr x509_store_ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_STORE_CTX_get0_store(IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_STORE_CTX_get_error(IntPtr x509_store_ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void X509_STORE_CTX_set_error(IntPtr x509_store_ctx, int error);
+
+		#endregion
+
+		#region X509_INFO
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void X509_INFO_free(IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_INFO_up_ref(IntPtr a);
+
+		#endregion
+
+		#region X509_NAME
+
+		public const int MBSTRING_FLAG = 0x1000;
+
+		public const int MBSTRING_ASC = MBSTRING_FLAG | 1;
+
+		public const int ASN1_STRFLGS_RFC2253 =
+			ASN1_STRFLGS_ESC_2253 |
+			ASN1_STRFLGS_ESC_CTRL |
+			ASN1_STRFLGS_ESC_MSB |
+			ASN1_STRFLGS_UTF8_CONVERT |
+			ASN1_STRFLGS_DUMP_UNKNOWN |
+			ASN1_STRFLGS_DUMP_DER;
+
+		public const int ASN1_STRFLGS_ESC_2253 = 1;
+		public const int ASN1_STRFLGS_ESC_CTRL = 2;
+		public const int ASN1_STRFLGS_ESC_MSB = 4;
+		public const int ASN1_STRFLGS_ESC_QUOTE = 8;
+		public const int ASN1_STRFLGS_UTF8_CONVERT = 0x10;
+		public const int ASN1_STRFLGS_DUMP_UNKNOWN = 0x100;
+		public const int ASN1_STRFLGS_DUMP_DER = 0x200;
+		public const int XN_FLAG_SEP_COMMA_PLUS = (1 << 16);
+		public const int XN_FLAG_FN_SN = 0;
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_NAME_new();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void X509_NAME_free(IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_NAME_dup(IntPtr xn);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_NAME_cmp(IntPtr a, IntPtr b);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_NAME_entry_count(IntPtr name);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_NAME_add_entry_by_NID(
+			IntPtr name,
+			int nid,
+			int type,
+			byte[] bytes,
+			int len,
+			int loc,
+			int set);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_NAME_add_entry_by_txt(
+			IntPtr name,
+			byte[] field,
+			int type,
+			byte[] bytes,
+			int len,
+			int loc,
+			int set);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_NAME_get_text_by_NID(IntPtr name, int nid, byte[] buf, int len);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_NAME_get_entry(IntPtr name, int loc);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_NAME_delete_entry(IntPtr name, int loc);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_NAME_get_index_by_NID(IntPtr name, int nid, int lastpos);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_NAME_digest(IntPtr data, IntPtr type, byte[] md, ref uint len);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr X509_NAME_oneline(IntPtr a, byte[] buf, int size);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_NAME_print(IntPtr bp, IntPtr name, int obase);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509_NAME_print_ex(IntPtr bp, IntPtr nm, int indent, uint flags);
+
+		#endregion
+
+		#region RAND
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RAND_set_rand_method(IntPtr meth);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr RAND_get_rand_method();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void RAND_cleanup();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void RAND_seed(byte[] buf, int len);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RAND_pseudo_bytes(byte[] buf, int len);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RAND_bytes(byte[] buf, int num);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void RAND_add(byte[] buf, int num, double entropy);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RAND_load_file(string file, int max_bytes);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RAND_write_file(string file);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static string RAND_file_name(byte[] buf, uint num);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RAND_status();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RAND_query_egd_bytes(string path, byte[] buf, int bytes);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RAND_egd(string path);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RAND_egd_bytes(string path, int bytes);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RAND_poll();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BN_rand(IntPtr rnd, int bits, int top, int bottom);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BN_pseudo_rand(IntPtr rnd, int bits, int top, int bottom);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BN_rand_range(IntPtr rnd, IntPtr range);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BN_pseudo_rand_range(IntPtr rnd, IntPtr range);
+
+		#endregion
+
+		#region DSA
+
+		//[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
+		//public extern static IntPtr DSA_generate_parameters(int bits, byte[] seed, int seed_len, IntPtr counter_ret, IntPtr h_ret, IntPtr callback, IntPtr cb_arg);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static
+		int DSA_generate_parameters_ex(IntPtr dsa,
+			int bits,
+			byte[] seed,
+			int seed_len,
+			out int counter_ret,
+			out IntPtr h_ret,
+			bn_gencb_st callback);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int DSA_generate_key(IntPtr dsa);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr DSA_new();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void DSA_free(IntPtr dsa);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int DSA_up_ref(IntPtr dsa);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int DSA_size(IntPtr dsa);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int DSAparams_print(IntPtr bp, IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int DSA_print(IntPtr bp, IntPtr x, int off);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int DSA_sign(int type, byte[] dgst, int dlen, byte[] sig, out uint siglen, IntPtr dsa);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int DSA_verify(int type, byte[] dgst, int dgst_len, byte[] sigbuf, int siglen, IntPtr dsa);
+
+		#endregion
+
+		#region RSA
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr RSA_new();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void RSA_free(IntPtr rsa);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RSA_up_ref(IntPtr rsa);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RSA_size(IntPtr rsa);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RSA_generate_key_ex(IntPtr rsa, int bits, IntPtr e, bn_gencb_st cb);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RSA_check_key(IntPtr rsa);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RSA_public_encrypt(int flen, byte[] from, byte[] to, IntPtr rsa, int padding);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RSA_private_encrypt(int flen, byte[] from, byte[] to, IntPtr rsa, int padding);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RSA_public_decrypt(int flen, byte[] from, byte[] to, IntPtr rsa, int padding);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RSA_private_decrypt(int flen, byte[] from, byte[] to, IntPtr rsa, int padding);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RSA_sign(int type, byte[] m, uint m_length, byte[] sigret, out uint siglen, IntPtr rsa);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RSA_verify(int type, byte[] m, uint m_length, byte[] sigbuf, uint siglen, IntPtr rsa);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int RSA_print(IntPtr bp, IntPtr r, int offset);
+
+		#endregion
+
+		#region DH
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr DH_generate_parameters(int prime_len, int generator, IntPtr callback, IntPtr cb_arg);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int DH_generate_parameters_ex(IntPtr dh, int prime_len, int generator, bn_gencb_st cb);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int DH_generate_key(IntPtr dh);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int DH_compute_key(byte[] key, IntPtr pub_key, IntPtr dh);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr DH_new();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void DH_free(IntPtr dh);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int DH_up_ref(IntPtr dh);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int DH_check(IntPtr dh, out int codes);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int DHparams_print(IntPtr bp, IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int DH_size(IntPtr dh);
+
+		#endregion
+
+		#region BIGNUM
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr BN_value_one();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr BN_CTX_new();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void BN_CTX_init(IntPtr c);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void BN_CTX_free(IntPtr c);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void BN_CTX_start(IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr BN_CTX_get(IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void BN_CTX_end(IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr BN_new();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void BN_free(IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void BN_init(IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr BN_bin2bn(byte[] s, int len, IntPtr ret);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BN_bn2bin(IntPtr a, byte[] to);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void BN_clear_free(IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void BN_clear(IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr BN_dup(IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr BN_copy(IntPtr a, IntPtr b);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void BN_swap(IntPtr a, IntPtr b);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BN_cmp(IntPtr a, IntPtr b);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BN_sub(IntPtr r, IntPtr a, IntPtr b);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BN_add(IntPtr r, IntPtr a, IntPtr b);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BN_mul(IntPtr r, IntPtr a, IntPtr b, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BN_num_bits(IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BN_sqr(IntPtr r, IntPtr a, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BN_div(IntPtr dv, IntPtr rem, IntPtr m, IntPtr d, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BN_print(IntPtr fp, IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr BN_bn2hex(IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr BN_bn2dec(IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BN_hex2bn(out IntPtr a, byte[] str);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BN_dec2bn(out IntPtr a, byte[] str);
+
+        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+        public extern static uint BN_mod_word(IntPtr a, uint w);
+
+
+
+
+        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+        public extern static int BN_mod(IntPtr rem, IntPtr a, IntPtr m, IntPtr ctx);
+
+        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+        public extern static int BN_nnmod(IntPtr r, IntPtr a, IntPtr m, IntPtr ctx);
+
+        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+        public extern static int BN_mod_add(IntPtr r, IntPtr a, IntPtr b, IntPtr m, IntPtr ctx);
+
+        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+        public extern static int BN_mod_sub(IntPtr r, IntPtr a, IntPtr b, IntPtr m, IntPtr ctx);
+
+        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+        public extern static int BN_mod_mul(IntPtr r, IntPtr a, IntPtr b, IntPtr m, IntPtr ctx);
+
+        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+        public extern static int BN_mod_sqr(IntPtr r, IntPtr a, IntPtr m, IntPtr ctx);
+
+        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+        public extern static int BN_mod_exp(IntPtr r, IntPtr a, IntPtr p, IntPtr m, IntPtr ctx);
+
+        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+        public extern static int BN_mod_inverse(IntPtr r, IntPtr a, IntPtr n, IntPtr ctx);
+
+        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+        public extern static int BN_exp(IntPtr r, IntPtr a, IntPtr p, IntPtr ctx);
+
+        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+        public extern static int BN_gcd(IntPtr r, IntPtr a, IntPtr b, IntPtr ctx);
+
+
+
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static uint BN_div_word(IntPtr a, uint w);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BN_mul_word(IntPtr a, uint w);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BN_add_word(IntPtr a, uint w);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BN_sub_word(IntPtr a, uint w);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BN_set_word(IntPtr a, uint w);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static uint BN_get_word(IntPtr a);
+		//#define BN_GENCB_set(gencb, callback, cb_arg) { \
+		//        BN_GENCB *tmp_gencb = (gencb); \
+		//        tmp_gencb->ver = 2; \
+		//        tmp_gencb->arg = (cb_arg); \
+		//        tmp_gencb->cb.cb_2 = (callback); }
+
+		[StructLayout(LayoutKind.Sequential)]
+		public class bn_gencb_st
+		{
+			/// To handle binary (in)compatibility 
+			public uint ver;
+			/// callback-specific data 
+			public IntPtr arg;
+			public GeneratorHandler cb;
+		}
+
+		#endregion
+
+		#region DER
+
+		//#define d2i_DHparams_bio(bp,x) ASN1_d2i_bio_of(DH,DH_new,d2i_DHparams,bp,x)
+		//#define i2d_DHparams_bio(bp,x) ASN1_i2d_bio_of_const(DH,i2d_DHparams,bp,x)
+		//
+		//#define ASN1_d2i_bio_of(type,xnew,d2i,in,x) \
+		//    ((type*)ASN1_d2i_bio( CHECKED_NEW_OF(type, xnew), \
+		//              CHECKED_D2I_OF(type, d2i), \
+		//              in, \
+		//              CHECKED_PPTR_OF(type, x)))
+		//
+		//#define ASN1_i2d_bio_of_const(type,i2d,out,x) \
+		//    (ASN1_i2d_bio(CHECKED_I2D_OF(const type, i2d), \
+		//          out, \
+		//          CHECKED_PTR_OF(const type, x)))
+		//
+		//#define CHECKED_I2D_OF(type, i2d) \
+		//    ((i2d_of_void*) (1 ? i2d : ((I2D_OF(type))0)))
+		//
+		//#define I2D_OF(type) int (*)(type *,byte[] *)
+		//
+		//#define CHECKED_PTR_OF(type, p) \
+		//    ((void*) (1 ? p : (type*)0))
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public static extern IntPtr d2i_DHparams(out IntPtr a, IntPtr pp, int length);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int i2d_DHparams(IntPtr a, IntPtr pp);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr ASN1_d2i_bio(IntPtr xnew, IntPtr d2i, IntPtr bp, IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int ASN1_i2d_bio(IntPtr i2d, IntPtr bp, IntPtr x);
+
+		#endregion
+
+		#region PEM
+
+		#region X509
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int PEM_write_bio_X509(IntPtr bp, IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr PEM_read_bio_X509(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr PEM_read_bio_PKCS7(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr d2i_PKCS7_bio(IntPtr bp, IntPtr p7);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void PKCS7_free(IntPtr p7);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr d2i_PKCS12_bio(IntPtr bp, IntPtr p12);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int i2d_PKCS12_bio(IntPtr bp, IntPtr p12);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr PKCS12_create(
+			string pass,
+			string name,
+			IntPtr pkey,
+			IntPtr cert,
+			IntPtr ca,
+			int nid_key,
+			int nid_cert,
+			int iter,
+			int mac_iter,
+			int keytype);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int PKCS12_parse(IntPtr p12, string pass, out IntPtr pkey, out IntPtr cert, out IntPtr ca);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void PKCS12_free(IntPtr p12);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int PEM_write_bio_PKCS8PrivateKey(
+			IntPtr bp,
+			IntPtr evp_pkey,
+			IntPtr evp_cipher,
+			IntPtr kstr,
+			int klen,
+			pem_password_cb cb,
+			IntPtr user_data);
+
+		#endregion
+
+		#region X509_INFO
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int PEM_write_bio_X509_INFO(IntPtr bp, IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr PEM_read_bio_X509_INFO(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
+
+		#endregion
+
+		#region X509_AUX
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int PEM_write_bio_X509_AUX(IntPtr bp, IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr PEM_read_bio_X509_AUX(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
+
+		#endregion
+
+		#region X509_REQ
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int PEM_write_bio_X509_REQ(IntPtr bp, IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr PEM_read_bio_X509_REQ(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
+
+		#endregion
+
+		#region X509_REQ_NEW
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int PEM_write_bio_X509_REQ_NEW(IntPtr bp, IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr PEM_read_bio_X509_REQ_NEW(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
+
+		#endregion
+
+		#region X509_CRL
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int PEM_write_bio_X509_CRL(IntPtr bp, IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr PEM_read_bio_X509_CRL(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
+
+		#endregion
+
+		#region X509Chain
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr PEM_X509_INFO_read_bio(IntPtr bp, IntPtr sk, pem_password_cb cb, IntPtr u);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int PEM_X509_INFO_write_bio(
+			IntPtr bp,
+			IntPtr xi,
+			IntPtr enc,
+			byte[] kstr,
+			int klen,
+			IntPtr cd,
+			IntPtr u);
+
+		#endregion
+
+		#region DSA
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int PEM_write_bio_DSAPrivateKey(
+			IntPtr bp,
+			IntPtr x,
+			IntPtr enc,
+			byte[] kstr,
+			int klen,
+			pem_password_cb cb,
+			IntPtr u);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr PEM_read_bio_DSAPrivateKey(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int PEM_write_bio_DSA_PUBKEY(IntPtr bp, IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr PEM_read_bio_DSA_PUBKEY(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
+
+		#endregion
+
+		#region DSAparams
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int PEM_write_bio_DSAparams(IntPtr bp, IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr PEM_read_bio_DSAparams(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
+
+		#endregion
+
+		#region RSA
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int PEM_write_bio_RSA_PUBKEY(IntPtr bp, IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr PEM_read_bio_RSA_PUBKEY(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int PEM_write_bio_RSAPrivateKey(
+			IntPtr bp,
+			IntPtr x,
+			IntPtr enc,
+			byte[] kstr,
+			int klen,
+			pem_password_cb cb,
+			IntPtr u);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr PEM_read_bio_RSAPrivateKey(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
+
+		#endregion
+
+		#region DHparams
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int PEM_write_bio_DHparams(IntPtr bp, IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr PEM_read_bio_DHparams(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
+
+		#endregion
+
+		#region PrivateKey
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int PEM_write_bio_PrivateKey(
+			IntPtr bp,
+			IntPtr x,
+			IntPtr enc,
+			byte[] kstr,
+			int klen,
+			pem_password_cb cb,
+			IntPtr u);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr PEM_read_bio_PrivateKey(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
+
+		#endregion
+
+		#region PUBKEY
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int PEM_write_bio_PUBKEY(IntPtr bp, IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr PEM_read_bio_PUBKEY(IntPtr bp, IntPtr x, pem_password_cb cb, IntPtr u);
+
+		#endregion
+
+		#endregion
+
+		#region EVP
+
+		#region Constants
+
+		public const int EVP_MAX_MD_SIZE = 64;
+		//!!(16+20);
+		public const int EVP_MAX_KEY_LENGTH = 32;
+		public const int EVP_MAX_IV_LENGTH = 16;
+		public const int EVP_MAX_BLOCK_LENGTH = 32;
+
+		public const int EVP_CIPH_STREAM_CIPHER = 0x0;
+		public const int EVP_CIPH_ECB_MODE = 0x1;
+		public const int EVP_CIPH_CBC_MODE = 0x2;
+		public const int EVP_CIPH_CFB_MODE = 0x3;
+		public const int EVP_CIPH_OFB_MODE = 0x4;
+		public const int EVP_CIPH_MODE = 0x7;
+		public const int EVP_CIPH_VARIABLE_LENGTH = 0x8;
+		public const int EVP_CIPH_CUSTOM_IV = 0x10;
+		public const int EVP_CIPH_ALWAYS_CALL_INIT = 0x20;
+		public const int EVP_CIPH_CTRL_INIT = 0x40;
+		public const int EVP_CIPH_CUSTOM_KEY_LENGTH = 0x80;
+		public const int EVP_CIPH_NO_PADDING = 0x100;
+		public const int EVP_CIPH_FLAG_FIPS = 0x400;
+		public const int EVP_CIPH_FLAG_NON_FIPS_ALLOW = 0x800;
+
+		#endregion
+
+		#region Message Digests
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_md_null();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_md2();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_md4();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_md5();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_sha();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_sha1();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_sha224();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_sha256();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_sha384();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_sha512();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_dss();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_dss1();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_mdc2();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_ripemd160();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_ecdsa();
+
+		#endregion
+
+		#region HMAC
+
+		public const int HMAC_MAX_MD_CBLOCK = 128;
+
+		//!!void HMAC_CTX_init(HMAC_CTX *ctx);
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void HMAC_CTX_init(IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void HMAC_CTX_set_flags(IntPtr ctx, uint flags);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void HMAC_CTX_cleanup(IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void HMAC_Init(IntPtr ctx, byte[] key, int len, IntPtr md);
+		/* deprecated */
+		
+		//!!public extern static void HMAC_Init_ex(IntPtr ctx, const void *key, int len, const EVP_MD *md, ENGINE *impl);
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void HMAC_Init_ex(IntPtr ctx, byte[] key, int len, IntPtr md, IntPtr engine_impl);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void HMAC_Update(IntPtr ctx, byte[] data, int len);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void HMAC_Final(IntPtr ctx, byte[] md, ref uint len);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr HMAC(IntPtr evp_md, byte[] key, int key_len, byte[] d, int n, byte[] md, ref uint md_len);
+
+		#endregion
+
+		#region Ciphers
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_get_cipherbyname(byte[] name);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_enc_null();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_des_ecb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_des_ede();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_des_ede3();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_des_ede_ecb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_des_ede3_ecb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_des_cfb64();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_des_cfb1();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_des_cfb8();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_des_ede_cfb64();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_des_ede3_cfb64();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_des_ede3_cfb1();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_des_ede3_cfb8();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_des_ofb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_des_ede_ofb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_des_ede3_ofb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_des_cbc();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_des_ede_cbc();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_des_ede3_cbc();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_desx_cbc();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_rc4();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_rc4_40();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_idea_ecb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_idea_cfb64();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_idea_ofb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_idea_cbc();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_rc2_ecb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_rc2_cbc();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_rc2_40_cbc();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_rc2_64_cbc();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_rc2_cfb64();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_rc2_ofb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_bf_ecb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_bf_cbc();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_bf_cfb64();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_bf_ofb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_cast5_ecb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_cast5_cbc();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_cast5_cfb64();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_cast5_ofb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_rc5_32_12_16_cbc();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_rc5_32_12_16_ecb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_rc5_32_12_16_cfb64();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_rc5_32_12_16_ofb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_aes_128_ecb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_aes_128_cbc();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_aes_128_cfb1();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_aes_128_cfb8();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_aes_128_cfb128();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_aes_128_ofb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_aes_192_ecb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_aes_192_cbc();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_aes_192_cfb1();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_aes_192_cfb8();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_aes_192_cfb128();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_aes_192_ofb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_aes_256_ecb();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_aes_256_cbc();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_aes_256_cfb1();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_aes_256_cfb8();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_aes_256_cfb128();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_aes_256_ofb();
+
+		#endregion
+
+		#region EVP_PKEY
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_PKEY_new();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void EVP_PKEY_free(IntPtr pkey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_PKEY_cmp(IntPtr a, IntPtr b);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_PKEY_decrypt(byte[] dec_key, byte[] enc_key, int enc_key_len, IntPtr private_key);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_PKEY_encrypt(byte[] enc_key, byte[] key, int key_len, IntPtr pub_key);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_PKEY_encrypt_old(byte[] enc_key, byte[] key, int key_len, IntPtr pub_key);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_PKEY_type(int type);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_PKEY_bits(IntPtr pkey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_PKEY_size(IntPtr pkey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_PKEY_assign(IntPtr pkey, int type, IntPtr key);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_PKEY_set1_DSA(IntPtr pkey, IntPtr key);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_PKEY_get1_DSA(IntPtr pkey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_PKEY_set1_RSA(IntPtr pkey, IntPtr key);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_PKEY_get1_RSA(IntPtr pkey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_PKEY_set1_EC_KEY(IntPtr pkey, IntPtr key);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_PKEY_get1_EC_KEY(IntPtr pkey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_PKEY_set1_DH(IntPtr pkey, IntPtr key);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_PKEY_get1_DH(IntPtr pkey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_PKEY_copy_parameters(IntPtr to, IntPtr from);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_PKEY_missing_parameters(IntPtr pkey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_PKEY_save_parameters(IntPtr pkey, int mode);
+
+        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+        public extern static int EVP_PKEY_cmp_parameters(IntPtr a, IntPtr b);
+
+        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+        public extern static int EVP_PKEY_derive_init(IntPtr ctx);
+
+        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+        public extern static int EVP_PKEY_derive_set_peer(IntPtr ctx, IntPtr peer);
+
+        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+        public extern static int EVP_PKEY_derive(IntPtr ctx, IntPtr key, IntPtr keylen);
+
+        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+        public extern static IntPtr EVP_PKEY_CTX_new(IntPtr pkey, IntPtr engine);
+
+        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+        public extern static void EVP_PKEY_CTX_free(IntPtr ctx);
+        
+        
+        #endregion
+
+		#region EVP_CIPHER
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void EVP_CIPHER_CTX_init(IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_CIPHER_CTX_rand_key(IntPtr ctx, byte[] key);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_CIPHER_CTX_set_padding(IntPtr x, int padding);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_CIPHER_CTX_set_key_length(IntPtr x, int keylen);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_CIPHER_CTX_ctrl(IntPtr ctx, int type, int arg, IntPtr ptr);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_CIPHER_CTX_cleanup(IntPtr a);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_CIPHER_type(IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_CipherInit_ex(IntPtr ctx, IntPtr type, IntPtr impl, byte[] key, byte[] iv, int enc);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_CipherUpdate(IntPtr ctx, byte[] outb, out int outl, byte[] inb, int inl);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_CipherFinal_ex(IntPtr ctx, byte[] outm, ref int outl);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_OpenInit(IntPtr ctx, IntPtr type, byte[] ek, int ekl, byte[] iv, IntPtr priv);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_OpenFinal(IntPtr ctx, byte[] outb, out int outl);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_SealInit(
+			IntPtr ctx,
+			IntPtr type,
+			IntPtr[] ek,
+			int[] ekl,
+			byte[] iv,
+			IntPtr[] pubk,
+			int npubk);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_SealFinal(IntPtr ctx, byte[] outb, out int outl);
+
+        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+        public extern static int EVP_DecryptInit_ex(IntPtr ctx, IntPtr type, IntPtr impl, byte[] key, byte[] iv);
+
+        [DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_DecryptUpdate(IntPtr ctx, byte[] output, out int outl, byte[] input, int inl);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_EncryptInit_ex(IntPtr ctx, IntPtr cipher, IntPtr impl, byte[] key, byte[] iv);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_EncryptUpdate(IntPtr ctx, byte[] output, out int outl, byte[] input, int inl);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_BytesToKey(
+			IntPtr type,
+			IntPtr md,
+			byte[] salt,
+			byte[] data,
+			int datal,
+			int count,
+			byte[] key,
+			byte[] iv);
+
+		#endregion
+
+		#region EVP_MD
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_MD_type(IntPtr md);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_MD_pkey_type(IntPtr md);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_MD_size(IntPtr md);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_MD_block_size(IntPtr md);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static uint EVP_MD_flags(IntPtr md);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_get_digestbyname(byte[] name);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void EVP_MD_CTX_init(IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_MD_CTX_cleanup(IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EVP_MD_CTX_create();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void EVP_MD_CTX_destroy(IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_DigestInit_ex(IntPtr ctx, IntPtr type, IntPtr impl);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_DigestUpdate(IntPtr ctx, byte[] d, uint cnt);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_DigestFinal_ex(IntPtr ctx, byte[] md, ref uint s);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_Digest(byte[] data, uint count, byte[] md, ref uint size, IntPtr type, IntPtr impl);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_SignFinal(IntPtr ctx, byte[] md, ref uint s, IntPtr pkey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EVP_VerifyFinal(IntPtr ctx, byte[] sigbuf, uint siglen, IntPtr pkey);
+
+		#endregion
+
+		#endregion
+
+		#region EC
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_get_builtin_curves(IntPtr r, int nitems);
+
+		#region EC_METHOD
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_GFp_simple_method();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_GFp_mont_method();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_GFp_nist_method();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_GF2m_simple_method();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_METHOD_get_field_type(IntPtr meth);
+
+		#endregion
+
+		#region EC_GROUP
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_GROUP_new(IntPtr meth);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void EC_GROUP_free(IntPtr group);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void EC_GROUP_clear_free(IntPtr group);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_GROUP_copy(IntPtr dst, IntPtr src);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_GROUP_dup(IntPtr src);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_GROUP_method_of(IntPtr group);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_GROUP_set_generator(IntPtr group, IntPtr generator, IntPtr order, IntPtr cofactor);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_GROUP_get0_generator(IntPtr group);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_GROUP_get_order(IntPtr group, IntPtr order, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_GROUP_get_cofactor(IntPtr group, IntPtr cofactor, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void EC_GROUP_set_curve_name(IntPtr group, int nid);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_GROUP_get_curve_name(IntPtr group);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void EC_GROUP_set_asn1_flag(IntPtr group, int flag);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_GROUP_get_asn1_flag(IntPtr group);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void EC_GROUP_set_point_conversion_form(IntPtr x, int y);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_GROUP_get_point_conversion_form(IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static byte[] EC_GROUP_get0_seed(IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_GROUP_get_seed_len(IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_GROUP_set_seed(IntPtr x, byte[] buf, int len);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_GROUP_set_curve_GFp(IntPtr group, IntPtr p, IntPtr a, IntPtr b, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_GROUP_get_curve_GFp(IntPtr group, IntPtr p, IntPtr a, IntPtr b, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_GROUP_set_curve_GF2m(IntPtr group, IntPtr p, IntPtr a, IntPtr b, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_GROUP_get_curve_GF2m(IntPtr group, IntPtr p, IntPtr a, IntPtr b, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_GROUP_get_degree(IntPtr group);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_GROUP_check(IntPtr group, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_GROUP_check_discriminant(IntPtr group, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_GROUP_cmp(IntPtr a, IntPtr b, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_GROUP_new_curve_GFp(IntPtr p, IntPtr a, IntPtr b, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_GROUP_new_curve_GF2m(IntPtr p, IntPtr a, IntPtr b, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_GROUP_new_by_curve_name(int nid);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_GROUP_precompute_mult(IntPtr group, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_GROUP_have_precompute_mult(IntPtr group);
+
+		#endregion
+
+		#region EC_POINT
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_POINT_new(IntPtr group);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void EC_POINT_free(IntPtr point);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void EC_POINT_clear_free(IntPtr point);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINT_copy(IntPtr dst, IntPtr src);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_POINT_dup(IntPtr src, IntPtr group);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_POINT_method_of(IntPtr point);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINT_set_to_infinity(IntPtr group, IntPtr point);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINT_set_Jprojective_coordinates_GFp(
+			IntPtr group,
+			IntPtr p,
+			IntPtr x,
+			IntPtr y,
+			IntPtr z,
+			IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINT_get_Jprojective_coordinates_GFp(
+			IntPtr group,
+			IntPtr p,
+			IntPtr x,
+			IntPtr y,
+			IntPtr z,
+			IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINT_set_affine_coordinates_GFp(IntPtr group, IntPtr p, IntPtr x, IntPtr y, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINT_get_affine_coordinates_GFp(IntPtr group, IntPtr p, IntPtr x, IntPtr y, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINT_set_compressed_coordinates_GFp(
+			IntPtr group,
+			IntPtr p,
+			IntPtr x,
+			int y_bit,
+			IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINT_set_affine_coordinates_GF2m(IntPtr group, IntPtr p, IntPtr x, IntPtr y, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINT_get_affine_coordinates_GF2m(IntPtr group, IntPtr p, IntPtr x, IntPtr y, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINT_set_compressed_coordinates_GF2m(
+			IntPtr group,
+			IntPtr p,
+			IntPtr x,
+			int y_bit,
+			IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINT_point2oct(IntPtr group, IntPtr p, int form, byte[] buf, int len, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINT_oct2point(IntPtr group, IntPtr p, byte[] buf, int len, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_POINT_point2bn(IntPtr a, IntPtr b, int form, IntPtr c, IntPtr d);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_POINT_bn2point(IntPtr a, IntPtr b, IntPtr c, IntPtr d);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static string EC_POINT_point2hex(IntPtr a, IntPtr b, int form, IntPtr c);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_POINT_hex2point(IntPtr a, string s, IntPtr b, IntPtr c);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINT_add(IntPtr group, IntPtr r, IntPtr a, IntPtr b, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINT_dbl(IntPtr group, IntPtr r, IntPtr a, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINT_invert(IntPtr group, IntPtr a, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINT_is_at_infinity(IntPtr group, IntPtr p);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINT_is_on_curve(IntPtr group, IntPtr point, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINT_cmp(IntPtr group, IntPtr a, IntPtr b, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINT_make_affine(IntPtr a, IntPtr b, IntPtr c);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINTs_make_affine(IntPtr a, int num, IntPtr[] b, IntPtr c);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINTs_mul(IntPtr group, IntPtr r, IntPtr n, int num, IntPtr[] p, IntPtr[] m, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_POINT_mul(IntPtr group, IntPtr r, IntPtr n, IntPtr q, IntPtr m, IntPtr ctx);
+
+		#endregion
+
+		#region EC_KEY
+
+		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
+		public delegate IntPtr EC_KEY_dup_func(IntPtr x);
+
+		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
+		public delegate void EC_KEY_free_func(IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_KEY_new();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_KEY_new_by_curve_name(int nid);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void EC_KEY_free(IntPtr key);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_KEY_copy(IntPtr dst, IntPtr src);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_KEY_dup(IntPtr src);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_KEY_up_ref(IntPtr key);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_KEY_get0_group(IntPtr key);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_KEY_set_group(IntPtr key, IntPtr group);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_KEY_get0_private_key(IntPtr key);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_KEY_set_private_key(IntPtr key, IntPtr prv);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_KEY_get0_public_key(IntPtr key);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_KEY_set_public_key(IntPtr key, IntPtr pub);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static uint EC_KEY_get_enc_flags(IntPtr key);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void EC_KEY_set_enc_flags(IntPtr x, uint y);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_KEY_get_conv_form(IntPtr x);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void EC_KEY_set_conv_form(IntPtr x, int y);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr EC_KEY_get_key_method_data(
+			IntPtr x,
+			EC_KEY_dup_func dup_func,
+			EC_KEY_free_func free_func,
+			EC_KEY_free_func clear_free_func);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void EC_KEY_insert_key_method_data(
+			IntPtr x,
+			IntPtr data,
+			EC_KEY_dup_func dup_func,
+			EC_KEY_free_func free_func,
+			EC_KEY_free_func clear_free_func);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void EC_KEY_set_asn1_flag(IntPtr x, int y);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_KEY_precompute_mult(IntPtr key, IntPtr ctx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_KEY_generate_key(IntPtr key);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int EC_KEY_check_key(IntPtr key);
+
+		#endregion
+
+		#region ECDSA
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr ECDSA_SIG_new();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void ECDSA_SIG_free(IntPtr sig);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int i2d_ECDSA_SIG(IntPtr sig, byte[] pp);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr d2i_ECDSA_SIG(IntPtr sig, byte[] pp, long len);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr ECDSA_do_sign(byte[] dgst, int dgst_len, IntPtr eckey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr ECDSA_do_sign_ex(byte[] dgst, int dgstlen, IntPtr kinv, IntPtr rp, IntPtr eckey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int ECDSA_do_verify(byte[] dgst, int dgst_len, IntPtr sig, IntPtr eckey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr ECDSA_OpenSSL();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void ECDSA_set_default_method(IntPtr meth);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr ECDSA_get_default_method();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int ECDSA_set_method(IntPtr eckey, IntPtr meth);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int ECDSA_size(IntPtr eckey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int ECDSA_sign_setup(IntPtr eckey, IntPtr ctx, IntPtr kinv, IntPtr rp);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int ECDSA_sign(int type, byte[] dgst, int dgstlen, byte[] sig, ref uint siglen, IntPtr eckey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int ECDSA_sign_ex(
+			int type,
+			byte[] dgst,
+			int dgstlen,
+			byte[] sig,
+			ref uint siglen,
+			IntPtr kinv,
+			IntPtr rp,
+			IntPtr eckey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int ECDSA_verify(int type, byte[] dgst, int dgstlen, byte[] sig, int siglen, IntPtr eckey);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int ECDSA_get_ex_new_index(
+			IntPtr argl,
+			IntPtr argp,
+			IntPtr new_func,
+			IntPtr dup_func,
+			IntPtr free_func);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int ECDSA_set_ex_data(IntPtr d, int idx, IntPtr arg);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr ECDSA_get_ex_data(IntPtr d, int idx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void ERR_load_ECDSA_strings();
+
+		#endregion
+
+		#region ECDH
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr ECDH_OpenSSL();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void ECDH_set_default_method(IntPtr method);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr ECDH_get_default_method();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int ECDH_set_method(IntPtr key, IntPtr method);
+
+		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
+		public delegate IntPtr ECDH_KDF([MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] byte[] pin,
+		                                int inlen,
+		                                IntPtr pout, 
+		                                ref int outlen);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int ECDH_compute_key(byte[] pout, int outlen, IntPtr pub_key, IntPtr ecdh, ECDH_KDF kdf);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int ECDH_get_ex_new_index(
+			IntPtr argl,
+			IntPtr argp,
+			IntPtr new_func,
+			IntPtr dup_func,
+			IntPtr free_func);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int ECDH_set_ex_data(IntPtr d, int idx, IntPtr arg);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr ECDH_get_ex_data(IntPtr d, int idx);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void ERR_load_ECDH_strings();
+
+		#endregion
+
+		#endregion
+
+		#region BIO
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		//!!public extern static IntPtr BIO_new_file(byte[] filename, byte[] mode);
+		public extern static IntPtr BIO_new_file(string filename, string mode);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr BIO_new_mem_buf(byte[] buf, int len);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr BIO_s_mem();
+
+		// Unsupported!
+		//[DllImport(DLLNAME, CallingConvention=CallingConvention.Cdecl)]
+		//public extern static IntPtr BIO_s_fd();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr BIO_f_md();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr BIO_f_null();
+
+		const int BIO_C_SET_FD = 104;
+		const int BIO_C_SET_MD = 111;
+		const int BIO_C_GET_MD = 112;
+		const int BIO_C_GET_MD_CTX = 120;
+		const int BIO_C_SET_MD_CTX = 148;
+
+		public const int BIO_NOCLOSE = 0x00;
+		public const int BIO_CLOSE = 0x01;
+
+		public static void BIO_set_md(IntPtr bp, IntPtr md)
+		{
+			Native.ExpectSuccess(BIO_ctrl(bp, BIO_C_SET_MD, 0, md));
+		}
+
+		// Unsupported!
+		//public static void BIO_set_fd(IntPtr bp, int fd, int c)
+		//{
+		//    Native.ExpectSuccess(BIO_int_ctrl(bp, BIO_C_SET_FD, c, fd));
+		//}
+
+		public static IntPtr BIO_get_md(IntPtr bp)
+		{
+			var ptr = Marshal.AllocHGlobal(4);
+			
+			try
+			{
+				ExpectSuccess(BIO_ctrl(bp, BIO_C_GET_MD, 0, ptr));
+				return Marshal.ReadIntPtr(ptr);
+			}
+			finally
+			{
+				Marshal.FreeHGlobal(ptr);
+			}
+		}
+
+		public static IntPtr BIO_get_md_ctx(IntPtr bp)
+		{
+			var ptr = Marshal.AllocHGlobal(4);
+			
+			try
+			{
+				ExpectSuccess(BIO_ctrl(bp, BIO_C_GET_MD_CTX, 0, ptr));
+				return Marshal.ReadIntPtr(ptr);
+			}
+			finally
+			{
+				Marshal.FreeHGlobal(ptr);
+			}
+		}
+
+		public static void BIO_set_md_ctx(IntPtr bp, IntPtr mdcp)
+		{
+			Native.ExpectSuccess(BIO_ctrl(bp, BIO_C_SET_MD_CTX, 0, mdcp));
+		}
+
+		/* man - set the 'close' on free */
+		const int BIO_CTRL_SET_CLOSE = 9;
+
+		//#define BIO_set_close(b,c)	(int)BIO_ctrl(b,BIO_CTRL_SET_CLOSE,(c),NULL)
+		public static int BIO_set_close(IntPtr bp, int arg)
+		{
+			return BIO_ctrl(bp, BIO_CTRL_SET_CLOSE, arg, IntPtr.Zero);
+		}
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr BIO_push(IntPtr bp, IntPtr append);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BIO_ctrl(IntPtr bp, int cmd, int larg, IntPtr parg);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BIO_int_ctrl(IntPtr bp, int cmd, int larg, int parg);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr BIO_new(IntPtr type);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BIO_read(IntPtr b, byte[] buf, int len);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BIO_write(IntPtr b, byte[] buf, int len);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BIO_puts(IntPtr b, byte[] buf);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int BIO_gets(IntPtr b, byte[] buf, int len);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void BIO_free(IntPtr bio);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static uint BIO_number_read(IntPtr bio);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static uint BIO_number_written(IntPtr bio);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static uint BIO_ctrl_pending(IntPtr bio);
+
+		#endregion
+
+		#region ERR
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void ERR_load_crypto_strings();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static uint ERR_get_error();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void ERR_error_string_n(uint e, byte[] buf, int len);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr ERR_lib_error_string(uint e);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr ERR_func_error_string(uint e);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr ERR_reason_error_string(uint e);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void ERR_remove_thread_state(IntPtr tid);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void ERR_clear_error();
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void ERR_print_errors_cb(err_cb cb, IntPtr u);
+
+		#endregion
+
+		#region NCONF
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr NCONF_new(IntPtr meth);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void NCONF_free(IntPtr conf);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		//!!public extern static int NCONF_load(IntPtr conf, byte[] file, ref int eline);
+		public extern static int NCONF_load(IntPtr conf, string file, ref int eline);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr NCONF_get_string(IntPtr conf, byte[] group, byte[] name);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void X509V3_set_ctx(
+			IntPtr ctx,
+			IntPtr issuer,
+			IntPtr subject,
+			IntPtr req,
+			IntPtr crl,
+			int flags);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void X509V3_set_nconf(IntPtr ctx, IntPtr conf);
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int X509V3_EXT_add_nconf(IntPtr conf, IntPtr ctx, byte[] section, IntPtr cert);
+
+		#endregion
+
+		#region FIPS
+
+		[DllImport(DLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int FIPS_mode_set(int onoff);
+
+		#endregion
+
+		#region SSL Routines
+
+		#region Initialization
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void SSL_load_error_strings();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_library_init();
+
+		#endregion
+
+		#region SSL Methods
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSLv2_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSLv2_server_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSLv2_client_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSLv3_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSLv3_server_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSLv3_client_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSLv23_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSLv23_server_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSLv23_client_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr TLSv1_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr TLSv1_client_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr TLSv1_server_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr TLSv1_1_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr TLSv1_1_server_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr TLSv1_1_client_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr TLSv1_2_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr TLSv1_2_server_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr TLSv1_2_client_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr DTLSv1_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr DTLSv1_client_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr DTLSv1_server_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr DTLSv1_2_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr DTLSv1_2_client_method();
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr DTLSv1_2_server_method();
+
+
+		#endregion
+
+		#region SSL_CTX
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSL_CTX_new(IntPtr sslMethod);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void SSL_CTX_free(IntPtr ctx);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_CTX_ctrl(IntPtr ctx, int cmd, int arg, IntPtr parg);
+
+		public const int SSL_CTRL_OPTIONS = 32;
+		public const int SSL_CTRL_MODE = 33;
+
+		public const int SSL_OP_MICROSOFT_SESS_ID_BUG = 0x00000001;
+		public const int SSL_OP_NETSCAPE_CHALLENGE_BUG = 0x00000002;
+		public const int SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = 0x00000008;
+		public const int SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG = 0x00000010;
+		public const int SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER = 0x00000020;
+		/* no effect since 0.9.7h and 0.9.8b */
+		public const int SSL_OP_MSIE_SSLV2_RSA_PADDING = 0x00000040;
+		public const int SSL_OP_SSLEAY_080_CLIENT_DH_BUG = 0x00000080;
+		public const int SSL_OP_TLS_D5_BUG = 0x00000100;
+		public const int SSL_OP_TLS_BLOCK_PADDING_BUG = 0x00000200;
+
+		/* Disable SSL 3.0/TLS 1.0 CBC vulnerability workaround that was added
+		 * in OpenSSL 0.9.6d.  Usually (depending on the application protocol)
+		 * the workaround is not needed.  Unfortunately some broken SSL/TLS
+		 * implementations cannot handle it at all, which is why we include
+		 * it in SSL_OP_ALL. */
+		/* added in 0.9.6e */
+		public const int SSL_OP_DONT_INSERT_EMPTY_FRAGMENTS = 0x00000800;
+
+		/* SSL_OP_ALL: various bug workarounds that should be rather harmless.
+		 *             This used to be 0x000FFFFFL before 0.9.7. */
+		public const int SSL_OP_ALL = (0x00000FFF ^ SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG);
+
+		/* As server, disallow session resumption on renegotiation */
+		public const int SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION = 0x00010000;
+		/* If set, always create a new key when using tmp_dh parameters */
+		public const int SSL_OP_SINGLE_DH_USE = 0x00100000;
+		/* Set to always use the tmp_rsa key when doing RSA operations,
+		 * even when this violates protocol specs */
+		public const int SSL_OP_EPHEMERAL_RSA = 0x00200000;
+		/* Set on servers to choose the cipher according to the server's
+		 * preferences */
+		public const int SSL_OP_CIPHER_SERVER_PREFERENCE = 0x00400000;
+		/* If set, a server will allow a client to issue a SSLv3.0 version number
+		 * as latest version supported in the premaster secret, even when TLSv1.0
+		 * (version 3.1) was announced in the client hello. Normally this is
+		 * forbidden to prevent version rollback attacks. */
+		public const int SSL_OP_TLS_ROLLBACK_BUG = 0x00800000;
+
+		public const int SSL_OP_NO_SSLv2 = 0x01000000;
+		public const int SSL_OP_NO_SSLv3 = 0x02000000;
+		public const int SSL_OP_NO_TLSv1 = 0x04000000;
+
+		/* The next flag deliberately changes the ciphertest, this is a check
+		 * for the PKCS#1 attack */
+		public const int SSL_OP_PKCS1_CHECK_1 = 0x08000000;
+		public const int SSL_OP_PKCS1_CHECK_2 = 0x10000000;
+		public const int SSL_OP_NETSCAPE_CA_DN_BUG = 0x20000000;
+		public const int SSL_OP_NETSCAPE_DEMO_CIPHER_CHANGE_BUG = 0x40000000;
+
+
+		/* Allow SSL_write(..., n) to return r with 0 < r < n (i.e. report success
+		 * when just a single record has been written): */
+		public const int SSL_MODE_ENABLE_PARTIAL_WRITE = 0x00000001;
+		/* Make it possible to retry SSL_write() with changed buffer location
+		 * (buffer contents must stay the same!); this is not the default to avoid
+		 * the misconception that non-blocking SSL_write() behaves like
+		 * non-blocking write(): */
+		public const int SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER = 0x00000002;
+		/* Never bother the application with retries if the transport
+		 * is blocking: */
+		public const int SSL_MODE_AUTO_RETRY = 0x00000004;
+		/* Don't attempt to automatically build certificate chain */
+		public const int SSL_MODE_NO_AUTO_CHAIN = 0x00000008;
+
+		/// <summary>
+		/// #define SSL_CTX_ctrl in ssl.h - calls SSL_CTX_ctrl()
+		/// </summary>
+		/// <param name="ctx"></param>
+		/// <param name="op"></param>
+		/// <returns></returns>
+		public static int SSL_CTX_set_mode(IntPtr ctx, int op)
+		{
+			return SSL_CTX_ctrl(ctx, SSL_CTRL_MODE, op, IntPtr.Zero);
+		}
+
+		/// <summary>
+		/// #define SSL_CTX_get_mode in ssl.h - calls SSL_CTX_ctrl
+		/// </summary>
+		/// <param name="ctx"></param>
+		/// <returns></returns>
+		public static int SSL_CTX_get_mode(IntPtr ctx)
+		{
+			return SSL_CTX_ctrl(ctx, SSL_CTRL_MODE, 0, IntPtr.Zero);
+		}
+
+		/// <summary>
+		/// #define SSL_CTX_set_options in ssl.h - calls SSL_CTX_ctrl
+		/// </summary>
+		/// <param name="ctx"></param>
+		/// <param name="op"></param>
+		/// <returns></returns>
+		public static int SSL_CTX_set_options(IntPtr ctx, int op)
+		{
+			return SSL_CTX_ctrl(ctx, SSL_CTRL_OPTIONS, op, IntPtr.Zero);
+		}
+
+		/// <summary>
+		/// #define SSL_CTX_get_options in ssl.h - calls SSL_CTX_ctrl
+		/// </summary>
+		/// <param name="ctx"></param>
+		/// <returns>Int32 representation of options set in the context</returns>
+		public static int SSL_CTX_get_options(IntPtr ctx)
+		{
+			return SSL_CTX_ctrl(ctx, SSL_CTRL_OPTIONS, 0, IntPtr.Zero);
+		}
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void SSL_CTX_set_cert_store(IntPtr ctx, IntPtr cert_store);
+
+		public const int SSL_VERIFY_NONE = 0x00;
+		public const int SSL_VERIFY_PEER = 0x01;
+		public const int SSL_VERIFY_FAIL_IF_NO_PEER_CERT = 0x02;
+		public const int SSL_VERIFY_CLIENT_ONCE = 0x04;
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void SSL_CTX_set_verify(IntPtr ctx, int mode, VerifyCertCallback callback);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void SSL_CTX_set_verify_depth(IntPtr ctx, int depth);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void SSL_CTX_set_client_CA_list(IntPtr ctx, IntPtr name_list);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSL_CTX_get_client_CA_list(IntPtr ctx);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_CTX_load_verify_locations(IntPtr ctx, string file, string path);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_CTX_set_default_verify_paths(IntPtr ctx);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_CTX_set_cipher_list(IntPtr ctx, string cipher_string);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_CTX_use_certificate_chain_file(IntPtr ctx, string file);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_CTX_use_certificate(IntPtr ctx, IntPtr cert);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_CTX_use_PrivateKey(IntPtr ctx, IntPtr pkey);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_CTX_use_PrivateKey_file(IntPtr ctx, string file, int type);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_CTX_check_private_key(IntPtr ctx);
+
+		public const int SSL_MAX_SID_CTX_LENGTH = 32;
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_CTX_set_session_id_context(IntPtr ctx, byte[] sid_ctx, uint sid_ctx_len);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void SSL_CTX_set_default_passwd_cb_userdata(IntPtr ssl, IntPtr data);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void SSL_CTX_set_default_passwd_cb(IntPtr ssl, pem_password_cb callback);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void SSL_CTX_set_client_cert_cb(IntPtr ssl_ctx, client_cert_cb callback);
+
+		#endregion
+
+		#region SSL functions
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static string SSL_CIPHER_description(IntPtr ssl_cipher, byte[] buf, int buf_len);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSL_CIPHER_get_name(IntPtr ssl_cipher);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_CIPHER_get_bits(IntPtr ssl_cipher, out int alg_bits);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSL_CIPHER_get_version(IntPtr ssl_cipher);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSL_get_current_cipher(IntPtr ssl);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSL_get_ciphers(IntPtr ssl);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_get_verify_result(IntPtr ssl);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_set_verify_result(IntPtr ssl, int v);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSL_get_peer_certificate(IntPtr ssl);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_get_error(IntPtr ssl, int ret_code);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_accept(IntPtr ssl);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_shutdown(IntPtr ssl);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_write(IntPtr ssl, byte[] buf, int len);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_read(IntPtr ssl, byte[] buf, int len);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_renegotiate(IntPtr ssl);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_set_session_id_context(IntPtr ssl, byte[] sid_ctx, uint sid_ctx_len);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_do_handshake(IntPtr ssl);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void SSL_set_connect_state(IntPtr ssl);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void SSL_set_accept_state(IntPtr ssl);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_connect(IntPtr ssl);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSL_new(IntPtr ctx);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void SSL_free(IntPtr ssl);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_state(IntPtr ssl);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void SSL_set_state(IntPtr ssl, int state);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void SSL_set_bio(IntPtr ssl, IntPtr read_bio, IntPtr write_bio);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_use_certificate_file(IntPtr ssl, string file, int type);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_use_PrivateKey_file(IntPtr ssl, string file, int type);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_clear(IntPtr ssl);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSL_load_client_CA_file(string file);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSL_get_client_CA_list(IntPtr ssl);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static void SSL_set_client_CA_list(IntPtr ssl, IntPtr name_list);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static IntPtr SSL_get_certificate(IntPtr ssl);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_use_certificate(IntPtr ssl, IntPtr x509);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public extern static int SSL_use_PrivateKey(IntPtr ssl, IntPtr evp_pkey);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public static extern int SSL_ctrl(IntPtr ssl, int cmd, int larg, IntPtr parg);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public static extern IntPtr SSL_get_servername(IntPtr s, int type);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public static extern int SSL_get_servername_type(IntPtr s);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public static extern IntPtr SSL_get_session(IntPtr s);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public static extern int SSL_CTX_callback_ctrl(IntPtr ctx, int cmd, IntPtr cb);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public static extern int SSL_CTX_set_alpn_protos(IntPtr ctx, byte[] protos, UInt32 protos_len);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public static extern void SSL_get0_alpn_selected(IntPtr ssl, out IntPtr data, out int len);
+
+		[DllImport(SSLDLLNAME, CallingConvention = CallingConvention.Cdecl)]
+		public static extern void SSL_CTX_set_alpn_select_cb(IntPtr ctx, alpn_cb alpnCb, IntPtr arg);
+
+		#endregion
+
+		#endregion
+
+		#region Utilities
+
+		public static string StaticString(IntPtr ptr)
+		{
+			return Marshal.PtrToStringAnsi(ptr);
+		}
+
+		public static string PtrToStringAnsi(IntPtr ptr, bool hasOwnership)
+		{
+			var len = 0;
+			for (var i = 0; i < 1024; i++, len++)
+			{
+				var octet = Marshal.ReadByte(ptr, i);
+				if (octet == 0)
+					break;
+			}
+
+			if (len == 1024)
+				return "Invalid string";
+
+			var buf = new byte[len];
+			Marshal.Copy(ptr, buf, 0, len);
+			if (hasOwnership)
+				Native.OPENSSL_free(ptr);
+			
+			return Encoding.ASCII.GetString(buf, 0, len);
+		}
+
+		public static IntPtr ExpectNonNull(IntPtr ptr)
+		{
+			if (ptr == IntPtr.Zero)
+				throw new OpenSslException();
+
+			return ptr;
+		}
+
+		public static int ExpectSuccess(int ret)
+		{
+			if (ret <= 0)
+				throw new OpenSslException();
+
+			return ret;
+		}
+
+		public static int TextToNID(string text)
+		{
+			var nid = Native.OBJ_txt2nid(text);
+
+			if (nid == Native.NID_undef)
+				throw new OpenSslException();
+
+			return nid;
+		}
+
+		#endregion
+	}
+
+	class NameCollector
+	{
+		[StructLayout(LayoutKind.Sequential)]
+		struct OBJ_NAME
+		{
+			public int type;
+			public int alias;
+			public IntPtr name;
+			public IntPtr data;
+		};
+
+		private List<string> list = new List<string>();
+
+		public List<string> Result { get { return list; } }
+
+		public NameCollector(int type, bool isSorted)
+		{
+			if (isSorted)
+				Native.OBJ_NAME_do_all_sorted(type, OnObjectName, IntPtr.Zero);
+			else
+				Native.OBJ_NAME_do_all(type, OnObjectName, IntPtr.Zero);
+		}
+
+		private void OnObjectName(IntPtr ptr, IntPtr arg)
+		{
+			var name = (OBJ_NAME)Marshal.PtrToStructure(ptr, typeof(OBJ_NAME));
+			var str = Native.PtrToStringAnsi(name.name, false);
+			list.Add(str);
+		}
+	}
+}
Index: ManagedOpenSsl/Core/Objects.cs
===================================================================
--- ManagedOpenSsl/Core/Objects.cs	(revision 47839)
+++ ManagedOpenSsl/Core/Objects.cs	(revision 47851)
@@ -1,68 +1,155 @@
-// Copyright (c) 2012 Frank Laub
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
-namespace OpenSSL.Core
-{
-	public class Objects
-	{
-		public class NID
-		{
-			public static Asn1Object undef = new Asn1Object(0);
-			public static Asn1Object X9_62_prime_field = new Asn1Object(406);
-			public static Asn1Object X9_62_prime192v1 = new Asn1Object(409);
-			public static Asn1Object X9_62_prime192v2 = new Asn1Object(410);
-			public static Asn1Object X9_62_prime192v3 = new Asn1Object(411);
-			public static Asn1Object X9_62_prime239v1 = new Asn1Object(412);
-			public static Asn1Object X9_62_prime239v2 = new Asn1Object(413);
-			public static Asn1Object X9_62_prime239v3 = new Asn1Object(414);
-			public static Asn1Object X9_62_prime256v1 = new Asn1Object(415);
-
-			public static Asn1Object X9_62_c2tnb191v1 = new Asn1Object(688);
-			public static Asn1Object X9_62_c2tnb239v1 = new Asn1Object(694);
-			
-			public static Asn1Object secp224r1 = new Asn1Object(713);
-			public static Asn1Object secp384r1 = new Asn1Object(715);
-			public static Asn1Object secp521r1 = new Asn1Object(716);
-
-			public static Asn1Object sect163k1 = new Asn1Object(721);
-			public static Asn1Object sect163r2 = new Asn1Object(723);
-			public static Asn1Object sect233k1 = new Asn1Object(726);
-			public static Asn1Object sect233r1 = new Asn1Object(727);
-			public static Asn1Object sect283k1 = new Asn1Object(729);
-			public static Asn1Object sect283r1 = new Asn1Object(730);
-			public static Asn1Object sect409k1 = new Asn1Object(731);
-			public static Asn1Object sect409r1 = new Asn1Object(732);
-			public static Asn1Object sect571k1 = new Asn1Object(733);
-			public static Asn1Object sect571r1 = new Asn1Object(734);
-
-			public static Asn1Object ipsec4 = new Asn1Object(750);
-		}
-		
-		public class SN
-		{
-			public static Asn1Object X9_62_prime192v1 = new Asn1Object("prime192v1");
-		}
-	}
-}
\ No newline at end of file
+// Copyright (c) 2012 Frank Laub
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+namespace OpenSSL.Core
+{
+	/// <summary>
+	/// 
+	/// </summary>
+	public class Objects
+	{
+		/// <summary>
+		/// 
+		/// </summary>
+		public class NID
+		{
+			/// <summary>
+			/// 0
+			/// </summary>
+			public static Asn1Object undef = new Asn1Object(0);
+			/// <summary>
+			/// 406
+			/// </summary>
+			public static Asn1Object X9_62_prime_field = new Asn1Object(406);
+			/// <summary>
+			/// 409
+			/// </summary>
+			public static Asn1Object X9_62_prime192v1 = new Asn1Object(409);
+			/// <summary>
+			/// 410
+			/// </summary>
+			public static Asn1Object X9_62_prime192v2 = new Asn1Object(410);
+			/// <summary>
+			/// 411
+			/// </summary>
+			public static Asn1Object X9_62_prime192v3 = new Asn1Object(411);
+			/// <summary>
+			/// 412
+			/// </summary>
+			public static Asn1Object X9_62_prime239v1 = new Asn1Object(412);
+			/// <summary>
+			/// 413
+			/// </summary>
+			public static Asn1Object X9_62_prime239v2 = new Asn1Object(413);
+			/// <summary>
+			/// 414
+			/// </summary>
+			public static Asn1Object X9_62_prime239v3 = new Asn1Object(414);
+			/// <summary>
+			/// 415
+			/// </summary>
+			public static Asn1Object X9_62_prime256v1 = new Asn1Object(415);
+
+			/// <summary>
+			/// 688
+			/// </summary>
+			public static Asn1Object X9_62_c2tnb191v1 = new Asn1Object(688);
+			/// <summary>
+			/// 694
+			/// </summary>
+			public static Asn1Object X9_62_c2tnb239v1 = new Asn1Object(694);
+			
+			/// <summary>
+			/// 713
+			/// </summary>
+			public static Asn1Object secp224r1 = new Asn1Object(713);
+			/// <summary>
+			/// 715
+			/// </summary>
+			public static Asn1Object secp384r1 = new Asn1Object(715);
+			/// <summary>
+			/// 716
+			/// </summary>
+			public static Asn1Object secp521r1 = new Asn1Object(716);
+
+			/// <summary>
+			/// 721
+			/// </summary>
+			public static Asn1Object sect163k1 = new Asn1Object(721);
+			/// <summary>
+			/// 723
+			/// </summary>
+			public static Asn1Object sect163r2 = new Asn1Object(723);
+			/// <summary>
+			/// 726
+			/// </summary>
+			public static Asn1Object sect233k1 = new Asn1Object(726);
+			/// <summary>
+			/// 727
+			/// </summary>
+			public static Asn1Object sect233r1 = new Asn1Object(727);
+			/// <summary>
+			/// 729
+			/// </summary>
+			public static Asn1Object sect283k1 = new Asn1Object(729);
+			/// <summary>
+			/// 730
+			/// </summary>
+			public static Asn1Object sect283r1 = new Asn1Object(730);
+			/// <summary>
+			/// 731
+			/// </summary>
+			public static Asn1Object sect409k1 = new Asn1Object(731);
+			/// <summary>
+			/// 732
+			/// </summary>
+			public static Asn1Object sect409r1 = new Asn1Object(732);
+			/// <summary>
+			/// 733
+			/// </summary>
+			public static Asn1Object sect571k1 = new Asn1Object(733);
+			/// <summary>
+			/// 734
+			/// </summary>
+			public static Asn1Object sect571r1 = new Asn1Object(734);
+
+			/// <summary>
+			/// 750
+			/// </summary>
+			public static Asn1Object ipsec4 = new Asn1Object(750);
+		}
+		
+		/// <summary>
+		/// 
+		/// </summary>
+		public class SN
+		{
+			/// <summary>
+			/// prime192v1
+			/// </summary>
+			public static Asn1Object X9_62_prime192v1 = new Asn1Object("prime192v1");
+		}
+	}
+}
Index: ManagedOpenSsl/Core/OpenSslException.cs
===================================================================
--- ManagedOpenSsl/Core/OpenSslException.cs	(revision 47839)
+++ ManagedOpenSsl/Core/OpenSslException.cs	(revision 47851)
@@ -24,9 +24,8 @@
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 using System;
+using System.Collections.Generic;
 using System.Text;
-using System.Collections.Generic;
-using System.Runtime.InteropServices;
 
 namespace OpenSSL.Core
 {
@@ -52,7 +51,7 @@
 		/// </summary>
 		public uint ErrorCode
 		{
-			get { return this.err; }
+			get { return err; }
 		}
 
 		/// <summary>
@@ -60,7 +59,7 @@
 		/// </summary>
 		public string Library
 		{
-			get { return Native.PtrToStringAnsi(Native.ERR_lib_error_string(this.err), false); }
+			get { return Native.PtrToStringAnsi(Native.ERR_lib_error_string(err), false); }
 		}
 
 		/// <summary>
@@ -68,7 +67,7 @@
 		/// </summary>
 		public string Reason
 		{
-			get { return Native.PtrToStringAnsi(Native.ERR_reason_error_string(this.err), false); }
+			get { return Native.PtrToStringAnsi(Native.ERR_reason_error_string(err), false); }
 		}
 
 		/// <summary>
@@ -76,7 +75,7 @@
 		/// </summary>
 		public string Function
 		{
-			get { return Native.PtrToStringAnsi(Native.ERR_func_error_string(this.err), false); }
+			get { return Native.PtrToStringAnsi(Native.ERR_func_error_string(err), false); }
 		}
 
 		/// <summary>
@@ -86,9 +85,11 @@
 		{
 			get
 			{
-				byte[] buf = new byte[1024];
+				var buf = new byte[1024];
+
 				buf.Initialize();
 				Native.ERR_error_string_n(err, buf, buf.Length);
+
 				int len;
 				for (len = 0; len < buf.Length; len++) 
 				{
@@ -95,6 +96,7 @@
 					if (buf[len] == 0)
 						break;
 				}
+
 				return Encoding.ASCII.GetString(buf, 0, len);
 			}
 		}
@@ -110,13 +112,13 @@
 		private OpenSslException(List<OpenSslError> context)
 			: base(GetErrorMessage(context))
 		{
-			this.errors = context;
+			errors = context;
 		}
 
 		/// <summary>
 		/// When this class is instantiated, GetErrorMessage() is called automatically.
 		/// This will call ERR_get_error() on the native openssl interface, once for every
-		/// error that is in the current context. The exception message is the concatination
+		/// error that is in the current context. The exception message is the concatenation
 		/// of each of these errors turned into strings using ERR_error_string_n().
 		/// </summary>
 		public OpenSslException()
@@ -124,30 +126,35 @@
 		{
 		}
 
-        private static List<OpenSslError> GetCurrentContext()
+		private static List<OpenSslError> GetCurrentContext()
 		{
-			List<OpenSslError> ret = new List<OpenSslError>();
+			var ret = new List<OpenSslError>();
+
 			while (true)
 			{
-				uint err = Native.ERR_get_error();
+				var err = Native.ERR_get_error();
+
 				if (err == 0)
 					break;
 
 				ret.Add(new OpenSslError(err));
 			}
+
 			return ret;
 		}
 
 		private static string GetErrorMessage(List<OpenSslError> context)
 		{
-			StringBuilder sb = new StringBuilder();
-			bool isFirst = true;
-			foreach (OpenSslError err in context)
+			var sb = new StringBuilder();
+			var isFirst = true;
+
+			foreach (var err in context)
 			{
 				if (isFirst)
 					isFirst = false;
 				else
 					sb.Append("\n");
+
 				sb.Append(err.Message);
 			}
 
@@ -159,7 +166,7 @@
 		/// </summary>
 		public List<OpenSslError> Errors
 		{
-			get { return this.errors; }
+			get { return errors; }
 		}
 	}
 }
Index: ManagedOpenSsl/Core/Password.cs
===================================================================
--- ManagedOpenSsl/Core/Password.cs	(revision 47839)
+++ ManagedOpenSsl/Core/Password.cs	(revision 47851)
@@ -24,9 +24,8 @@
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 using System;
-using System.Collections.Generic;
+using System.Runtime.InteropServices;
 using System.Text;
-using System.Runtime.InteropServices;
 
 namespace OpenSSL.Core
 {
@@ -74,15 +73,16 @@
 		{
 			get
 			{
-				if (this.OnPassword == null)
+				if (OnPassword == null)
 					return null;
-				return this.OnPasswordThunk;
+
+				return OnPasswordThunk;
 			}
 		}
 
 		public PasswordThunk(PasswordHandler client, object arg)
 		{
-			this.OnPassword = client;
+			OnPassword = client;
 			this.arg = arg;
 		}
 
@@ -90,13 +90,15 @@
 		{
 			try
 			{
-				string ret = OnPassword(rwflag != 0, this.arg);
-				byte[] pass = Encoding.ASCII.GetBytes(ret);
-				int len = pass.Length;
+				var ret = OnPassword(rwflag != 0, arg);
+				var pass = Encoding.ASCII.GetBytes(ret);
+				var len = pass.Length;
+
 				if (len > size)
 					len = size;
 
 				Marshal.Copy(pass, 0, buf, len);
+
 				return len;
 			}
 			catch (Exception ex)
@@ -106,5 +108,4 @@
 			}
 		}
 	}
-
 }
Index: ManagedOpenSsl/Core/Random.cs
===================================================================
--- ManagedOpenSsl/Core/Random.cs	(revision 47839)
+++ ManagedOpenSsl/Core/Random.cs	(revision 47851)
@@ -22,10 +22,10 @@
 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
 using System;
-using System.Collections.Generic;
+using System.Runtime.InteropServices;
 using System.Text;
-using System.Runtime.InteropServices;
 
 namespace OpenSSL.Core
 {
@@ -49,7 +49,7 @@
 		/// <param name="seed"></param>
 		public static void Seed(string seed)
 		{
-			byte[] tmp = Encoding.ASCII.GetBytes(seed);
+			var tmp = Encoding.ASCII.GetBytes(seed);
 			Native.RAND_seed(tmp, tmp.Length);
 		}
 
@@ -60,8 +60,9 @@
 		/// <returns></returns>
 		public static byte[] PseudoBytes(int len)
 		{
-			byte[] buf = new byte[len];
+			var buf = new byte[len];
 			Native.ExpectSuccess(Native.RAND_pseudo_bytes(buf, buf.Length));
+
 			return buf;
 		}
 
@@ -80,8 +81,9 @@
 		/// <returns></returns>
 		public static byte[] Bytes(int len)
 		{
-			byte[] buf = new byte[len];
+			var buf = new byte[len];
 			Native.ExpectSuccess(Native.RAND_bytes(buf, len));
+
 			return buf;
 		}
 
@@ -120,7 +122,7 @@
 		/// <returns></returns>
 		public static string GetFilename()
 		{
-			byte[] buf = new byte[1024];
+			var buf = new byte[1024];
 			return Native.RAND_file_name(buf, (uint)buf.Length);
 		}
 
@@ -127,7 +129,8 @@
 		/// <summary>
 		/// Returns RAND_status()
 		/// </summary>
-		public static int Status {
+		public static int Status
+		{
 			get { return Native.RAND_status(); }
 		}
 
@@ -178,25 +181,54 @@
 		/// <returns></returns>
 		public static BigNumber Next(int bits, int top, int bottom)
 		{
-			BigNumber bn = new BigNumber();
+			var bn = new BigNumber();
 			Native.ExpectSuccess(Native.BN_rand(bn.Handle, bits, top, bottom));
+
 			return bn;
 		}
 
+		/// <summary>
+		/// Function types
+		/// </summary>
 		public class Delegates
 		{
+			/// <summary>
+			/// 
+			/// </summary>
+			/// <param name="buf"></param>
+			/// <param name="num"></param>
+			/// <returns></returns>
 			[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
 			public delegate int Seed(IntPtr buf, int num);
-	
+
+			/// <summary>
+			/// 
+			/// </summary>
+			/// <param name="buf"></param>
+			/// <param name="num"></param>
+			/// <returns></returns>
 			[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
-			public delegate int Bytes([MarshalAs(UnmanagedType.LPArray, SizeParamIndex=1)] byte[] buf, int num);
-	
+			public delegate int Bytes([MarshalAs(UnmanagedType.LPArray, SizeParamIndex = 1)] byte[] buf, int num);
+
+			/// <summary>
+			/// 
+			/// </summary>
 			[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
 			public delegate void Cleanup();
-	
+
+			/// <summary>
+			/// 
+			/// </summary>
+			/// <param name="buf"></param>
+			/// <param name="num"></param>
+			/// <param name="entropy"></param>
 			[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
 			public delegate void Add(IntPtr buf, int num, double entropy);
-	
+
+			/// <summary>
+			/// 
+			/// </summary>
+			/// <returns></returns>
 			[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
 			public delegate int Status();
 		};
@@ -213,6 +245,9 @@
 		};
 
 		#region Random Method
+		/// <summary>
+		/// 
+		/// </summary>
 		public class Method : Base
 		{
 			#region Data Structures and Variables
@@ -219,14 +254,19 @@
 			private static IntPtr original;
 			private rand_meth_st raw = new rand_meth_st();
 			#endregion
-			
-			#region Initialization			
-			static Method() {
+
+			#region Initialization
+			static Method()
+			{
 				original = Native.ExpectNonNull(Native.RAND_get_rand_method());
 			}
-			
-			public Method() 
-				: base(Marshal.AllocHGlobal(Marshal.SizeOf(typeof(rand_meth_st))), true) {
+
+			/// <summary>
+			/// 
+			/// </summary>
+			public Method()
+				: base(Marshal.AllocHGlobal(Marshal.SizeOf(typeof(rand_meth_st))), true)
+			{
 				rand_meth_st raw = (rand_meth_st)Marshal.PtrToStructure(original, typeof(rand_meth_st));
 				this.raw.add = raw.add;
 				this.raw.bytes = raw.bytes;
@@ -235,63 +275,99 @@
 				this.raw.pseudorand = raw.pseudorand;
 				this.raw.status = raw.status;
 			}
-			
-			~Method() {
+
+			/// <summary>
+			/// 
+			/// </summary>
+			~Method()
+			{
 				Dispose();
 			}
 			#endregion
-			
+
 			#region Properties
-			public Delegates.Seed Seed {
-				get { return this.raw.seed; }
-				set { this.raw.seed = value; }
+			/// <summary>
+			/// 
+			/// </summary>
+			public Delegates.Seed Seed
+			{
+				get { return raw.seed; }
+				set { raw.seed = value; }
 			}
 
-			public Delegates.Bytes Bytes {
-				get { return this.raw.bytes; }
-				set { this.raw.bytes = value; }
+			/// <summary>
+			/// 
+			/// </summary>
+			public Delegates.Bytes Bytes
+			{
+				get { return raw.bytes; }
+				set { raw.bytes = value; }
 			}
 
-			public Delegates.Cleanup Cleanup {
-				get { return this.raw.cleanup; }
-				set { this.raw.cleanup = value; }
+			/// <summary>
+			/// 
+			/// </summary>
+			public Delegates.Cleanup Cleanup
+			{
+				get { return raw.cleanup; }
+				set { raw.cleanup = value; }
 			}
 
-			public Delegates.Add Add {
-				get { return this.raw.add; }
-				set { this.raw.add = value; }
+			/// <summary>
+			/// 
+			/// </summary>
+			public Delegates.Add Add
+			{
+				get { return raw.add; }
+				set { raw.add = value; }
 			}
 
-			public Delegates.Bytes PseudoRand {
-				get { return this.raw.pseudorand; }
-				set { this.raw.pseudorand = value; }
+			/// <summary>
+			/// 
+			/// </summary>
+			public Delegates.Bytes PseudoRand
+			{
+				get { return raw.pseudorand; }
+				set { raw.pseudorand = value; }
 			}
 
-			public Delegates.Status Status {
-				get { return this.raw.status; }
-				set { this.raw.status = value; }
+			/// <summary>
+			/// 
+			/// </summary>
+			public Delegates.Status Status
+			{
+				get { return raw.status; }
+				set { raw.status = value; }
 			}
 			#endregion
-			
+
 			#region Methods
-			public void Override() {
-				Marshal.StructureToPtr(this.raw, this.ptr, false);
-				Native.ExpectSuccess(Native.RAND_set_rand_method(this.ptr));
+			/// <summary>
+			/// 
+			/// </summary>
+			public void Override()
+			{
+				Marshal.StructureToPtr(raw, ptr, false);
+				Native.ExpectSuccess(Native.RAND_set_rand_method(ptr));
 			}
-						
-			private void Restore() {
+
+			private void Restore()
+			{
 				Native.ExpectSuccess(Native.RAND_set_rand_method(original));
 			}
 			#endregion
 
 			#region IDisposable implementation
-			protected override void OnDispose() {
+			/// <summary>
+			/// 
+			/// </summary>
+			protected override void OnDispose()
+			{
 				Restore();
-				Marshal.FreeHGlobal(this.ptr);
+				Marshal.FreeHGlobal(ptr);
 			}
 			#endregion
 		};
-
 		#endregion
 	}
 }
Index: ManagedOpenSsl/Core/Stack.cs
===================================================================
--- ManagedOpenSsl/Core/Stack.cs	(revision 47839)
+++ ManagedOpenSsl/Core/Stack.cs	(revision 47851)
@@ -26,7 +26,6 @@
 using System;
 using System.Collections;
 using System.Collections.Generic;
-using System.Text;
 using System.Reflection;
 
 namespace OpenSSL.Core
@@ -43,10 +42,11 @@
 	}
 
 	/// <summary>
-	/// Encapsultes the sk_* functions
+	/// Encapsulates the sk_* functions
 	/// </summary>
 	/// <typeparam name="T"></typeparam>
-	public class Stack<T> : BaseValueType, IStack, IList<T> where T : Base, IStackable
+	public class Stack<T> : BaseValue, IStack, IList<T> 
+		where T : BaseReference, IStackable
 	{
 		#region Initialization
 		internal Stack(IntPtr ptr, bool owner)
@@ -72,7 +72,7 @@
 		/// <returns></returns>
 		public T Shift()
 		{
-			IntPtr ptr = Native.sk_shift(this.ptr);
+			var ptr = Native.sk_shift(this.ptr);
 			return CreateInstance(ptr);
 		}
 
@@ -94,14 +94,17 @@
 			{
 				get
 				{
-					if (this.index < 0 || this.index >= this.parent.Count)
+					if (index < 0 || index >= parent.Count)
 						throw new InvalidOperationException();
 
-					IntPtr ptr = Native.ExpectNonNull(Native.sk_value(this.parent.Handle, index));
+					var ptr = Native.ExpectNonNull(Native.sk_value(parent.Handle, index));
+
 					// Create a new item
 					T item = parent.CreateInstance(ptr);
+
 					// Addref the item
 					item.AddRef();
+
 					// return it
 					return item;
 				}
@@ -117,22 +120,24 @@
 
 			#region IEnumerator Members
 
-			object System.Collections.IEnumerator.Current
+			object IEnumerator.Current
 			{
-				get { return this.Current; }
+				get { return Current; }
 			}
 
 			public bool MoveNext()
 			{
-				this.index++;
-				if (this.index < this.parent.Count)
+				index++;
+
+				if (index < parent.Count)
 					return true;
+
 				return false;
 			}
 
 			public void Reset()
 			{
-				this.index = -1;
+				index = -1;
 			}
 
 			#endregion
@@ -148,7 +153,7 @@
 			// Free the items
 			Clear();
 
-			Native.sk_free(this.ptr);
+			Native.sk_free(ptr);
 		}
 
 		/// <summary>
@@ -157,7 +162,7 @@
 		/// <returns></returns>
 		internal override IntPtr DuplicateHandle()
 		{
-			return Native.sk_dup(this.ptr);
+			return Native.sk_dup(ptr);
 		}
 
 		#endregion
@@ -171,7 +176,7 @@
 		/// <returns></returns>
 		public int IndexOf(T item)
 		{
-			return Native.sk_find(this.ptr, item.Handle);
+			return Native.sk_find(ptr, item.Handle);
 		}
 
 		/// <summary>
@@ -182,7 +187,8 @@
 		public void Insert(int index, T item)
 		{
 			// Insert the item into the stack
-			Native.ExpectSuccess(Native.sk_insert(this.ptr, item.Handle, index));
+			Native.ExpectSuccess(Native.sk_insert(ptr, item.Handle, index));
+
 			// Addref the item
 			item.AddRef();
 		}
@@ -193,7 +199,7 @@
 		/// <param name="index"></param>
 		public void RemoveAt(int index)
 		{
-			Native.ExpectNonNull(Native.sk_delete(this.ptr, index));
+			Native.ExpectNonNull(Native.sk_delete(ptr, index));
 		}
 
 		/// <summary>
@@ -206,11 +212,14 @@
 			get
 			{
 				// Get the native pointer from the stack
-				IntPtr ptr = Native.ExpectNonNull(Native.sk_value(this.ptr, index));
+				var ptr = Native.ExpectNonNull(Native.sk_value(this.ptr, index));
+
 				// Create a new object
-				T item = CreateInstance(ptr);
+				var item = CreateInstance(ptr);
+
 				// Addref the object
 				item.AddRef();
+
 				// Return the managed object
 				return item;
 			}
@@ -217,9 +226,11 @@
 			set
 			{
 				// Insert the item in the stack
-				int ret = Native.sk_insert(this.ptr, value.Handle, index);
+				var ret = Native.sk_insert(ptr, value.Handle, index);
+
 				if (ret < 0)
 					throw new OpenSslException();
+				
 				// Addref the native pointer
 				value.AddRef();
 			}
@@ -236,8 +247,9 @@
 		public void Add(T item)
 		{
 			// Add the item to the stack
-			if (Native.sk_push(this.ptr, item.Handle) <= 0)
+			if (Native.sk_push(ptr, item.Handle) <= 0)
 				throw new OpenSslException();
+
 			// Addref the native pointer
 			item.AddRef();
 		}
@@ -247,12 +259,13 @@
 		/// </summary>
 		public void Clear()
 		{
-			IntPtr value_ptr = Native.sk_shift(this.ptr);
+			var value_ptr = Native.sk_shift(ptr);
+
 			while (value_ptr != IntPtr.Zero)
 			{
-				T item = CreateInstance(value_ptr);
+				var item = CreateInstance(value_ptr);
 				item.Dispose();
-				value_ptr = Native.sk_shift(this.ptr);
+				value_ptr = Native.sk_shift(ptr);
 			}
 		}
 
@@ -263,16 +276,12 @@
 		/// <returns></returns>
 		public bool Contains(T item)
 		{
-			foreach (T element in this)
+			foreach (var element in this)
 			{
 				if (element.Equals(item))
 					return true;
 			}
 			return false;
-			//int ret = Native.sk_find(this.ptr, item.Handle);
-			//if (ret >= 0 && ret < this.Count)
-			//    return true;
-			//return false;
 		}
 
 		/// <summary>
@@ -292,9 +301,11 @@
 		{
 			get
 			{
-				int ret = Native.sk_num(this.ptr);
+				var ret = Native.sk_num(ptr);
+
 				if (ret < 0)
 					throw new OpenSslException();
+
 				return ret;
 			}
 		}
@@ -314,11 +325,13 @@
 		/// <returns></returns>
 		public bool Remove(T item)
 		{
-			IntPtr ptr = Native.sk_delete_ptr(this.ptr, item.Handle);
+			var ptr = Native.sk_delete_ptr(this.ptr, item.Handle);
+
 			if (ptr != IntPtr.Zero)
 			{
 				return true;
 			}
+
 			return false;
 		}
 
@@ -339,7 +352,7 @@
 
 		#region IEnumerable Members
 
-		System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()
+		IEnumerator IEnumerable.GetEnumerator()
 		{
 			return new Enumerator(this);
 		}
@@ -350,15 +363,17 @@
 
 		private T CreateInstance(IntPtr ptr)
 		{
-			object[] args = new object[] {
-				(IStack)this,
+			var args = new object[] {
+				this,
 				ptr
 			};
-			BindingFlags flags =
+
+			var flags =
 				BindingFlags.NonPublic |
 				BindingFlags.Public |
 				BindingFlags.Instance;
-			T item = (T)Activator.CreateInstance(typeof(T), flags, null, args, null);
+
+			var item = (T)Activator.CreateInstance(typeof(T), flags, null, args, null);
 			return item;
 		}
 
Index: ManagedOpenSsl/Core/Version.cs
===================================================================
--- ManagedOpenSsl/Core/Version.cs	(revision 47839)
+++ ManagedOpenSsl/Core/Version.cs	(revision 47851)
@@ -23,8 +23,6 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-using System;
-using System.Collections.Generic;
 using System.Text;
 
 namespace OpenSSL.Core
@@ -87,7 +85,7 @@
 		/// </summary>
 		public uint Major
 		{
-			get { return (this.raw & 0xf0000000) >> 28; }
+			get { return (raw & 0xf0000000) >> 28; }
 		}
 
 		/// <summary>
@@ -95,7 +93,7 @@
 		/// </summary>
 		public uint Minor
 		{
-			get { return (this.raw & 0x0ff00000) >> 20; }
+			get { return (raw & 0x0ff00000) >> 20; }
 		}
 
 		/// <summary>
@@ -103,21 +101,24 @@
 		/// </summary>
 		public uint Fix
 		{
-			get { return (this.raw & 0x000ff000) >> 12; }
+			get { return (raw & 0x000ff000) >> 12; }
 		}
 
 		/// <summary>
 		/// Patch portion of the Version. These should start at 'a' and continue to 'z'.
 		/// </summary>
-		public char Patch
+		public char? Patch
 		{
 			get
 			{
-				uint patch = (this.raw & 0x00000ff0) >> 4;
+				var patch = (raw & 0x00000ff0) >> 4;
+				if (patch == 0)
+					return null;
 
-				byte a = Encoding.ASCII.GetBytes("a")[0];
-				uint x = a + patch;
-				char ch = Encoding.ASCII.GetString(new byte[] { (byte)x })[0];
+				var a = Encoding.ASCII.GetBytes("a")[0];
+				var x = a + (patch - 1);
+				var ch = Encoding.ASCII.GetString(new[] { (byte)x })[0];
+
 				return ch;
 			}
 		}
@@ -129,7 +130,8 @@
 		{
 			get
 			{
-				uint status = this.RawStatus;
+				var status = RawStatus;
+
 				if (status == 0)
 					return StatusType.Development;
 				else if (status == 0xf)
@@ -144,7 +146,7 @@
 		/// </summary>
 		public uint Raw
 		{
-			get { return this.raw; }
+			get { return raw; }
 		}
 
 		/// <summary>
@@ -152,7 +154,7 @@
 		/// </summary>
 		public uint RawStatus
 		{
-			get { return this.raw & 0x0000000f; }
+			get { return raw & 0x0000000f; }
 		}
 
 		/// <summary>
@@ -161,12 +163,13 @@
 		/// <returns></returns>
 		public override string ToString()
 		{
-			return string.Format("{0}.{1}.{2}{3} {4}",
+			return string.Format("{0}.{1}.{2}{3} {4} (0x{5:x8})",
 				Major,
 				Minor,
 				Fix,
 				Patch,
-				Status);
+				Status,
+				Raw);
 		}
 
 		/// <summary>
@@ -202,7 +205,7 @@
 		/// <param name="format"></param>
 		public static string GetText(Format format)
 		{
-			return Native.SSLeay_version((int)format);
+			return Native.StaticString(Native.SSLeay_version((int)format));
 		}
 	}
 }
Index: ManagedOpenSsl/SSL/AlpnException.cs
===================================================================
--- ManagedOpenSsl/SSL/AlpnException.cs	(revision 0)
+++ ManagedOpenSsl/SSL/AlpnException.cs	(revision 47851)
@@ -0,0 +1,22 @@
+﻿// Copyright © Microsoft Open Technologies, Inc.
+// All Rights Reserved       
+
+using System;
+
+namespace OpenSSL.Exceptions
+{
+	/// <summary>
+	/// Alpn exception.
+	/// </summary>
+    public class AlpnException : Exception
+    {
+		/// <summary>
+		/// Initializes a new instance of the <see cref="OpenSSL.Exceptions.AlpnException"/> class.
+		/// </summary>
+		/// <param name="msg">Message.</param>
+        public AlpnException(string msg)
+            : base(msg)
+        {
+        }
+    }
+}
\ No newline at end of file
Index: ManagedOpenSsl/SSL/ConnectionEnd.cs
===================================================================
--- ManagedOpenSsl/SSL/ConnectionEnd.cs	(revision 0)
+++ ManagedOpenSsl/SSL/ConnectionEnd.cs	(revision 47851)
@@ -0,0 +1,21 @@
+﻿// Copyright © Microsoft Open Technologies, Inc.
+// All Rights Reserved       
+
+namespace OpenSSL
+{
+    /// <summary>
+    /// 
+    /// </summary>
+    public enum ConnectionEnd
+    {
+        /// <summary>
+        /// 
+        /// </summary>
+        Client = 0,
+
+        /// <summary>
+        /// 
+        /// </summary>
+        Server = 1,
+    }
+}
Index: ManagedOpenSsl/SSL/Extensions/Alpn.cs
===================================================================
--- ManagedOpenSsl/SSL/Extensions/Alpn.cs	(revision 0)
+++ ManagedOpenSsl/SSL/Extensions/Alpn.cs	(revision 47851)
@@ -0,0 +1,120 @@
+﻿// Copyright © Microsoft Open Technologies, Inc.
+// All Rights Reserved       
+
+using System;
+using System.Collections.Generic;
+using System.IO;
+using System.Runtime.InteropServices;
+using System.Text;
+using OpenSSL.Core;
+using OpenSSL.Exceptions;
+using OpenSSL.SSL;
+
+namespace OpenSSL.Extensions
+{
+	internal class AlpnExtension
+	{
+		internal AlpnExtension(IntPtr ctxHandle, IEnumerable<string> knownProtos)
+		{
+			if (knownProtos == null)
+				throw new ArgumentNullException("knownProtos");
+
+			SetKnownProtocols(ctxHandle, knownProtos);
+		}
+
+		private byte[] _knownProtocols;
+
+		private bool CompareProtos(byte[] protos1, int offset1, byte[] protos2, int offset2, int count)
+		{
+			if (offset1 + count > protos1.Length ||
+			    offset2 + count > protos2.Length)
+			{
+				return false;
+			}
+
+			for (int i = 0; i < count; i++)
+			{
+				if (protos1[i + offset1] != protos2[i + offset2])
+					return false;
+			}
+
+			return true;
+		}
+
+		private void SetKnownProtocols(IntPtr ctx, IEnumerable<string> protos)
+		{
+			uint total = 0;
+			using (var protoStream = new MemoryStream())
+			{
+				foreach (var proto in protos)
+				{
+					byte len = (byte)proto.Length;
+					protoStream.WriteByte(len);
+
+					var utf8 = Encoding.UTF8.GetBytes(proto);
+					protoStream.Write(utf8, 0, len);
+
+					total += sizeof(byte) + (uint)len;
+				}
+
+				_knownProtocols = protoStream.GetBuffer();
+			}
+
+			if (Native.SSL_CTX_set_alpn_protos(ctx, _knownProtocols, total) != 0)
+			{
+				throw new AlpnException("cant set alpn protos");
+			}
+		}
+
+		public int AlpnCb(IntPtr ssl, 
+			out string selProto, 
+			out byte selProtoLen,
+			IntPtr inProtos, 
+			int inProtosLen, 
+			IntPtr arg)
+		{
+			var inProtosBytes = new byte[inProtosLen];
+			Marshal.Copy(inProtos, inProtosBytes, 0, inProtosLen);
+
+			int matchIndex = -1;
+			byte matchLen = 0;
+			for (int i = 0; i < _knownProtocols.Length;)
+			{
+				bool gotMatch = false;
+				for (int j = 0; j < inProtosLen;)
+				{
+					if (_knownProtocols[i] == inProtosBytes[j] &&
+					    CompareProtos(_knownProtocols, i + 1, inProtosBytes, j + 1, _knownProtocols[i]))
+					{
+						/* We found a match */
+						matchIndex = i;
+						matchLen = _knownProtocols[i];
+						gotMatch = true;
+						break;
+					}
+
+					j += inProtosBytes[j];
+					j++;
+				}
+
+				if (gotMatch)
+					break;
+
+				i += _knownProtocols[i];
+				i++;
+			}
+
+			if (matchIndex == -1)
+			{
+				selProto = null;
+				selProtoLen = 0;
+				return (int)Errors.SSL_TLSEXT_ERR_NOACK;
+			}
+
+			selProto = Encoding.UTF8.GetString(_knownProtocols, matchIndex + 1, matchLen);
+
+			selProtoLen = matchLen;
+			return (int)Errors.SSL_TLSEXT_ERR_OK; // ok OPENSSL_NPN_NEGOTIATED
+		}
+	}
+}
Index: ManagedOpenSsl/SSL/Extensions/EnumExtensions.cs
===================================================================
--- ManagedOpenSsl/SSL/Extensions/EnumExtensions.cs	(revision 0)
+++ ManagedOpenSsl/SSL/Extensions/EnumExtensions.cs	(revision 47851)
@@ -0,0 +1,24 @@
+﻿using System;
+
+namespace OpenSSL
+{
+	/// <summary>
+	/// Enum extensions.
+	/// </summary>
+    public static class EnumExtensions
+    {
+		/// <summary>
+		/// Determines if has flag the specified value flag.
+		/// </summary>
+		/// <returns><c>true</c> if has flag the specified value flag; otherwise, <c>false</c>.</returns>
+		/// <param name="value">Value.</param>
+		/// <param name="flag">Flag.</param>
+		public static bool HasFlag(Enum value, Enum flag)
+		{
+			var longValue = Convert.ToInt64(value);
+			var longFlag = Convert.ToInt64(flag);
+			return (longValue & longFlag) == longFlag;
+		}
+    }
+}
+
Index: ManagedOpenSsl/SSL/Extensions/Errors.cs
===================================================================
--- ManagedOpenSsl/SSL/Extensions/Errors.cs	(revision 0)
+++ ManagedOpenSsl/SSL/Extensions/Errors.cs	(revision 47851)
@@ -0,0 +1,13 @@
+﻿// Copyright © Microsoft Open Technologies, Inc.
+// All Rights Reserved       
+
+namespace OpenSSL.SSL
+{
+    internal enum Errors : int
+    {
+        SSL_TLSEXT_ERR_OK = 0,
+        SSL_TLSEXT_ERR_ALERT_WARNING = 1,
+        SSL_TLSEXT_ERR_ALERT_FATAL = 2,
+        SSL_TLSEXT_ERR_NOACK = 3,
+    }
+}
Index: ManagedOpenSsl/SSL/Extensions/SNI.cs
===================================================================
--- ManagedOpenSsl/SSL/Extensions/SNI.cs	(revision 0)
+++ ManagedOpenSsl/SSL/Extensions/SNI.cs	(revision 47851)
@@ -0,0 +1,116 @@
+﻿using System;
+using System.Runtime.InteropServices;
+using OpenSSL.Core;
+using OpenSSL.SSL;
+
+namespace OpenSSL.Extensions
+{
+	/// <summary>
+	/// Sni callback.
+	/// </summary>
+	[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
+    public delegate int SniCallback(IntPtr ssl,
+                                    IntPtr ad,
+                                    IntPtr arg);
+
+	internal class Sni
+	{
+		internal const int TLSEXT_NAMETYPE_host_name = 0;
+		internal const int SSL_CTRL_SET_TLSEXT_SERVERNAME_CB = 53;
+		internal const int SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG = 54;
+		internal const int SSL_CTRL_SET_TLSEXT_HOSTNAME = 55;
+		internal const int SSL_CTRL_GET_SESSION_REUSED = 8;
+
+		private readonly string _serverName;
+		private static IntPtr _serverNamePtr;
+
+		public Sni(string serverName)
+		{
+			_serverName = serverName;
+			_serverNamePtr = Marshal.StringToHGlobalAnsi(serverName);
+		}
+
+		public string ServerName { get { return _serverName; } }
+
+
+		public void AttachSniExtensionClient(IntPtr ssl, IntPtr sslCtx, SniCallback cb)
+		{
+			SSL_CTX_set_tlsext_servername_callback(cb, sslCtx);
+
+			Native.SSL_CTX_ctrl(sslCtx, SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG, 0, _serverNamePtr);
+			SSL_set_tlsext_host_name(ssl);
+		}
+
+		public void AttachSniExtensionServer(IntPtr ssl, IntPtr sslCtx, SniCallback cb)
+		{
+			SSL_CTX_set_tlsext_servername_callback(cb, sslCtx);
+			//SSL_CTX_ctrl(sslCtx, SSL_CTRL_SET_TLSEXT_SERVERNAME_ARG, 0, serverNamePtr);
+		}
+
+		private static long SSL_session_reused(IntPtr ssl)
+		{
+			return Native.SSL_ctrl(ssl, SSL_CTRL_GET_SESSION_REUSED, 0, IntPtr.Zero);
+		}
+
+		private int SSL_set_tlsext_host_name(IntPtr s)
+		{
+			return Native.SSL_ctrl(s, SSL_CTRL_SET_TLSEXT_HOSTNAME,
+				TLSEXT_NAMETYPE_host_name,
+				_serverNamePtr);
+		}
+
+		private int SSL_CTX_set_tlsext_servername_callback(SniCallback cb, IntPtr ctx)
+		{
+			var cbPtr = Marshal.GetFunctionPointerForDelegate(cb);
+			return Native.SSL_CTX_callback_ctrl(ctx, SSL_CTRL_SET_TLSEXT_SERVERNAME_CB, cbPtr);
+		}
+
+		//This callback just checks was session reused or not.
+		//If we renegotiate each time we make a connection then clientSniArgAck
+		//should be true
+		public int ClientSniCb(IntPtr ssl, IntPtr ad, IntPtr arg)
+		{
+			var hnptr = Native.SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
+
+			if (Native.SSL_get_servername_type(ssl) != -1)
+			{
+				var isReused = SSL_session_reused(ssl) != 0;
+				var clientSniArgAck = !isReused && hnptr != IntPtr.Zero;
+#if DEBUG
+				Console.WriteLine("Servername ack is {0}", clientSniArgAck);
+#endif
+			}
+			else
+			{
+#if DEBUG
+				Console.WriteLine("Can't use SSL_get_servername");
+#endif
+				throw new Exception("Cant use servername extension");
+			}
+
+			return (int)Errors.SSL_TLSEXT_ERR_OK;
+		}
+
+		public int ServerSniCb(IntPtr ssl, IntPtr ad, IntPtr arg)
+		{
+			//Hostname in TLS extension
+			var extServerNamePtr = Native.SSL_get_servername(ssl, TLSEXT_NAMETYPE_host_name);
+			var extServerName = Marshal.PtrToStringAnsi(extServerNamePtr);
+
+			if (!_serverName.Equals(extServerName))
+			{
+#if DEBUG
+				Console.WriteLine("Server names are not equal");
+#endif
+				throw new Exception("Server names are not equal");    
+			}
+
+			return (int)Errors.SSL_TLSEXT_ERR_OK;
+		}
+
+		~Sni()
+		{
+			//Marshal.FreeHGlobal(_serverNamePtr);
+		}
+	}
+}
Index: ManagedOpenSsl/SSL/Protocols.cs
===================================================================
--- ManagedOpenSsl/SSL/Protocols.cs	(revision 0)
+++ ManagedOpenSsl/SSL/Protocols.cs	(revision 47851)
@@ -0,0 +1,24 @@
+﻿// Copyright © Microsoft Open Technologies, Inc.
+// All Rights Reserved       
+
+namespace OpenSSL
+{
+    /// <summary>
+    /// see 12 -> 3.1.  HTTP/2 Version Identification
+    /// </summary>
+    public static class Protocols
+    {
+		/// <summary>
+		/// The http2.
+		/// </summary>
+        public static string Http2 = "h2-12";
+		/// <summary>
+		/// The http2 no tls.
+		/// </summary>
+        public static string Http2NoTls = "h2c-12";
+		/// <summary>
+		/// The http1.
+		/// </summary>
+        public static string Http1 = "http/1.1";
+    }
+}
Index: ManagedOpenSsl/SSL/Enums.cs
===================================================================
--- ManagedOpenSsl/SSL/Enums.cs	(revision 47839)
+++ ManagedOpenSsl/SSL/Enums.cs	(revision 47851)
@@ -24,8 +24,6 @@
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
 using System;
-using System.Collections.Generic;
-using System.Text;
 
 namespace OpenSSL.SSL
 {
@@ -149,6 +147,7 @@
 	/// <summary>
 	/// 
 	/// </summary>
+	[Flags]
 	public enum SslProtocols
 	{
 		/// <summary>
@@ -176,6 +175,7 @@
 	/// <summary>
 	/// 
 	/// </summary>
+	[Flags]
 	public enum SslStrength
 	{
 		/// <summary>
@@ -196,7 +196,10 @@
 		All = High | Medium | Low
 	}
 
-	enum SslFileType
+	/// <summary>
+	/// SSL_FILETYPE_*
+	/// </summary>
+	public enum SslFileType
 	{
 		/// <summary>
 		/// SSL_FILETYPE_PEM
@@ -227,10 +230,10 @@
 		Complete
 	}
 
-
 	/// <summary>
 	/// Options enumeration for Options property
 	/// </summary>
+	[Flags]
 	enum SslOptions
 	{
 		SSL_OP_MICROSOFT_SESS_ID_BUG = 0x00000001,
@@ -238,7 +241,10 @@
 		SSL_OP_NETSCAPE_REUSE_CIPHER_CHANGE_BUG = 0x00000008,
 		SSL_OP_SSLREF2_REUSE_CERT_TYPE_BUG = 0x00000010,
 		SSL_OP_MICROSOFT_BIG_SSLV3_BUFFER = 0x00000020,
-		SSL_OP_MSIE_SSLV2_RSA_PADDING = 0x00000040, /* no effect since 0.9.7h and 0.9.8b */
+		/// <summary>
+		/// no effect since 0.9.7h and 0.9.8b
+		/// </summary>
+		SSL_OP_MSIE_SSLV2_RSA_PADDING = 0x00000040, 
 		SSL_OP_SSLEAY_080_CLIENT_DH_BUG = 0x00000080,
 		SSL_OP_TLS_D5_BUG = 0x00000100,
 		SSL_OP_TLS_BLOCK_PADDING_BUG = 0x00000200,
@@ -274,8 +280,10 @@
 		SSL_OP_NO_SSLv3 = 0x02000000,
 		SSL_OP_NO_TLSv1 = 0x04000000,
 
-		/* The next flag deliberately changes the ciphertest, this is a check
-		 * for the PKCS#1 attack */
+		/// <summary>
+		/// The next flag deliberately changes the ciphertest, this is a check
+		/// for the PKCS#1 attack
+		/// </summary>
 		SSL_OP_PKCS1_CHECK_1 = 0x08000000,
 		SSL_OP_PKCS1_CHECK_2 = 0x10000000,
 		SSL_OP_NETSCAPE_CA_DN_BUG = 0x20000000,
@@ -284,21 +292,33 @@
 
 	enum SslMode
 	{
-		/* Allow SSL_write(..., n) to return r with 0 < r < n (i.e. report success
-		 * when just a single record has been written): */
+		/// <summary>
+		/// Allow SSL_write(..., n) to return r with 0 &lt; r &lt; n (i.e. report success
+		/// when just a single record has been written): 
+		/// </summary>
 		SSL_MODE_ENABLE_PARTIAL_WRITE = 0x00000001,
-		/* Make it possible to retry SSL_write() with changed buffer location
-		 * (buffer contents must stay the same!); this is not the default to avoid
-		 * the misconception that non-blocking SSL_write() behaves like
-		 * non-blocking write(): */
+
+		/// <summary>
+		/// Make it possible to retry SSL_write() with changed buffer location
+		/// (buffer contents must stay the same!); this is not the default to avoid
+		/// the misconception that non-blocking SSL_write() behaves like
+		/// non-blocking write():
+		/// </summary>
 		SSL_MODE_ACCEPT_MOVING_WRITE_BUFFER = 0x00000002,
-		/* Never bother the application with retries if the transport
-		 * is blocking: */
+
+		/// <summary>
+		/// Never bother the application with retries if the transport
+		/// is blocking:
+		/// </summary>
 		SSL_MODE_AUTO_RETRY = 0x00000004,
-		/* Don't attempt to automatically build certificate chain */
+
+		/// <summary>
+		/// Don't attempt to automatically build certificate chain
+		/// </summary>
 		SSL_MODE_NO_AUTO_CHAIN = 0x00000008
 	}
 
+	[Flags]
 	enum VerifyMode
 	{
 		SSL_VERIFY_NONE = 0x00,
Index: ManagedOpenSsl/SSL/Ssl.cs
===================================================================
--- ManagedOpenSsl/SSL/Ssl.cs	(revision 47839)
+++ ManagedOpenSsl/SSL/Ssl.cs	(revision 47851)
@@ -23,16 +23,18 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
+using OpenSSL.X509;
 using System;
+using System.Runtime.InteropServices;
+using OpenSSL.Extensions;
+using OpenSSL.Exceptions;
+using System.Text;
 using System.Collections.Generic;
-using System.Text;
-using System.Runtime.InteropServices;
-using OpenSSL.Core;
-using OpenSSL.X509;
 
 namespace OpenSSL.SSL
 {
-	enum SslError
+	internal enum SslError
 	{
 		SSL_ERROR_NONE = 0,
 		SSL_ERROR_SSL = 1,
@@ -39,210 +41,20 @@
 		SSL_ERROR_WANT_READ = 2,
 		SSL_ERROR_WANT_WRITE = 3,
 		SSL_ERROR_WANT_X509_LOOKUP = 4,
-		SSL_ERROR_SYSCALL = 5, /* look at error stack/return value/errno */
+		SSL_ERROR_SYSCALL = 5,
 		SSL_ERROR_ZERO_RETURN = 6,
 		SSL_ERROR_WANT_CONNECT = 7,
 		SSL_ERROR_WANT_ACCEPT = 8
 	}
 
-	class Ssl : Base, IDisposable
+	/// <summary>
+	/// Ssl.
+	/// </summary>
+	public class Ssl : Base
 	{
 		internal const int SSL_ST_CONNECT = 0x1000;
 		internal const int SSL_ST_ACCEPT = 0x2000;
 
-		#region ssl_st
-
-		[StructLayout(LayoutKind.Sequential)]
-		struct ssl_st
-		{
-			/* protocol version
-			 * (one of SSL2_VERSION, SSL3_VERSION, TLS1_VERSION, DTLS1_VERSION)
-			 */
-			public int version;
-			public int type; /* SSL_ST_CONNECT or SSL_ST_ACCEPT */
-
-			public IntPtr method;  //SSL_METHOD *method; /* SSLv3 */
-
-			/* There are 2 BIO's even though they are normally both the
-			 * same.  This is so data can be read and written to different
-			 * handlers */
-
-#if ! OPENSSL_NO_BIO
-			public IntPtr rbio;    //BIO *rbio; /* used by SSL_read */
-			public IntPtr wbio;    //BIO *wbio; /* used by SSL_write */
-			public IntPtr bbio;    //BIO *bbio; /* used during session-id reuse to concatenate messages */
-#else
-	        char *rbio; /* used by SSL_read */
-	        char *wbio; /* used by SSL_write */
-	        char *bbio;
-#endif
-			/* This holds a variable that indicates what we were doing
-	         * when a 0 or -1 is returned.  This is needed for
-	         * non-blocking IO so we know what request needs re-doing when
-	         * in SSL_accept or SSL_connect */
-			public int rwstate;
-
-			/* true when we are actually in SSL_accept() or SSL_connect() */
-			public int in_handshake;
-			public IntPtr handshake_func;  //int (*handshake_func)(SSL *);
-
-			/* Imagine that here's a boolean member "init" that is
-			 * switched as soon as SSL_set_{accept/connect}_state
-			 * is called for the first time, so that "state" and
-			 * "handshake_func" are properly initialized.  But as
-			 * handshake_func is == 0 until then, we use this
-			 * test instead of an "init" member.
-			 */
-
-			public int server;	/* are we the server side? - mostly used by SSL_clear*/
-
-			public int new_session;/* 1 if we are to use a new session.
-	                         * 2 if we are a server and are inside a handshake
-	                         *   (i.e. not just sending a HelloRequest)
-	                         * NB: For servers, the 'new' session may actually be a previously
-	                         * cached session or even the previous session unless
-	                         * SSL_OP_NO_SESSION_RESUMPTION_ON_RENEGOTIATION is set */
-			public int quiet_shutdown;/* don't send shutdown packets */
-			public int shutdown;	/* we have shut things down, 0x01 sent, 0x02 for received */
-			public int state;	/* where we are */
-			public int rstate;	/* where we are when reading */
-
-			public IntPtr init_buf;    //BUF_MEM *init_buf;	/* buffer used during init */
-			public IntPtr init_msg;    //void *init_msg;   	/* pointer to handshake message body, set by ssl3_get_message() */
-			public int init_num;		/* amount read/written */
-			public int init_off;		/* amount read/written */
-
-			/* used internally to point at a raw packet */
-			public IntPtr packet;  //unsigned char *packet;
-			public uint packet_length; //unsigned int packet_length;
-
-			public IntPtr s2;  //struct ssl2_state_st *s2; /* SSLv2 variables */
-			public IntPtr s3;  //struct ssl3_state_st *s3; /* SSLv3 variables */
-			public IntPtr d1;  //struct dtls1_state_st *d1; /* DTLSv1 variables */
-
-			public int read_ahead;		/* Read as many input bytes as possible (for non-blocking reads) */
-
-			/* callback that allows applications to peek at protocol messages */
-			public IntPtr msg_callback;    //void (*msg_callback)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg);
-			public IntPtr msg_callback_arg;    //void *msg_callback_arg;
-
-			public int hit;		/* reusing a previous session */
-
-			public IntPtr param;   //X509_VERIFY_PARAM *param;
-
-#if FALSE // #if 0
-	        int purpose;		/* Purpose setting */
-	        int trust;		/* Trust setting */
-#endif
-
-			/* crypto */
-			public IntPtr cipher_list;     //STACK_OF(SSL_CIPHER) *cipher_list;
-			public IntPtr cipher_list_by_id;   //STACK_OF(SSL_CIPHER) *cipher_list_by_id;
-
-			/* These are the ones being used, the ones in SSL_SESSION are
-			 * the ones to be 'copied' into these ones */
-
-			public IntPtr enc_read_ctx;    //EVP_CIPHER_CTX *enc_read_ctx;		/* cryptographic state */
-			public IntPtr read_hash;       //const EVP_MD *read_hash;		/* used for mac generation */
-#if ! OPENSSL_NO_COMP
-			public IntPtr expand;      //COMP_CTX *expand;			/* uncompress */
-#else
-	        char *expand;
-#endif
-
-			public IntPtr enc_write_ctx;   //EVP_CIPHER_CTX *enc_write_ctx;		/* cryptographic state */
-			public IntPtr write_hash;      //const EVP_MD *write_hash;		/* used for mac generation */
-#if ! OPENSSL_NO_COMP
-			public IntPtr compress;    //COMP_CTX *compress;			/* compression */
-#else
-	        char *compress;	
-#endif
-
-			/* session info */
-
-			/* client cert? */
-			/* This is used to hold the server certificate used */
-			public IntPtr cert;    //struct cert_st /* CERT */ *cert;
-
-			/* the session_id_context is used to ensure sessions are only reused
-			 * in the appropriate context */
-			public uint sid_ctx_length;    //unsigned int sid_ctx_length;
-			[MarshalAs(UnmanagedType.ByValArray, SizeConst = Native.SSL_MAX_SID_CTX_LENGTH)]
-			public byte[] sid_ctx;   //unsigned char sid_ctx[SSL_MAX_SID_CTX_LENGTH];
-
-			/* This can also be in the session once a session is established */
-			public IntPtr session;  //SSL_SESSION *session;
-
-			/* Default generate session ID callback. */
-			public IntPtr generate_session_id; //GEN_SESSION_CB generate_session_id;
-
-			/* Used in SSL2 and SSL3 */
-			public int verify_mode;	/* 0 don't care about verify failure.
-				         * 1 fail if verify fails */
-			public IntPtr verify_callback;  //int (*verify_callback)(int ok,X509_STORE_CTX *ctx); /* fail if callback returns 0 */
-
-			public IntPtr info_callback;    //void (*info_callback)(const SSL *ssl,int type,int val); /* optional informational callback */
-
-			public int error;		/* error bytes to be written */
-			public int error_code;		/* actual code */
-
-#if !OPENSSL_NO_KRB5
-			public IntPtr kssl_ctx; //KSSL_CTX *kssl_ctx;     /* Kerberos 5 context */
-#endif	// OPENSSL_NO_KRB5
-
-			public IntPtr ctx;  //SSL_CTX *ctx;
-			/* set this flag to 1 and a sleep(1) is put into all SSL_read()
-			 * and SSL_write() calls, good for nbio debuging :-) */
-			public int debug;
-
-			/* extra application data */
-			public int verify_result;   //long verify_result;
-			//	        CRYPTO_EX_DATA ex_data;
-			#region CRYPTO_EX_DATA ex_data;
-			public IntPtr ex_data_sk;
-			public int ex_data_dummy;
-			#endregion
-
-			/* for server side, keep the list of CA_dn we can use */
-			public IntPtr client_CA;    //STACK_OF(X509_NAME) *client_CA;
-
-			public int references;
-			public uint options; //unsigned long options; /* protocol behaviour */
-			public uint mode;    //unsigned long mode; /* API behaviour */
-			public int max_cert_list;   //long max_cert_list;
-			public int first_packet;
-			public int client_version;	/* what was passed, used for
-				         * SSLv3/TLS rollback check */
-#if ! OPENSSL_NO_TLSEXT
-			/* TLS extension debug callback */
-			public IntPtr tlsext_debug_cb;  //void (*tlsext_debug_cb)(SSL *s, int client_server, int type, unsigned char *data, int len, void *arg);
-			public IntPtr tlsext_debug_arg; //void *tlsext_debug_arg;
-			public IntPtr tlsext_hostname;  //char *tlsext_hostname;
-			public int servername_done;   /* no further mod of servername 
-	                                  0 : call the servername extension callback.
-	                                  1 : prepare 2, allow last ack just after in server callback.
-	                                  2 : don't call servername callback, no ack in server hello
-	                               */
-			/* certificate status request info */
-			/* Status type or -1 if no status type */
-			public int tlsext_status_type;
-			/* Expect OCSP CertificateStatus message */
-			public int tlsext_status_expected;
-			/* OCSP status request only */
-			public IntPtr tlsext_ocsp_ids;  //STACK_OF(OCSP_RESPID) *tlsext_ocsp_ids;
-			public IntPtr tlsext_ocsp_exts; //X509_EXTENSIONS *tlsext_ocsp_exts;
-			/* OCSP response received or to be sent */
-			public IntPtr tlsext_ocsp_resp; //unsigned char *tlsext_ocsp_resp;
-			public int tlsext_ocsp_resplen;
-
-			/* RFC4507 session ticket expected to be received or sent */
-			public int tlsext_ticket_expected;
-			public IntPtr initial_ctx;  //SSL_CTX * initial_ctx; /* initial ctx, used to store sessions */
-#endif //! OPENSSL_NO_TLSEXT
-		}
-
-		#endregion
-
 		#region Initialization
 
 		/// <summary>
@@ -249,166 +61,184 @@
 		/// Calls SSL_new()
 		/// </summary>
 		/// <param name="ctx"></param>
-		public Ssl(SslContext ctx) :
+		internal Ssl(SslContext ctx) :
 			base(Native.ExpectNonNull(Native.SSL_new(ctx.Handle)), true)
-		{ }
+		{
+		}
 
-		internal Ssl(IntPtr ptr, bool takeOwnership)
-			: base(ptr, takeOwnership)
-		{ }
+		internal Ssl(IntPtr ptr, bool takeOwnership) : base(ptr, takeOwnership)
+		{
+		}
 
 		#endregion
 
 		#region Properties
-		public int State
+
+		internal int State
 		{
-			get
-			{
-				int offset = (int)Marshal.OffsetOf(typeof(ssl_st), "state");
-				IntPtr offset_ptr = new IntPtr((int)this.ptr + offset);
-				return Marshal.ReadInt32(offset_ptr);
-			}
-			set
-			{
-				int offset = (int)Marshal.OffsetOf(typeof(ssl_st), "state");
-				IntPtr offset_ptr = new IntPtr((int)this.ptr + offset);
-				Marshal.WriteInt32(offset_ptr, value);
-			}
+			get { return Native.SSL_state(Handle); }
+			set { Native.SSL_set_state(Handle, value); }
 		}
 
+		/// <summary>
+		/// Gets the current cipher.
+		/// </summary>
+		/// <value>The current cipher.</value>
 		public SslCipher CurrentCipher
 		{
-			get { return new SslCipher(Native.SSL_get_current_cipher(this.Handle), false); }
+			get { return new SslCipher(Native.SSL_get_current_cipher(Handle), false); }
 		}
 
-		public Core.Stack<X509Name> CAList
+		internal Core.Stack<X509Name> CAList
 		{
-			get
-			{
-				IntPtr ptr = Native.SSL_get_client_CA_list(this.ptr);
-				Core.Stack<X509Name> name_stack = new Core.Stack<X509Name>(ptr, false);
-				return name_stack;
-			}
-			set
-			{
-				Native.SSL_set_client_CA_list(this.ptr, value.Handle);
-			}
+			get { return new Core.Stack<X509Name>(Native.SSL_get_client_CA_list(ptr), false); }
+			set { Native.SSL_set_client_CA_list(ptr, value.Handle); }
 		}
 
-		public X509Certificate LocalCertificate
+		internal X509Certificate LocalCertificate
 		{
 			get
 			{
-				IntPtr cert = Native.ExpectNonNull(Native.SSL_get_certificate(this.ptr));
+				var cert = Native.SSL_get_certificate(ptr);
+				if (cert == IntPtr.Zero)
+					return null;
 				return new X509Certificate(cert, false);
 			}
 			set
 			{
-				Native.ExpectSuccess(Native.SSL_use_certificate(this.ptr, value.Handle));
+				Native.ExpectSuccess(Native.SSL_use_certificate(ptr, value.Handle));
 			}
 		}
 
-		public X509Certificate RemoteCertificate
+		internal X509Certificate RemoteCertificate
 		{
 			get { return GetPeerCertificate(); }
 		}
 
+		internal Core.Stack<SslCipher> Ciphers
+		{
+			get { return new Core.Stack<SslCipher>(Native.SSL_get_ciphers(Handle), false); }
+		}
+
 		#endregion
 
 		#region Methods
 
-		public int Accept()
+		internal int Accept()
 		{
-			return Native.SSL_accept(this.ptr);
+			return Native.SSL_accept(ptr);
 		}
 
-		public int Connect()
+		internal int Connect()
 		{
-			return Native.SSL_connect(this.ptr);
+			return Native.SSL_connect(ptr);
 		}
 
-		public SslError GetError(int ret_code)
+		internal SslError GetError(int ret_code)
 		{
-			return (SslError)Native.SSL_get_error(this.ptr, ret_code);
+			return (SslError)Native.SSL_get_error(ptr, ret_code);
 		}
 
-		public X509Certificate GetPeerCertificate()
+		internal X509Certificate GetPeerCertificate()
 		{
-			IntPtr cert_ptr = Native.ExpectNonNull(Native.SSL_get_peer_certificate(this.ptr));
-			X509Certificate cert = new X509Certificate(cert_ptr, true);
-			return cert;
+			var cert = Native.SSL_get_peer_certificate(ptr);
+			if (cert == IntPtr.Zero)
+				return null;
+			return new X509Certificate(cert, true);
 		}
 
-		public VerifyResult GetVerifyResult()
+		internal VerifyResult GetVerifyResult()
 		{
-			return (VerifyResult)Native.SSL_get_verify_result(this.ptr);
+			return (VerifyResult)Native.SSL_get_verify_result(ptr);
 		}
 
-		public void SetVerifyResult(VerifyResult result)
+		internal void SetVerifyResult(VerifyResult result)
 		{
-			Native.SSL_set_verify_result(this.ptr, (int)result);
+			Native.SSL_set_verify_result(ptr, (int)result);
 		}
 
-		public int Shutdown()
+		internal int Shutdown()
 		{
-			return Native.SSL_shutdown(this.ptr);
+			return Native.SSL_shutdown(ptr);
 		}
 
-		public int Write(byte[] buf, int len)
+		internal int Write(byte[] buf, int len)
 		{
-			return Native.SSL_write(this.ptr, buf, len);
+			return Native.SSL_write(ptr, buf, len);
 		}
 
-		public int Read(byte[] buf, int len)
+		internal int Read(byte[] buf, int len)
 		{
-			return Native.SSL_read(this.ptr, buf, len);
+			return Native.SSL_read(ptr, buf, len);
 		}
 
-		public int SetSessionIdContext(byte[] sid_ctx, uint sid_ctx_len)
+		internal int SetSessionIdContext(byte[] sid_ctx, uint sid_ctx_len)
 		{
-			return Native.ExpectSuccess(Native.SSL_set_session_id_context(this.ptr, sid_ctx, sid_ctx_len));
+			return Native.ExpectSuccess(Native.SSL_set_session_id_context(ptr, sid_ctx, sid_ctx_len));
 		}
 
-		public int Renegotiate()
+		internal int Renegotiate()
 		{
-			return Native.ExpectSuccess(Native.SSL_renegotiate(this.ptr));
+			return Native.ExpectSuccess(Native.SSL_renegotiate(ptr));
 		}
 
-		public int DoHandshake()
+		internal int DoHandshake()
 		{
-			return Native.SSL_do_handshake(this.ptr);
+			return Native.SSL_do_handshake(ptr);
 		}
 
-		public void SetAcceptState()
+		internal void SetAcceptState()
 		{
-			Native.SSL_set_accept_state(this.ptr);
+			Native.SSL_set_accept_state(ptr);
 		}
 
-		public void SetConnectState()
+		internal void SetConnectState()
 		{
-			Native.SSL_set_connect_state(this.ptr);
+			Native.SSL_set_connect_state(ptr);
 		}
 
-		public void SetBIO(BIO read, BIO write)
+		internal void SetBIO(BIO read, BIO write)
 		{
-			Native.SSL_set_bio(this.ptr, read.Handle, write.Handle);
+			Native.SSL_set_bio(ptr, read.Handle, write.Handle);
 		}
 
-		public int UseCertificateFile(string filename, SslFileType type)
+		internal int UseCertificateFile(string filename, SslFileType type)
 		{
-			return Native.ExpectSuccess(Native.SSL_use_certificate_file(this.ptr, filename, (int)type));
+			return Native.ExpectSuccess(Native.SSL_use_certificate_file(ptr, filename, (int)type));
 		}
 
-		public int UsePrivateKeyFile(string filename, SslFileType type)
+		internal int UsePrivateKeyFile(string filename, SslFileType type)
 		{
-			return Native.ExpectSuccess(Native.SSL_use_PrivateKey_file(this.ptr, filename, (int)type));
+			return Native.ExpectSuccess(Native.SSL_use_PrivateKey_file(ptr, filename, (int)type));
 		}
 
-		public int Clear()
+		internal int Clear()
 		{
-			return Native.ExpectSuccess(Native.SSL_clear(this.ptr));
+			return Native.ExpectSuccess(Native.SSL_clear(ptr));
 		}
 
+		/// <summary>
+		/// Gets the alpn selected protocol.
+		/// </summary>
+		/// <value>The alpn selected protocol.</value>
+		public string AlpnSelectedProtocol
+		{
+			get
+			{
+				var ptr = new IntPtr();
+				var len = 0;
+
+				Native.SSL_get0_alpn_selected(Handle, out ptr, out len);
+
+				if (ptr == IntPtr.Zero)
+					throw new AlpnException("Cant get selected protocol. See if ALPN was included into client/server hello");
+
+				var buf = new byte[len];
+				Marshal.Copy(ptr, buf, 0, len);
+				return Encoding.ASCII.GetString(buf, 0, len);
+			}
+		}
+
 		#endregion
 
 		#region Overrides
@@ -418,7 +248,7 @@
 		/// </summary>
 		protected override void OnDispose()
 		{
-			Native.SSL_free(this.Handle);
+			Native.SSL_free(Handle);
 		}
 
 		#endregion
Index: ManagedOpenSsl/SSL/SslCipher.cs
===================================================================
--- ManagedOpenSsl/SSL/SslCipher.cs	(revision 47839)
+++ ManagedOpenSsl/SSL/SslCipher.cs	(revision 47851)
@@ -23,428 +23,133 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
 using System;
+using System.Runtime.InteropServices;
+using System.Text;
 using System.Collections.Generic;
-using System.Text;
-using System.Runtime.InteropServices;
-using OpenSSL.Core;
 
 namespace OpenSSL.SSL
 {
-	class SslCipher : Base, IStackable
+	/// <summary>
+	/// Wraps a SSL_CIPHER
+	/// </summary>
+	public class SslCipher : BaseReference, IStackable
 	{
-		#region SSL_CIPHER
-		[StructLayout(LayoutKind.Sequential)]
-		struct SSL_CIPHER
-		{
-			public int valid;
-			public IntPtr name; // text name
-			public uint id; // id, 4 bytes, first is version
-			public uint algorithms; // what ciphers are used
-			public uint algo_strength; // strength and export flags
-			public uint algorithm2; // extra flags
-			public int strength_bits; // number of bits really used
-			public int alg_bits; // number of bits for algorithm
-			public uint mask; // used for matching
-			public uint mask_strength; // also used for matching
-		}
-		#endregion
-
-		bool isInitialized = false;
-		private SSL_CIPHER raw;
-		private CipherAlgorithmType cipherAlgorithm = CipherAlgorithmType.None;
-		private int cipherStrength = 0;
-		private HashAlgorithmType hashAlgorithm = HashAlgorithmType.None;
-		private ExchangeAlgorithmType keyExchangeAlgorithm = ExchangeAlgorithmType.None;
-		private AuthenticationMethod authMethod = AuthenticationMethod.None;
-		private int keyExchangeStrength = 0;
-		private SslProtocols sslProtocol = SslProtocols.None;
-
+		/// <summary>
+		/// Initializes a new instance of the <see cref="OpenSSL.SSL.SslCipher"/> class.
+		/// </summary>
 		public SslCipher() :
 			this(IntPtr.Zero, false)
 		{
 		}
 
+		/// <summary>
+		/// Initializes a new instance of the <see cref="OpenSSL.SSL.SslCipher"/> class.
+		/// </summary>
+		/// <param name="ptr">Ptr.</param>
+		/// <param name="owner">If set to <c>true</c> owner.</param>
 		public SslCipher(IntPtr ptr, bool owner) :
 			base(ptr, owner)
 		{
-			Initialize();
 		}
 
 		internal SslCipher(IStack stack, IntPtr ptr) :
 			base(ptr, true)
 		{
-			Initialize();
 		}
 
 		/// <summary>
-		/// Returns SSL_CIPHER_name()
+		/// see https://www.openssl.org/docs/apps/ciphers.html
+		/// for details about OpenSSL cipher string
 		/// </summary>
-		public string Name
+		/// <returns>The string.</returns>
+		/// <param name="sslProtocols">SSL protocols.</param>
+		/// <param name="sslStrength">SSL strength.</param>
+		public static string MakeString(SslProtocols sslProtocols, SslStrength sslStrength)
 		{
-			get { return Native.SSL_CIPHER_name(this.ptr); }
-		}
+			var parts = new List<string>();
 
-		/// <summary>
-		/// Returns SSL_CIPHER_description()
-		/// </summary>
-		public string Description
-		{
-			get
+			if (EnumExtensions.HasFlag(sslStrength, SslStrength.High))
 			{
-				byte[] buf = new byte[512];
-				Native.SSL_CIPHER_description(this.ptr, buf, buf.Length);
-				string ret = Encoding.ASCII.GetString(buf);
-				return ret;
+				parts.Add("HIGH");
 			}
-		}
 
-		/// <summary>
-		/// Returns SSL_CIPHER_get_bits()
-		/// </summary>
-		public int Strength
-		{
-			get
+			if (EnumExtensions.HasFlag(sslStrength, SslStrength.Medium))
 			{
-				Initialize();
-				if (cipherStrength == 0)
-				{
-					int nAlgBits = 0;
-					return Native.SSL_CIPHER_get_bits(this.Handle, out nAlgBits);
-				}
-				return cipherStrength;
+				parts.Add("MEDIUM");
 			}
-		}
 
-		public const int SSL_EXPORT = 0x00000002;
-		public const int SSL_EXP40 = 0x00000008;
-		public const int SSL_EXP56 = 0x00000010;
-
-		private bool IsExport(uint algo_strength)
-		{
-			return (algo_strength & SSL_EXPORT) > 0;
-		}
-
-		private int ExportPrivateKeyLength(uint algo_strength)
-		{
-			if ((algo_strength & SSL_EXP40) > 0)
+			if (EnumExtensions.HasFlag(sslStrength, SslStrength.Low))
 			{
-				return 512;
+				parts.Add("LOW");
 			}
-			return 1024;
-		}
 
-		private int ExportKeyLength(uint algorithms, uint algo_strength)
-		{
-			if ((algo_strength & SSL_EXP40) > 0)
+			if ((sslProtocols == SslProtocols.Default) ||
+				(sslProtocols == SslProtocols.Tls) ||
+				(sslProtocols == SslProtocols.Ssl3))
 			{
-				return 5;
+				parts.Add("!SSLv2");
 			}
-			else
-			{
-				if ((algorithms & SSL_ENC_MASK) == SSL_DES)
-				{
-					return 8;
-				}
-				return 7;
-			}
-		}
 
-		public const int SSL_MKEY_MASK = 0x000000FF;
-		public const int SSL_kRSA = 0x00000001; /* RSA key exchange */
-		public const int SSL_kDHr = 0x00000002; /* DH cert RSA CA cert */
-		public const int SSL_kDHd = 0x00000004; /* DH cert DSA CA cert */
-		public const int SSL_kFZA = 0x00000008;
-		public const int SSL_kEDH = 0x00000010; /* tmp DH key no DH cert */
-		public const int SSL_kKRB5 = 0x00000020; /* Kerberos5 key exchange */
-		public const int SSL_kECDH = 0x00000040; /* ECDH w/ long-term keys */
-		public const int SSL_kECDHE = 0x00000080; /* ephemeral ECDH */
-		public const int SSL_EDH = (SSL_kEDH | (SSL_AUTH_MASK ^ SSL_aNULL));
+			parts.Add("!ADH");
+			parts.Add("!aNULL");
+			parts.Add("!eNULL");
+			parts.Add("@STRENGTH");
 
-		public const int SSL_AUTH_MASK = 0x00007F00;
-		public const int SSL_aRSA = 0x00000100; /* Authenticate with RSA */
-		public const int SSL_aDSS = 0x00000200; /* Authenticate with DSS */
-		public const int SSL_DSS = SSL_aDSS;
-		public const int SSL_aFZA = 0x00000400;
-		public const int SSL_aNULL = 0x00000800; /* no Authenticate, ADH */
-		public const int SSL_aDH = 0x00001000; /* no Authenticate, ADH */
-		public const int SSL_aKRB5 = 0x00002000; /* Authenticate with KRB5 */
-		public const int SSL_aECDSA = 0x00004000; /* Authenticate with ECDSA */
-
-		public const int SSL_NULL = (SSL_eNULL);
-		public const int SSL_ADH = (SSL_kEDH | SSL_aNULL);
-		public const int SSL_RSA = (SSL_kRSA | SSL_aRSA);
-		public const int SSL_DH = (SSL_kDHr | SSL_kDHd | SSL_kEDH);
-		public const int SSL_ECDH = (SSL_kECDH | SSL_kECDHE);
-		public const int SSL_FZA = (SSL_aFZA | SSL_kFZA | SSL_eFZA);
-		public const int SSL_KRB5 = (SSL_kKRB5 | SSL_aKRB5);
-
-		public const int SSL_ENC_MASK = 0x1C3F8000;
-		public const int SSL_DES = 0x00008000;
-		public const int SSL_3DES = 0x00010000;
-		public const int SSL_RC4 = 0x00020000;
-		public const int SSL_RC2 = 0x00040000;
-		public const int SSL_IDEA = 0x00080000;
-		public const int SSL_eFZA = 0x00100000;
-		public const int SSL_eNULL = 0x00200000;
-		public const int SSL_AES = 0x04000000;
-		public const int SSL_CAMELLIA = 0x08000000;
-		public const int SSL_SEED = 0x10000000;
-
-		public const int SSL_MAC_MASK = 0x00c00000;
-		public const int SSL_MD5 = 0x00400000;
-		public const int SSL_SHA1 = 0x00800000;
-		public const int SSL_SHA = (SSL_SHA1);
-
-		public const int SSL_SSL_MASK = 0x03000000;
-		public const int SSL_SSLV2 = 0x01000000;
-		public const int SSL_SSLV3 = 0x02000000;
-		public const int SSL_TLSV1 = SSL_SSLV3;	/* for now */
-
-		/* Flags for the SSL_CIPHER.algorithm2 field */
-		public const int SSL2_CF_5_BYTE_ENC = 0x01;
-		public const int SSL2_CF_8_BYTE_ENC = 0x02;
-
-		private void Initialize()
-		{
-			if (this.ptr == IntPtr.Zero || isInitialized)
-			{
-				return;
-			}
-
-			isInitialized = true;
-
-			// marshal the structure
-			raw = (SSL_CIPHER)Marshal.PtrToStructure(ptr, typeof(SSL_CIPHER));
-			// start picking the data out
-			bool isExport = IsExport(raw.algo_strength);
-			int privateKeyLength = ExportPrivateKeyLength(raw.algo_strength);
-			int keyLength = ExportKeyLength(raw.algorithms, raw.algo_strength);
-
-			// Get the SSL Protocol version
-			if ((raw.algorithms & SSL_SSLV2) == SSL_SSLV2)
-			{
-				sslProtocol = SslProtocols.Ssl2;
-			}
-			else if ((raw.algorithms & SSL_SSLV3) == SSL_SSLV3)
-			{
-				sslProtocol = SslProtocols.Tls; // SSL3 & TLS are the same here...
-			}
-
-			// set the keyExchange strength
-			keyExchangeStrength = privateKeyLength;
-
-			// Get the Key Exchange cipher and strength
-			switch (raw.algorithms & SSL_MKEY_MASK)
-			{
-				case SSL_kRSA:
-					keyExchangeAlgorithm = ExchangeAlgorithmType.RsaKeyX;
-					break;
-				case SSL_kDHr:
-				case SSL_kDHd:
-				case SSL_kEDH:
-					keyExchangeAlgorithm = ExchangeAlgorithmType.DiffieHellman;
-					break;
-				case SSL_kKRB5:         /* VRS */
-				case SSL_KRB5:          /* VRS */
-					keyExchangeAlgorithm = ExchangeAlgorithmType.Kerberos;
-					break;
-				case SSL_kFZA:
-					keyExchangeAlgorithm = ExchangeAlgorithmType.Fortezza;
-					break;
-				case SSL_kECDH:
-				case SSL_kECDHE:
-					keyExchangeAlgorithm = ExchangeAlgorithmType.ECDiffieHellman;
-					break;
-			}
-
-			// Get the authentication method
-			switch (raw.algorithms & SSL_AUTH_MASK)
-			{
-				case SSL_aRSA:
-					authMethod = AuthenticationMethod.Rsa;
-					break;
-				case SSL_aDSS:
-					authMethod = AuthenticationMethod.Dss;
-					break;
-				case SSL_aDH:
-					authMethod = AuthenticationMethod.DiffieHellman;
-					break;
-				case SSL_aKRB5:         /* VRS */
-				case SSL_KRB5:          /* VRS */
-					authMethod = AuthenticationMethod.Kerberos;
-					break;
-				case SSL_aFZA:
-				case SSL_aNULL:
-					authMethod = AuthenticationMethod.None;
-					break;
-				case SSL_aECDSA:
-					authMethod = AuthenticationMethod.ECDsa;
-					break;
-			}
-			// Get the symmetric encryption cipher info
-			switch (raw.algorithms & SSL_ENC_MASK)
-			{
-				case SSL_DES:
-					cipherAlgorithm = CipherAlgorithmType.Des;
-					if (isExport && keyLength == 5)
-					{
-						cipherStrength = 40;
-					}
-					else
-					{
-						cipherStrength = 56;
-					}
-					break;
-				case SSL_3DES:
-					cipherAlgorithm = CipherAlgorithmType.TripleDes;
-					cipherStrength = 168;
-					break;
-				case SSL_RC4:
-					cipherAlgorithm = CipherAlgorithmType.Rc4;
-					if (isExport)
-					{
-						if (keyLength == 5)
-						{
-							cipherStrength = 40;
-						}
-						else
-						{
-							cipherStrength = 56;
-						}
-					}
-					else
-					{
-						if ((raw.algorithm2 & SSL2_CF_8_BYTE_ENC) == SSL2_CF_8_BYTE_ENC)
-						{
-							cipherStrength = 64;
-						}
-						else
-						{
-							cipherStrength = 128;
-						}
-					}
-					break;
-				case SSL_RC2:
-					cipherAlgorithm = CipherAlgorithmType.Rc2;
-					if (isExport)
-					{
-						if (keyLength == 5)
-						{
-							cipherStrength = 40;
-						}
-						else
-						{
-							cipherStrength = 56;
-						}
-					}
-					else
-					{
-						cipherStrength = 128;
-					}
-					break;
-				case SSL_IDEA:
-					cipherAlgorithm = CipherAlgorithmType.Idea;
-					cipherStrength = 128;
-					break;
-				case SSL_eFZA:
-					cipherAlgorithm = CipherAlgorithmType.Fortezza;
-					break;
-				case SSL_eNULL:
-					cipherAlgorithm = CipherAlgorithmType.None;
-					break;
-				case SSL_AES:
-					switch (raw.strength_bits)
-					{
-						case 128: cipherAlgorithm = CipherAlgorithmType.Aes128; break;
-						case 192: cipherAlgorithm = CipherAlgorithmType.Aes192; break;
-						case 256: cipherAlgorithm = CipherAlgorithmType.Aes256; break;
-					}
-					break;
-				case SSL_CAMELLIA:
-					switch (raw.strength_bits)
-					{
-						case 128: cipherAlgorithm = CipherAlgorithmType.Camellia128; break;
-						case 256: cipherAlgorithm = CipherAlgorithmType.Camellia256; break;
-					}
-					break;
-				case SSL_SEED:
-					cipherAlgorithm = CipherAlgorithmType.Seed;
-					cipherStrength = 128;
-					break;
-			}
-			// Get the MAC info
-			switch (raw.algorithms & SSL_MAC_MASK)
-			{
-				case SSL_MD5:
-					hashAlgorithm = HashAlgorithmType.Md5;
-					break;
-				case SSL_SHA1:
-					hashAlgorithm = HashAlgorithmType.Sha1;
-					break;
-				default:
-					hashAlgorithm = HashAlgorithmType.None;
-					break;
-			}
+			return string.Join(":", parts.ToArray());
 		}
 
-		public CipherAlgorithmType CipherAlgorithm
+		/// <summary>
+		/// Returns SSL_CIPHER_get_name()
+		/// </summary>
+		public string Name
 		{
-			get
-			{
-				Initialize();
-				return cipherAlgorithm;
-			}
+			get { return Native.StaticString(Native.SSL_CIPHER_get_name(Handle)); }
 		}
 
-		public HashAlgorithmType HashAlgorithm
+		/// <summary>
+		/// Returns SSL_CIPHER_description()
+		/// </summary>
+		public string Description
 		{
-			get
-			{
-				Initialize();
-				return hashAlgorithm;
-			}
+			get { return Native.SSL_CIPHER_description(Handle, null, 0); }
 		}
 
-		public ExchangeAlgorithmType KeyExchangeAlgorithm
+		/// <summary>
+		/// Returns SSL_CIPHER_get_version()
+		/// </summary>
+		/// <value>The version.</value>
+		public string Version
 		{
-			get
-			{
-				Initialize();
-				return keyExchangeAlgorithm;
-			}
+			get { return Native.StaticString(Native.SSL_CIPHER_get_version(Handle)); }
 		}
 
-		public int KeyExchangeStrength
+		/// <summary>
+		/// Returns SSL_CIPHER_get_bits()
+		/// </summary>
+		public int Bits
 		{
 			get
 			{
-				Initialize();
-				return keyExchangeStrength;
+				var alg_bits = 0;
+				return Native.SSL_CIPHER_get_bits(Handle, out alg_bits);
 			}
 		}
 
-		public SslProtocols SslProtocol
+		internal override void AddRef()
 		{
-			get
-			{
-				Initialize();
-				return sslProtocol;
-			}
+			// SSL_CIPHERs come from a static list in ssl_ciph.c
+			// nothing to do here
 		}
 
-		public AuthenticationMethod AuthenticateionMethod
-		{
-			get
-			{
-				Initialize();
-				return authMethod;
-			}
-		}
-
+		/// <summary>
+		/// This method must be implemented in derived classes.
+		/// </summary>
 		protected override void OnDispose()
 		{
-			Native.OPENSSL_free(this.ptr);
+			// SSL_CIPHERs come from a static list in ssl_ciph.c
+			// nothing to do here
 		}
 	}
 }
Index: ManagedOpenSsl/SSL/SslContext.cs
===================================================================
--- ManagedOpenSsl/SSL/SslContext.cs	(revision 47839)
+++ ManagedOpenSsl/SSL/SslContext.cs	(revision 47851)
@@ -23,420 +23,255 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
+using OpenSSL.Crypto;
+using OpenSSL.X509;
 using System;
 using System.Collections.Generic;
-using System.Text;
 using System.Runtime.InteropServices;
-using OpenSSL.Core;
-using OpenSSL.Crypto;
-using OpenSSL.X509;
+using OpenSSL.Extensions;
 
 namespace OpenSSL.SSL
 {
-	delegate int ClientCertCallbackHandler(Ssl ssl, out X509Certificate cert, out CryptoKey key);
+	internal delegate int ClientCertCallbackHandler(
+		Ssl ssl, 
+		out X509Certificate cert, 
+		out CryptoKey key
+	);
 
 	/// <summary>
-	/// Wraps the SST_CTX structure and methods
+	///     Wraps the SST_CTX structure and methods
 	/// </summary>
-	internal class SslContext : Base, IDisposable
+	internal sealed class SslContext : Base
 	{
-		#region SSL_CTX
-		[StructLayout(LayoutKind.Sequential)]
-		private struct SSL_CTX
-		{
-			public IntPtr method; //SSL_METHOD
-			public IntPtr cipher_list;  // STACK_OF(SSL_CIPHER)
-			public IntPtr cipher_list_by_id; // STACK_OF(SSL_CIPHER)
-			public IntPtr cert_store; //X509_STORE
-			public IntPtr sessions; //lhash_st of SSL_SESSION
-			public int session_cache_size;
-			public IntPtr session_cache_head; //ssl_session_st
-			public IntPtr session_cache_tail; // ssl_session_st
-			public int session_cache_mode;
-			public int session_timeout;
-			public IntPtr new_session_cb; // int (*new_session_cb)(SSL*, SSL_SESSION*)
-			public IntPtr remove_session_cb; // void (*remove_session_cb)(SSL*,SSL_SESSION*)
-			public IntPtr get_session_cb; // SSL_SESSION*(*get_session_cb)(SSL*, uchar* data, int len, int* copy)
-			#region stats
-			public int stats_sess_connect;	/* SSL new conn - started */
-			public int stats_sess_connect_renegotiate;/* SSL reneg - requested */
-			public int stats_sess_connect_good;	/* SSL new conne/reneg - finished */
-			public int stats_sess_accept;	/* SSL new accept - started */
-			public int stats_sess_accept_renegotiate;/* SSL reneg - requested */
-			public int stats_sess_accept_good;	/* SSL accept/reneg - finished */
-			public int stats_sess_miss;		/* session lookup misses  */
-			public int stats_sess_timeout;	/* reuse attempt on timeouted session */
-			public int stats_sess_cache_full;	/* session removed due to full cache */
-			public int stats_sess_hit;		/* session reuse actually done */
-			public int stats_sess_cb_hit;	/* session-id that was not in the cache was passed back via the callback.  This
-					         * indicates that the application is supplying session-id's from other processes - spooky :-) */
-			#endregion
-			public int references;
-			public IntPtr app_verify_callback; //int (*app_verify_callback)(X509_STORE_CTX *, void *)
-			public IntPtr app_verify_arg;
-			public IntPtr default_passwd_callback; //pem_password_cb
-			public IntPtr default_passwd_callback_userdata;
-			public IntPtr client_cert_cb; //int (*client_cert_cb)(SSL *ssl, X509 **x509, EVP_PKEY **pkey)
-			public IntPtr app_gen_cookie_cb; //int (*app_gen_cookie_cb)(SSL *ssl, unsigned char *cookie, unsigned int *cookie_len);
-			public IntPtr app_verify_cookie_cb; //int (*app_verify_cookie_cb)(SSL *ssl, unsigned char *cookie, unsigned int cookie_len); 
-			#region CRYPTO_EX_DATA ex_data;
-			public IntPtr ex_data_sk;
-			public int ex_data_dummy;
-			#endregion
-			public IntPtr rsa_md5; //EVP_MD
-			public IntPtr md5; //EVP_MD
-			public IntPtr sha1; //EVP_MD
-			public IntPtr extra_certs; //STACK_OF(X509)
-			public IntPtr comp_methods; //STACK_OF(SSL_COMP)
-			public IntPtr info_callback; //void (*info_callback)(const SSL *ssl,int type,int val)
-			public IntPtr client_CA; //STACK_OF(X509_NAME)
-			public uint options;
-			public uint mode;
-			public int max_cert_list;
-			public IntPtr cert; //cert_st
-			public int read_ahead;
-			public IntPtr msg_callback; //void (*msg_callback)(int write_p, int version, int content_type, const void *buf, size_t len, SSL *ssl, void *arg);
-			public IntPtr msg_callback_arg;
-			public int verify_mode;
-			public uint sid_ctx_length;
-			[MarshalAs(UnmanagedType.ByValArray, SizeConst = Native.SSL_MAX_SID_CTX_LENGTH)]
-			public byte[] sid_ctx;
-			public IntPtr default_verify_callback; //int (*default_verify_callback)(int ok,X509_STORE_CTX *ctx)
-			public IntPtr generate_session_id; //typedef int (*GEN_SESSION_CB)(const SSL *ssl, unsigned char *id,unsigned int *id_len);
-			#region X509_VERIFY_PARAM
-			public IntPtr x509_verify_param_name;
-			public long x509_verify_param_check_time;
-			public int x509_verify_param_inh_flags;
-			public int x509_verify_param_flags;
-			public int x509_verify_param_purpose;
-			public int x509_verify_param_trust;
-			public int x509_verify_param_depth;
-			public IntPtr x509_verify_param_policies;
-			#endregion
-#if __UNUSED__
-	            int purpose;		/* Purpose setting */
-	            int trust;		/* Trust setting */
-#endif
-			public int quiet_shutdown;
-			//#if (! OPENSSL_ENGINE)
-			// Engine to pass requests for client certs to
-			public IntPtr client_cert_engine;
-			//#endif
-			//#if (! OPENSSL_NO_TLSEXT)
-			public IntPtr tlsext_servername_callback; //int (*tlsext_servername_callback)(SSL*, int *, void *)
-			public IntPtr tlsext_servername_arg;
-			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
-			public byte[] tlsext_tick_key_name;
-			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
-			public byte[] tlsext_tick_hmac_key;
-			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 16)]
-			public byte[] tlsext_tick_aes_key;
-			public IntPtr tlsext_ticket_key_cb; //int (*tlsext_ticket_key_cb)(SSL *ssl,unsigned char *name, unsigned char *iv,EVP_CIPHER_CTX *ectx,HMAC_CTX *hctx, int enc);
-			public IntPtr tlsext_status_cb; //int (*tlsext_status_cb)(SSL *ssl, void *arg);
-			public IntPtr tlsext_status_arg;
-			//#endif
-		}
-		#endregion
-
 		#region Members
 
-		//private SSL_CTX raw;
-		private VerifyCertCallbackThunk _verifyCertCallbackThunk;
-		private ClientCertCallbackThunk _clientCertCallbackThunk;
+		private AlpnExtension alpnExt;
+		private ClientCertCallbackHandler OnClientCert;
+		private RemoteCertificateValidationHandler OnVerifyCert;
+
+		// hold down the thunk so it doesn't get collected
+		private Native.client_cert_cb _ptrOnClientCertThunk;
+		private Native.VerifyCertCallback _ptrOnVerifyCertThunk;
+		private Native.alpn_cb _ptrOnAlpn;
+
 		#endregion
 
+
 		/// <summary>
-		/// Calls SSL_CTX_new()
+		///     Calls SSL_CTX_new()
 		/// </summary>
 		/// <param name="sslMethod"></param>
-		public SslContext(SslMethod sslMethod) :
+		/// <param name="end"></param>
+		/// <param name="protoList"></param>
+		public SslContext(
+			SslMethod sslMethod,
+			ConnectionEnd end,
+			IEnumerable<string> protoList) :
 			base(Native.ExpectNonNull(Native.SSL_CTX_new(sslMethod.Handle)), true)
 		{
+			alpnExt = new AlpnExtension(Handle, protoList);
+
+			_ptrOnClientCertThunk = OnClientCertThunk;
+			_ptrOnVerifyCertThunk = OnVerifyCertThunk;
+			_ptrOnAlpn = alpnExt.AlpnCb;
+
+			if (end == ConnectionEnd.Server)
+			{
+				Native.SSL_CTX_set_alpn_select_cb(Handle, _ptrOnAlpn, IntPtr.Zero);
+			}
 		}
 
 		#region Properties
 
 		/// <summary>
-		/// Calls SSL_CTX_set_options
+		///     Calls SSL_CTX_set_options
 		/// </summary>
 		public SslOptions Options
 		{
-			set { Native.ExpectSuccess(Native.SSL_CTX_set_options(this.ptr, (int)value)); }
-			get { return (SslOptions)Native.SSL_CTX_get_options(this.ptr); }
+			set { Native.ExpectSuccess(Native.SSL_CTX_set_options(ptr, (int)value)); }
+			get { return (SslOptions)Native.SSL_CTX_get_options(ptr); }
 		}
 
 		public SslMode Mode
 		{
-			set { Native.ExpectSuccess(Native.SSL_CTX_set_mode(this.ptr, (int)value)); }
-			get { return (SslMode)Native.SSL_CTX_get_mode(this.ptr); }
+			set { Native.ExpectSuccess(Native.SSL_CTX_set_mode(ptr, (int)value)); }
+			get { return (SslMode)Native.SSL_CTX_get_mode(ptr); }
 		}
 
 		#endregion
 
-		internal class ClientCertCallbackThunk
+		private int OnVerifyCertThunk(int ok, IntPtr store)
 		{
-			private ClientCertCallbackHandler OnClientCertCallback;
-			private Native.client_cert_cb nativeCallback;
+			var ctx = new X509StoreContext(store, false);
 
-			public Native.client_cert_cb Callback
+			// build the X509Chain from the store
+			using (var chain = new X509Chain())
 			{
-				get
+				foreach (var obj in ctx.Store.Objects)
 				{
-					if (this.OnClientCertCallback == null)
-					{
-						return null;
-					}
-					if (this.nativeCallback != null)
-					{
-						return this.nativeCallback;
-					}
-					else
-					{
-						this.nativeCallback = new Native.client_cert_cb(this.OnClientCertThunk);
-						return this.nativeCallback;
-					}
+					var cert = obj.Certificate;
+					if (cert != null)
+						chain.Add(cert);
 				}
-			}
 
-			public ClientCertCallbackThunk(ClientCertCallbackHandler callback)
-			{
-				this.OnClientCertCallback = callback;
+				// Call the managed delegate
+				return OnVerifyCert(
+					this, 
+					ctx.CurrentCert, 
+					chain, 
+					ctx.ErrorDepth, 
+					(VerifyResult)ctx.Error
+				) ? 1 : 0;
 			}
-
-			internal int OnClientCertThunk(IntPtr ssl_ptr, out IntPtr cert_ptr, out IntPtr key_ptr)
-			{
-				X509Certificate cert = null;
-				CryptoKey key = null;
-				Ssl ssl = new Ssl(ssl_ptr, false);
-				cert_ptr = IntPtr.Zero;
-				key_ptr = IntPtr.Zero;
-
-				int nRet = OnClientCertCallback(ssl, out cert, out key);
-				if (nRet != 0)
-				{
-					if (cert != null)
-					{
-						cert_ptr = cert.Handle;
-					}
-					if (key != null)
-					{
-						key_ptr = key.Handle;
-					}
-				}
-				return nRet;
-			}
-
 		}
 
-		internal class VerifyCertCallbackThunk
+		private int OnClientCertThunk(IntPtr ptrSsl, out IntPtr ptrCert, out IntPtr ptrKey)
 		{
-			private RemoteCertificateValidationHandler OnVerifyCert;
-			private Native.VerifyCertCallback nativeCallback;
+			ptrCert = IntPtr.Zero;
+			ptrKey = IntPtr.Zero;
 
-			public Native.VerifyCertCallback Callback
-			{
-				get
-				{
-					if (this.OnVerifyCert == null)
-					{
-						return null;
-					}
-					if (this.nativeCallback != null)
-					{
-						return this.nativeCallback;
-					}
-					else
-					{
-						this.nativeCallback = new Native.VerifyCertCallback(OnVerifyCertThunk);
-						return this.nativeCallback;
-					}
-				}
-			}
+			var ssl = new Ssl(ptrSsl, false);
+			X509Certificate cert;
+			CryptoKey key;
 
-			public VerifyCertCallbackThunk(RemoteCertificateValidationHandler callback)
+			var ret = OnClientCert(ssl, out cert, out key);
+			if (ret != 0)
 			{
-				this.OnVerifyCert = callback;
-			}
+				if (cert != null)
+					ptrCert = cert.Handle;
 
-			internal int OnVerifyCertThunk(int ok, IntPtr store_ctx)
-			{
-				X509StoreContext ctx = new X509StoreContext(store_ctx, false);
-				X509Certificate cert = ctx.CurrentCert;
-				int depth = ctx.ErrorDepth;
-				VerifyResult result = (VerifyResult)ctx.Error;
-				// build the X509Chain from the store
-				X509Store store = ctx.Store;
-				Core.Stack<X509Object> objStack = store.Objects;
-				X509Chain chain = new X509Chain();
-				foreach (X509Object obj in objStack)
-				{
-					X509Certificate objCert = obj.Certificate;
-					if (objCert != null)
-					{
-						chain.Add(objCert);
-					}
-				}
-				// Call the managed delegate
-				if (OnVerifyCert(this, cert, chain, depth, result))
-				{
-					return 1;
-				}
-				else
-				{
-					return 0;
-				}
+				if (key != null)
+					ptrKey = key.Handle;
 			}
+			return ret;
 		}
 
 		#region Methods
 
 		/// <summary>
-		/// Sets the certificate store for the context - calls SSL_CTX_set_cert_store
-		/// The X509Store object and contents will be freed when the context is disposed.
-		/// Ensure that the store object and it's contents have IsOwner set to false
-		/// before assigning them into the context.
+		///     Sets the certificate store for the context - calls SSL_CTX_set_cert_store
+		///     The X509Store object and contents will be freed when the context is disposed.
+		///     Ensure that the store object and it's contents have IsOwner set to false
+		///     before assigning them into the context.
 		/// </summary>
 		/// <param name="store"></param>
 		public void SetCertificateStore(X509Store store)
 		{
-			// Remove the native pointer ownership from the object
-			// Reference counts don't work for the X509_STORE, so
-			// we just remove ownership from the X509Store object
-			store.IsOwner = false;
-			Native.SSL_CTX_set_cert_store(this.ptr, store.Handle);
+			store.AddRef();
+			Native.SSL_CTX_set_cert_store(ptr, store.Handle);
 		}
 
 		/// <summary>
-		/// Sets the certificate verification mode and callback - calls SSL_CTX_set_verify
+		///     Sets the certificate verification mode and callback - calls SSL_CTX_set_verify
 		/// </summary>
 		/// <param name="mode"></param>
 		/// <param name="callback"></param>
 		public void SetVerify(VerifyMode mode, RemoteCertificateValidationHandler callback)
 		{
-			this._verifyCertCallbackThunk = new VerifyCertCallbackThunk(callback);
-			Native.SSL_CTX_set_verify(this.ptr, (int)mode, _verifyCertCallbackThunk.Callback);
+			OnVerifyCert = callback;
+			Native.SSL_CTX_set_verify(ptr, (int)mode, callback == null ? null : _ptrOnVerifyCertThunk);
 		}
 
 		/// <summary>
-		/// Sets the certificate verification depth - calls SSL_CTX_set_verify_depth
+		///     Sets the certificate verification depth - calls SSL_CTX_set_verify_depth
 		/// </summary>
 		/// <param name="depth"></param>
 		public void SetVerifyDepth(int depth)
 		{
-			Native.SSL_CTX_set_verify_depth(this.ptr, depth);
+			Native.SSL_CTX_set_verify_depth(ptr, depth);
 		}
 
 		public Core.Stack<X509Name> LoadClientCAFile(string filename)
 		{
-			IntPtr stack = Native.SSL_load_client_CA_file(filename);
-			Core.Stack<X509Name> name_stack = new Core.Stack<X509Name>(stack, true);
-			return name_stack;
+			var stack = Native.SSL_load_client_CA_file(filename);
+			return new Core.Stack<X509Name>(stack, true);
 		}
 
 		/// <summary>
-		/// Calls SSL_CTX_set_client_CA_list/SSL_CTX_get_client_CA_list
-		/// The Stack and the X509Name objects contined within them
-		/// are freed when the context is disposed.  Make sure that
-		/// the Stack and X509Name objects have set IsOwner to false
-		/// before assigning them to the context.
+		///     Calls SSL_CTX_set_client_CA_list/SSL_CTX_get_client_CA_list
+		///     The Stack and the X509Name objects contined within them
+		///     are freed when the context is disposed.  Make sure that
+		///     the Stack and X509Name objects have set IsOwner to false
+		///     before assigning them to the context.
 		/// </summary>
 		public Core.Stack<X509Name> CAList
 		{
 			get
 			{
-				IntPtr ptr = Native.SSL_CTX_get_client_CA_list(this.ptr);
-				Core.Stack<X509Name> name_stack = new Core.Stack<X509Name>(ptr, false);
-				return name_stack;
+				var ptr = Native.SSL_CTX_get_client_CA_list(this.ptr);
+				return new Core.Stack<X509Name>(ptr, false);
 			}
 			set
 			{
-				// Remove the native pointer ownership from the Stack object
-				value.IsOwner = false;
-				Native.SSL_CTX_set_client_CA_list(this.ptr, value.Handle);
+				value.AddRef();
+				Native.SSL_CTX_set_client_CA_list(ptr, value.Handle);
 			}
 		}
 
 		public int LoadVerifyLocations(string caFile, string caPath)
 		{
-			return Native.ExpectSuccess(Native.SSL_CTX_load_verify_locations(this.ptr, caFile, caPath));
+			return Native.ExpectSuccess(Native.SSL_CTX_load_verify_locations(ptr, caFile, caPath));
 		}
 
 		public int SetDefaultVerifyPaths()
 		{
-			return Native.ExpectSuccess(Native.SSL_CTX_set_default_verify_paths(this.ptr));
+			return Native.ExpectSuccess(Native.SSL_CTX_set_default_verify_paths(ptr));
 		}
 
 		public int SetCipherList(string cipherList)
 		{
-			return Native.ExpectSuccess(Native.SSL_CTX_set_cipher_list(this.ptr, cipherList));
+			return Native.ExpectSuccess(Native.SSL_CTX_set_cipher_list(ptr, cipherList));
 		}
 
 		public int UseCertificate(X509Certificate cert)
 		{
-			return Native.ExpectSuccess(Native.SSL_CTX_use_certificate(this.ptr, cert.Handle));
+			return Native.ExpectSuccess(Native.SSL_CTX_use_certificate(ptr, cert.Handle));
 		}
 
 		public int UseCertificateChainFile(string filename)
 		{
-			return Native.ExpectSuccess(Native.SSL_CTX_use_certificate_chain_file(this.ptr, filename));
+			return Native.ExpectSuccess(Native.SSL_CTX_use_certificate_chain_file(ptr, filename));
 		}
 
 		public int UsePrivateKey(CryptoKey key)
 		{
-			return Native.ExpectSuccess(Native.SSL_CTX_use_PrivateKey(this.ptr, key.Handle));
+			return Native.ExpectSuccess(Native.SSL_CTX_use_PrivateKey(ptr, key.Handle));
 		}
 
 		public int UsePrivateKeyFile(string filename, SslFileType type)
 		{
-			return Native.ExpectSuccess(Native.SSL_CTX_use_PrivateKey_file(this.ptr, filename, (int)type));
+			return Native.ExpectSuccess(Native.SSL_CTX_use_PrivateKey_file(ptr, filename, (int)type));
 		}
 
 		public int CheckPrivateKey()
 		{
-			return Native.ExpectSuccess(Native.SSL_CTX_check_private_key(this.ptr));
+			return Native.ExpectSuccess(Native.SSL_CTX_check_private_key(ptr));
 		}
 
 		public int SetSessionIdContext(byte[] sid_ctx)
 		{
-			return Native.ExpectSuccess(Native.SSL_CTX_set_session_id_context(this.ptr, sid_ctx, (uint)sid_ctx.Length));
+			return Native.ExpectSuccess(Native.SSL_CTX_set_session_id_context(ptr, sid_ctx, (uint)sid_ctx.Length));
 		}
 
 		public void SetClientCertCallback(ClientCertCallbackHandler callback)
 		{
-			_clientCertCallbackThunk = new ClientCertCallbackThunk(callback);
-			Native.SSL_CTX_set_client_cert_cb(this.ptr, _clientCertCallbackThunk.Callback);
+			OnClientCert = callback;
+			Native.SSL_CTX_set_client_cert_cb(ptr, callback == null ? null : _ptrOnClientCertThunk);
 		}
 
-		public List<string> GetCipherList()
-		{
-			List<string> ret = new List<string>();
-			SSL_CTX raw = (SSL_CTX)Marshal.PtrToStructure(ptr, typeof(SSL_CTX));
-			Core.Stack<SslCipher> stack = new Core.Stack<SslCipher>(raw.cipher_list, false);
-			foreach (SslCipher cipher in stack)
-			{
-				IntPtr cipher_ptr = Native.SSL_CIPHER_description(cipher.Handle, null, 0);
-				if (cipher_ptr != IntPtr.Zero)
-				{
-					string strCipher = Marshal.PtrToStringAnsi(cipher_ptr);
-					ret.Add(strCipher);
-					Native.OPENSSL_free(cipher_ptr);
-				}
-			}
-			return ret;
-		}
-
 		#endregion
 
 		#region IDisposable Members
 
 		/// <summary>
-		/// base override - calls SSL_CTX_free()
+		///     base override - calls SSL_CTX_free()
 		/// </summary>
 		protected override void OnDispose()
 		{
-			Native.SSL_CTX_free(this.ptr);
+			Native.SSL_CTX_free(ptr);
 		}
 
 		#endregion
 	}
-}
+}
\ No newline at end of file
Index: ManagedOpenSsl/SSL/SslMethod.cs
===================================================================
--- ManagedOpenSsl/SSL/SslMethod.cs	(revision 47839)
+++ ManagedOpenSsl/SSL/SslMethod.cs	(revision 47851)
@@ -23,104 +23,118 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
 using System;
-using System.Collections.Generic;
-using System.Text;
-using OpenSSL.Core;
 
 namespace OpenSSL.SSL
 {
-    /// <summary>
-    /// Wraps the SSL_METHOD structure and methods
-    /// </summary>
-    public class SslMethod : Base
-    {
-        private SslMethod(IntPtr ptr, bool owner) :
-            base(ptr, owner)
-        {
-        }
+	/// <summary>
+	/// Wraps the SSL_METHOD structure and methods
+	/// </summary>
+	public class SslMethod : Base
+	{
+		private SslMethod(IntPtr ptr, bool owner) :
+			base(ptr, owner)
+		{
+		}
 
 		/// <summary>
 		/// Throws NotImplementedException()
 		/// </summary>
-		protected override void OnDispose() {
+		protected override void OnDispose()
+		{
 			throw new NotImplementedException();
 		}
 
-        /// <summary>
-        /// SSLv2_method()
-        /// </summary>
-        public static SslMethod SSLv2_method = new SslMethod(Native.SSLv2_method(), false);
+		/// <summary>
+		/// SSLv3_method()
+		/// </summary>
+		public static SslMethod SSLv3_method = new SslMethod(Native.SSLv3_method(), false);
 
-        /// <summary>
-        /// SSLv2_server_method()
-        /// </summary>
-        public static SslMethod SSLv2_server_method = new SslMethod(Native.SSLv2_server_method(), false);
+		/// <summary>
+		/// SSLv3_server_method()
+		/// </summary>
+		public static SslMethod SSLv3_server_method = new SslMethod(Native.SSLv3_server_method(), false);
 
-        /// <summary>
-        /// SSLv2_client_method()
-        /// </summary>
-        public static SslMethod SSLv2_client_method = new SslMethod(Native.SSLv2_client_method(), false);
-        
-        /// <summary>
-        /// SSLv3_method()
-        /// </summary>
-        public static SslMethod SSLv3_method = new SslMethod(Native.SSLv3_method(), false);
+		/// <summary>
+		/// SSLv3_client_method()
+		/// </summary>
+		public static SslMethod SSLv3_client_method = new SslMethod(Native.SSLv3_client_method(), false);
 
-        /// <summary>
-        /// SSLv3_server_method()
-        /// </summary>
-        public static SslMethod SSLv3_server_method = new SslMethod(Native.SSLv3_server_method(), false);
+		/// <summary>
+		/// SSLv23_method()
+		/// </summary>
+		public static SslMethod SSLv23_method = new SslMethod(Native.SSLv23_method(), false);
 
-        /// <summary>
-        /// SSLv3_client_method()
-        /// </summary>
-        public static SslMethod SSLv3_client_method = new SslMethod(Native.SSLv3_client_method(), false);
+		/// <summary>
+		/// SSLv23_server_method()
+		/// </summary>
+		public static SslMethod SSLv23_server_method = new SslMethod(Native.SSLv23_server_method(), false);
 
-        /// <summary>
-        /// SSLv23_method()
-        /// </summary>
-        public static SslMethod SSLv23_method = new SslMethod(Native.SSLv23_method(), false);
+		/// <summary>
+		/// SSLv23_client_method()
+		/// </summary>
+		public static SslMethod SSLv23_client_method = new SslMethod(Native.SSLv23_client_method(), false);
 
-        /// <summary>
-        /// SSLv23_server_method()
-        /// </summary>
-        public static SslMethod SSLv23_server_method = new SslMethod(Native.SSLv23_server_method(), false);
+		/// <summary>
+		/// TLSv1_method()
+		/// </summary>
+		public static SslMethod TLSv1_method = new SslMethod(Native.TLSv1_method(), false);
 
-        /// <summary>
-        /// SSLv23_client_method()
-        /// </summary>
-        public static SslMethod SSLv23_client_method = new SslMethod(Native.SSLv23_client_method(), false);
+		/// <summary>
+		/// TLSv1_server_method()
+		/// </summary>
+		public static SslMethod TLSv1_server_method = new SslMethod(Native.TLSv1_server_method(), false);
 
-        /// <summary>
-        /// TLSv1_method()
-        /// </summary>
-        public static SslMethod TLSv1_method = new SslMethod(Native.TLSv1_method(), false);
+		/// <summary>
+		/// TLSv1_client_method()
+		/// </summary>
+		public static SslMethod TLSv1_client_method = new SslMethod(Native.TLSv1_client_method(), false);
 
-        /// <summary>
-        /// TLSv1_server_method()
-        /// </summary>
-        public static SslMethod TLSv1_server_method = new SslMethod(Native.TLSv1_server_method(), false);
+		/// <summary>
+		/// TLSv11_method()
+		/// </summary>
+		public static SslMethod TLSv11_method = new SslMethod(Native.TLSv1_1_method(), false);
 
-        /// <summary>
-        /// TLSv1_client_method()
-        /// </summary>
-        public static SslMethod TLSv1_client_method = new SslMethod(Native.TLSv1_client_method(), false);
+		/// <summary>
+		/// TLSv11_server_method()
+		/// </summary>
+		public static SslMethod TLSv11_server_method = new SslMethod(Native.TLSv1_1_server_method(), false);
 
-        /// <summary>
-        /// DTLSv1_method()
-        /// </summary>
-        public static SslMethod DTLSv1_method = new SslMethod(Native.DTLSv1_method(), false);
+		/// <summary>
+		/// TLSv11_client_method()
+		/// </summary>
+		public static SslMethod TLSv11_client_method = new SslMethod(Native.TLSv1_1_client_method(), false);
 
-        /// <summary>
-        /// DTLSv1_server_method()
-        /// </summary>
-        public static SslMethod DTLSv1_server_method = new SslMethod(Native.DTLSv1_server_method(), false);
+		/// <summary>
+		/// TLSv12_method()
+		/// </summary>
+		public static SslMethod TLSv12_method = new SslMethod(Native.TLSv1_2_method(), false);
 
-        /// <summary>
-        /// DTLSv1_client_method()
-        /// </summary>
-        public static SslMethod DTLSv1_client_method = new SslMethod(Native.DTLSv1_client_method(), false);
+		/// <summary>
+		/// TLSv12_server_method()
+		/// </summary>
+		public static SslMethod TLSv12_server_method = new SslMethod(Native.TLSv1_2_server_method(), false);
 
-    }
+		/// <summary>
+		/// TLSv12_client_method()
+		/// </summary>
+		public static SslMethod TLSv12_client_method = new SslMethod(Native.TLSv1_2_client_method(), false);
+
+		/// <summary>
+		/// DTLSv1_method()
+		/// </summary>
+		public static SslMethod DTLSv1_method = new SslMethod(Native.DTLSv1_method(), false);
+
+		/// <summary>
+		/// DTLSv1_server_method()
+		/// </summary>
+		public static SslMethod DTLSv1_server_method = new SslMethod(Native.DTLSv1_server_method(), false);
+
+		/// <summary>
+		/// DTLSv1_client_method()
+		/// </summary>
+		public static SslMethod DTLSv1_client_method = new SslMethod(Native.DTLSv1_client_method(), false);
+
+	}
 }
Index: ManagedOpenSsl/SSL/SslStream.cs
===================================================================
--- ManagedOpenSsl/SSL/SslStream.cs	(revision 47839)
+++ ManagedOpenSsl/SSL/SslStream.cs	(revision 47851)
@@ -23,12 +23,11 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.X509;
 using System;
 using System.Collections.Generic;
-using System.Text;
+using System.IO;
 using System.Net.Security;
-using System.IO;
-using OpenSSL.X509;
 
 namespace OpenSSL.SSL
 {
@@ -41,7 +40,13 @@
 	/// <param name="depth"></param>
 	/// <param name="result"></param>
 	/// <returns></returns>
-	public delegate bool RemoteCertificateValidationHandler(Object sender, X509Certificate cert, X509Chain chain, int depth, VerifyResult result);
+	public delegate bool RemoteCertificateValidationHandler(
+		Object sender, 
+		X509Certificate cert, 
+		X509Chain chain, 
+		int depth, 
+		VerifyResult result
+	);
 
 	/// <summary>
 	/// 
@@ -52,10 +57,16 @@
 	/// <param name="remoteCert"></param>
 	/// <param name="acceptableIssuers"></param>
 	/// <returns></returns>
-	public delegate X509Certificate LocalCertificateSelectionHandler(Object sender, string targetHost, X509List localCerts, X509Certificate remoteCert, string[] acceptableIssuers);
+	public delegate X509Certificate LocalCertificateSelectionHandler(
+		Object sender, 
+		string targetHost, 
+		X509List localCerts, 
+		X509Certificate remoteCert, 
+		string[] acceptableIssuers
+	);
 
 	/// <summary>
-	/// Implments an AuthenticatedStream and is the main interface to the SSL library.
+	/// Implements an AuthenticatedStream and is the main interface to the SSL library.
 	/// </summary>
 	public class SslStream : AuthenticatedStream
 	{
@@ -65,8 +76,7 @@
 		/// Create an SslStream based on an existing stream.
 		/// </summary>
 		/// <param name="stream"></param>
-		public SslStream(Stream stream)
-			: this(stream, false)
+		public SslStream(Stream stream) : this(stream, false)
 		{
 		}
 
@@ -75,11 +85,8 @@
 		/// </summary>
 		/// <param name="stream"></param>
 		/// <param name="leaveInnerStreamOpen"></param>
-		public SslStream(Stream stream, bool leaveInnerStreamOpen)
-			: base(stream, leaveInnerStreamOpen)
+		public SslStream(Stream stream, bool leaveInnerStreamOpen) : base(stream, leaveInnerStreamOpen)
 		{
-			remoteCertificateValidationCallback = null;
-			localCertificateSelectionCallback = null;
 		}
 
 		/// <summary>
@@ -88,8 +95,13 @@
 		/// <param name="stream"></param>
 		/// <param name="leaveInnerStreamOpen"></param>
 		/// <param name="remote_callback"></param>
-		public SslStream(Stream stream, bool leaveInnerStreamOpen, RemoteCertificateValidationHandler remote_callback)
-			: this(stream, leaveInnerStreamOpen, remote_callback, null)
+		public SslStream(Stream stream, 
+			bool leaveInnerStreamOpen, 
+			RemoteCertificateValidationHandler remote_callback) : this(
+				stream,
+				leaveInnerStreamOpen,
+				remote_callback,
+				null)
 		{
 		}
 
@@ -100,15 +112,20 @@
 		/// <param name="leaveInnerStreamOpen"></param>
 		/// <param name="remote_callback"></param>
 		/// <param name="local_callback"></param>
-		public SslStream(Stream stream, bool leaveInnerStreamOpen, RemoteCertificateValidationHandler remote_callback, LocalCertificateSelectionHandler local_callback)
-			: base(stream, leaveInnerStreamOpen)
+		public SslStream(
+			Stream stream,
+			bool leaveInnerStreamOpen,
+			RemoteCertificateValidationHandler remote_callback,
+			LocalCertificateSelectionHandler local_callback) : base(stream, leaveInnerStreamOpen)
 		{
 			remoteCertificateValidationCallback = remote_callback;
 			localCertificateSelectionCallback = local_callback;
 		}
+
 		#endregion
 
 		#region AuthenticatedStream Members
+
 		/// <summary>
 		/// Returns whether authentication was successful.
 		/// </summary>
@@ -132,7 +149,9 @@
 		{
 			get
 			{
-				if (IsAuthenticated && (IsServer ? sslStream.RemoteCertificate != null : sslStream.LocalCertificate != null))
+				if (IsAuthenticated &&
+				    (IsServer ? Ssl.RemoteCertificate != null : 
+						Ssl.LocalCertificate != null))
 				{
 					return true;
 				}
@@ -159,6 +178,7 @@
 		#endregion
 
 		#region Stream Members
+
 		/// <summary>
 		/// Gets a value indicating whether the current stream supports reading.
 		/// </summary>
@@ -209,7 +229,7 @@
 		}
 
 		/// <summary>
-		/// Gets or sets a value, in miliseconds, that determines how long the stream will attempt to read before timing out.
+		/// Gets or sets a value, in milliseconds, that determines how long the stream will attempt to read before timing out.
 		/// </summary>
 		public override int ReadTimeout
 		{
@@ -218,7 +238,7 @@
 		}
 
 		/// <summary>
-		/// Gets or sets a value, in miliseconds, that determines how long the stream will attempt to write before timing out.
+		/// Gets or sets a value, in milliseconds, that determines how long the stream will attempt to write before timing out.
 		/// </summary>
 		public override int WriteTimeout
 		{
@@ -261,7 +281,7 @@
 
 		/// <summary>
 		/// Waits for the pending asynchronous read to complete.
-				/// </summary>
+		/// </summary>
 		/// <param name="asyncResult"></param>
 		/// <returns></returns>
 		public override int EndRead(IAsyncResult asyncResult)
@@ -277,7 +297,7 @@
 		/// <param name="offset"></param>
 		/// <param name="origin"></param>
 		/// <returns></returns>
-		public override long Seek(long offset, System.IO.SeekOrigin origin)
+		public override long Seek(long offset, SeekOrigin origin)
 		{
 			throw new NotSupportedException();
 		}
@@ -337,160 +357,59 @@
 		}
 
 		/// <summary>
-		/// Closes the current stream and releases any resources (such as sockets and file handles) associated with the current stream.		
+		/// Closes the current stream and releases any resources 
+		/// (such as sockets and file handles) associated with the current stream.		
 		/// </summary>
 		public override void Close()
 		{
-			TestConnectionIsValid();
-
 			base.Close();
-			sslStream.Close();
-		}
-		#endregion
-
-		#region Properties
-
-		/// <summary>
-		/// 
-		/// </summary>
-		public bool CheckCertificateRevocationStatus
-		{
-			get
+			if (sslStream != null)
 			{
-				if (!IsAuthenticated)
-					return false;
-				return sslStream.CheckCertificateRevocationStatus;
+				sslStream.Close();
 			}
 		}
 
-		/// <summary>
-		/// 
-		/// </summary>
-		public CipherAlgorithmType CipherAlgorithm
-		{
-			get
-			{
-				if (!IsAuthenticated)
-					return CipherAlgorithmType.None;
-				return sslStream.CipherAlgorithm;
-			}
-		}
+		#endregion
 
-		/// <summary>
-		/// 
-		/// </summary>
-		public int CipherStrength
-		{
-			get
-			{
-				if (!IsAuthenticated)
-					return 0;
-				return sslStream.CipherStrength;
-			}
-		}
+		#region Properties
 
 		/// <summary>
 		/// 
 		/// </summary>
-		public HashAlgorithmType HashAlgorithm
-		{
-			get
-			{
-				if (!IsAuthenticated)
-					return HashAlgorithmType.None;
-				return sslStream.HashAlgorithm;
-			}
-		}
+		public string AlpnSelectedProtocol { get; private set; }
 
 		/// <summary>
 		/// 
 		/// </summary>
-		public int HashStrength
+		public bool CheckCertificateRevocationStatus
 		{
 			get
 			{
 				if (!IsAuthenticated)
-					return 0;
-				return sslStream.HashStrength;
+					return false;
+				return sslStream.CheckCertificateRevocationStatus;
 			}
 		}
 
 		/// <summary>
-		/// 
+		/// Gets the ssl.
 		/// </summary>
-		public ExchangeAlgorithmType KeyExchangeAlgorithm
+		/// <value>The ssl.</value>
+		public Ssl Ssl
 		{
 			get
 			{
 				if (!IsAuthenticated)
-					return ExchangeAlgorithmType.None;
-				return sslStream.KeyExchangeAlgorithm;
-			}
-		}
-
-		/// <summary>
-		/// 
-		/// </summary>
-		public int KeyExchangeStrength
-		{
-			get
-			{
-				if (!IsAuthenticated)
-					return 0;
-				return sslStream.KeyExchangeStrength;
-			}
-		}
-
-		/// <summary>
-		/// 
-		/// </summary>
-		public X509Certificate LocalCertificate
-		{
-			get
-			{
-				if (!IsAuthenticated)
 					return null;
-				return sslStream.LocalCertificate;
+				return sslStream.Ssl;
 			}
 		}
 
-		/// <summary>
-		/// 
-		/// </summary>
-		public virtual X509Certificate RemoteCertificate
-		{
-			get
-			{
-				if (!IsAuthenticated)
-					return null;
-				return sslStream.RemoteCertificate;
-			}
-		}
 
-		/// <summary>
-		/// 
-		/// </summary>
-		public SslProtocols SslProtocol
-		{
-			get
-			{
-				if (!IsAuthenticated)
-					return SslProtocols.None;
-				return sslStream.SslProtocol;
-			}
-		}
+		#endregion
 
-		/// <summary>
-		/// 
-		/// </summary>
-		public List<string> CipherList
-		{
-			get { return sslStream.CipherList; }
-		}
+		#region Methods
 
-		#endregion //Properties
-
-		#region Methods
 		/// <summary>
 		/// 
 		/// </summary>
@@ -497,7 +416,7 @@
 		/// <param name="targetHost"></param>
 		public virtual void AuthenticateAsClient(string targetHost)
 		{
-			AuthenticateAsClient(targetHost, null, null, SslProtocols.Default, SslStrength.Medium, false);
+			AuthenticateAsClient(targetHost, null, null, SslProtocols.Tls, SslStrength.All, false);
 		}
 
 		/// <summary>
@@ -517,7 +436,15 @@
 			SslStrength sslStrength,
 			bool checkCertificateRevocation)
 		{
-			EndAuthenticateAsClient(BeginAuthenticateAsClient(targetHost, certificates, caCertificates, enabledSslProtocols, sslStrength, checkCertificateRevocation, null, null));
+			EndAuthenticateAsClient(BeginAuthenticateAsClient(
+				targetHost, 
+				certificates, 
+				caCertificates, 
+				enabledSslProtocols, 
+				sslStrength, 
+				checkCertificateRevocation, 
+				null, 
+				null));
 		}
 
 		/// <summary>
@@ -527,9 +454,20 @@
 		/// <param name="asyncCallback"></param>
 		/// <param name="asyncState"></param>
 		/// <returns></returns>
-		public virtual IAsyncResult BeginAuthenticateAsClient(string targetHost, AsyncCallback asyncCallback, Object asyncState)
+		public virtual IAsyncResult BeginAuthenticateAsClient(
+			string targetHost,
+			AsyncCallback asyncCallback,
+			Object asyncState)
 		{
-			return BeginAuthenticateAsClient(targetHost, null, null, SslProtocols.Default, SslStrength.Medium, false, asyncCallback, asyncState);
+			return BeginAuthenticateAsClient(
+				targetHost, 
+				null, 
+				null, 
+				SslProtocols.Tls, 
+				SslStrength.All, 
+				false, 
+				asyncCallback, 
+				asyncState);
 		}
 
 		/// <summary>
@@ -559,8 +497,19 @@
 				throw new InvalidOperationException("SslStream is already authenticated");
 			}
 
+			End = ConnectionEnd.Client;
+
 			// Create the stream
-			SslStreamClient client_stream = new SslStreamClient(InnerStream, false, targetHost, clientCertificates, caCertificates, enabledSslProtocols, sslStrength, checkCertificateRevocation, remoteCertificateValidationCallback, localCertificateSelectionCallback);
+			var client_stream = new SslStreamClient(
+				                    InnerStream, 
+				                    targetHost, 
+				                    clientCertificates, 
+				                    caCertificates, 
+				                    enabledSslProtocols, 
+				                    sslStrength, 
+				                    checkCertificateRevocation, 
+				                    remoteCertificateValidationCallback, 
+				                    localCertificateSelectionCallback);
 			// set the internal stream
 			sslStream = client_stream;
 			// start the write operation
@@ -577,6 +526,8 @@
 
 			// Finish the async authentication.  The EndRead/EndWrite will complete successfully, or throw exception
 			EndWrite(ar);
+
+			AlpnSelectedProtocol = sslStream.ssl.AlpnSelectedProtocol;
 		}
 
 		/// <summary>
@@ -585,7 +536,7 @@
 		/// <param name="serverCertificate"></param>
 		public virtual void AuthenticateAsServer(X509Certificate serverCertificate)
 		{
-			AuthenticateAsServer(serverCertificate, false, null, SslProtocols.Default, SslStrength.Medium, false);
+			AuthenticateAsServer(serverCertificate, false, null, SslProtocols.Tls, SslStrength.All, false);
 		}
 
 		/// <summary>
@@ -605,7 +556,15 @@
 			SslStrength sslStrength,
 			bool checkCertificateRevocation)
 		{
-			EndAuthenticateAsServer(BeginAuthenticateAsServer(serverCertificate, clientCertificateRequired, caCertificates, enabledSslProtocols, sslStrength, checkCertificateRevocation, null, null));
+			EndAuthenticateAsServer(BeginAuthenticateAsServer(
+				serverCertificate, 
+				clientCertificateRequired, 
+				caCertificates, 
+				enabledSslProtocols, 
+				sslStrength, 
+				checkCertificateRevocation, 
+				null, 
+				null));
 		}
 
 		/// <summary>
@@ -620,7 +579,15 @@
 			AsyncCallback asyncCallback,
 			Object asyncState)
 		{
-			return BeginAuthenticateAsServer(serverCertificate, false, null, SslProtocols.Default, SslStrength.Medium, false, asyncCallback, asyncState);
+			return BeginAuthenticateAsServer(
+				serverCertificate, 
+				false, 
+				null, 
+				SslProtocols.Tls, 
+				SslStrength.All, 
+				false, 
+				asyncCallback, 
+				asyncState);
 		}
 
 		/// <summary>
@@ -649,8 +616,19 @@
 			{
 				throw new InvalidOperationException("SslStream is already authenticated");
 			}
+
+			End = ConnectionEnd.Server;
+		    
 			// Initialize the server stream
-			SslStreamServer server_stream = new SslStreamServer(InnerStream, false, serverCertificate, clientCertificateRequired, caCerts, enabledSslProtocols, sslStrength, checkCertificateRevocation, remoteCertificateValidationCallback);
+			var server_stream = new SslStreamServer(
+				                    InnerStream, 
+				                    serverCertificate, 
+				                    clientCertificateRequired, 
+				                    caCerts, 
+				                    enabledSslProtocols, 
+				                    sslStrength, 
+				                    checkCertificateRevocation, 
+				                    remoteCertificateValidationCallback);
 			// Set the internal sslStream
 			sslStream = server_stream;
 			// Start the read operation
@@ -667,6 +645,8 @@
 
 			// Finish the async AuthenticateAsServer call - EndRead/Write call will throw exception on error
 			EndRead(ar);
+
+			AlpnSelectedProtocol = sslStream.ssl.AlpnSelectedProtocol;
 		}
 
 		/// <summary>
@@ -695,10 +675,8 @@
 			{
 				return BeginWrite(new byte[0], 0, 0, callback, state);
 			}
-			else
-			{
-				return BeginRead(new byte[0], 0, 0, callback, state);
-			}
+
+			return BeginRead(new byte[0], 0, 0, callback, state);
 		}
 
 		/// <summary>
@@ -722,6 +700,7 @@
 		#endregion
 
 		#region Helpers
+
 		private void TestConnectionIsValid()
 		{
 			if (sslStream == null)
@@ -729,13 +708,24 @@
 				throw new InvalidOperationException("SslStream has not been authenticated");
 			}
 		}
+
 		#endregion
 
+		#region Properties
+
+		/// <summary>
+		/// 
+		/// </summary>
+		public ConnectionEnd End { get; private set; }
+
+		#endregion
+
 		#region Fields
+
 		SslStreamBase sslStream;
 		internal RemoteCertificateValidationHandler remoteCertificateValidationCallback = null;
 		internal LocalCertificateSelectionHandler localCertificateSelectionCallback = null;
-		internal bool m_bCheckCertRevocationStatus = false;
+
 		#endregion
 	}
 }
Index: ManagedOpenSsl/SSL/SslStreamBase.cs
===================================================================
--- ManagedOpenSsl/SSL/SslStreamBase.cs	(revision 47839)
+++ ManagedOpenSsl/SSL/SslStreamBase.cs	(revision 47851)
@@ -23,40 +23,46 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
+using OpenSSL.X509;
 using System;
 using System.Collections.Generic;
-using System.Text;
 using System.IO;
 using System.Threading;
-using OpenSSL.Core;
-using OpenSSL.X509;
+using OpenSSL.Extensions;
 
 namespace OpenSSL.SSL
 {
-	internal abstract class SslStreamBase : Stream, IDisposable
+	internal abstract class SslStreamBase : Stream
 	{
 		internal Stream innerStream;
-		internal bool ownStream;
 		private volatile bool disposed = false;
 		internal SslContext sslContext;
 		internal Ssl ssl;
 		internal BIO read_bio;
 		internal BIO write_bio;
-		private byte[] read_buffer; // for reading from the stream
-		private MemoryStream decrypted_data_stream; // decrypted data from Ssl.Read
-		//private volatile bool inHandshakeLoop;
+		// for reading from the stream
+		private byte[] read_buffer = new byte[16384];
+		// decrypted data from Ssl.Read
+		private MemoryStream cleartext = new MemoryStream();
 		private const int SSL3_RT_HEADER_LENGTH = 5;
 		private const int SSL3_RT_MAX_PLAIN_LENGTH = 16384;
 		private const int SSL3_RT_MAX_COMPRESSED_LENGTH = (1024 + SSL3_RT_MAX_PLAIN_LENGTH);
 		private const int SSL3_RT_MAX_ENCRYPTED_LENGTH = (1024 + SSL3_RT_MAX_COMPRESSED_LENGTH);
 		private const int SSL3_RT_MAX_PACKET_SIZE = (SSL3_RT_MAX_ENCRYPTED_LENGTH + SSL3_RT_HEADER_LENGTH);
-		private const int WaitTimeOut = 300 * 1000; // 5 minutes
-		protected LocalCertificateSelectionHandler localCertificateSelectionCallback;
-		protected RemoteCertificateValidationHandler remoteCertificateSelectionCallback;
+		// 5 minutes
+		private const int WaitTimeOut = 300 * 1000;
+		protected LocalCertificateSelectionHandler OnLocalCertificate;
+		protected RemoteCertificateValidationHandler OnRemoteCertificate;
 		protected bool checkCertificateRevocationStatus = false;
 		protected HandshakeState handShakeState = HandshakeState.None;
 		protected OpenSslException handshakeException = null;
 
+		protected SniCallback sniCb;
+		protected Sni sniExt;
+
+		protected string srvName = "localhost";
+
 		/// <summary>
 		/// Override to implement client/server specific handshake processing
 		/// </summary>
@@ -81,7 +87,14 @@
 			private int offset;
 			private int count;
 
-			public InternalAsyncResult(AsyncCallback userCallback, object userState, byte[] buffer, int offset, int count, bool isWriteOperation, bool continueAfterHandshake)
+			public InternalAsyncResult(
+				AsyncCallback userCallback,
+				object userState,
+				byte[] buffer,
+				int offset,
+				int count,
+				bool isWriteOperation,
+				bool continueAfterHandshake)
 			{
 				this.userCallback = userCallback;
 				this.userState = userState;
@@ -94,43 +107,43 @@
 
 			public bool ContinueAfterHandshake
 			{
-				get { return this.continueAfterHandshake; }
+				get { return continueAfterHandshake; }
 			}
 
 			public bool IsWriteOperation
 			{
-				get { return this.isWriteOperation; }
-				set { this.isWriteOperation = value; }
+				get { return isWriteOperation; }
+				set { isWriteOperation = value; }
 			}
 
 			public byte[] Buffer
 			{
-				get { return this.buffer; }
+				get { return buffer; }
 			}
 
 			public int Offset
 			{
-				get { return this.offset; }
+				get { return offset; }
 			}
 
 			public int Count
 			{
-				get { return this.count; }
+				get { return count; }
 			}
 
 			public int BytesRead
 			{
-				get { return this.bytesRead; }
+				get { return bytesRead; }
 			}
 
 			public object AsyncState
 			{
-				get { return this.userState; }
+				get { return userState; }
 			}
 
 			public Exception AsyncException
 			{
-				get { return this.asyncException; }
+				get { return asyncException; }
 			}
 
 			public bool CompletedWithError
@@ -152,12 +165,12 @@
 					lock (locker)
 					{
 						// Create the event if we haven't already done so
-						if (this.asyncWaitHandle == null)
+						if (asyncWaitHandle == null)
 						{
-							this.asyncWaitHandle = new ManualResetEvent(isCompleted);
+							asyncWaitHandle = new ManualResetEvent(isCompleted);
 						}
 					}
-					return this.asyncWaitHandle;
+					return asyncWaitHandle;
 				}
 			}
 
@@ -172,7 +185,7 @@
 				{
 					lock (locker)
 					{
-						return this.isCompleted;
+						return isCompleted;
 					}
 				}
 			}
@@ -181,25 +194,25 @@
 			{
 				lock (locker)
 				{
-					if (this.isCompleted)
+					if (isCompleted)
 					{
 						return;
 					}
 
-					this.isCompleted = true;
-					this.asyncException = ex;
+					isCompleted = true;
+					asyncException = ex;
 					this.bytesRead = bytesRead;
 					// If the wait handle isn't null, we should set the event
 					// rather than fire a callback
-					if (this.asyncWaitHandle != null)
+					if (asyncWaitHandle != null)
 					{
-						this.asyncWaitHandle.Set();
+						asyncWaitHandle.Set();
 					}
 				}
 				// If we have a callback method, invoke it
-				if (this.userCallback != null)
+				if (userCallback != null)
 				{
-					this.userCallback.BeginInvoke(this, null, null);
+					userCallback.BeginInvoke(this, null, null);
 				}
 			}
 
@@ -218,9 +231,10 @@
 				SetComplete(null, 0);
 			}
 		}
+
 		#endregion
 
-		public SslStreamBase(Stream stream, bool ownStream)
+		public SslStreamBase(Stream stream)
 		{
 			if (stream == null)
 			{
@@ -231,10 +245,8 @@
 				throw new ArgumentException("Stream must allow read and write capabilities", "stream");
 			}
 			innerStream = stream;
-			this.ownStream = ownStream;
-			read_buffer = new byte[16384];
-			//inHandshakeLoop = false;
-			decrypted_data_stream = new MemoryStream();
+            
+			sniExt = new Sni(srvName);
 		}
 
 		public bool HandshakeComplete
@@ -255,78 +267,23 @@
 
 		public LocalCertificateSelectionHandler LocalCertSelectionCallback
 		{
-			get { return localCertificateSelectionCallback; }
-			set { localCertificateSelectionCallback = value; }
+			get { return OnLocalCertificate; }
+			set { OnLocalCertificate = value; }
 		}
 
 		public RemoteCertificateValidationHandler RemoteCertValidationCallback
 		{
-			get { return remoteCertificateSelectionCallback; }
-			set { remoteCertificateSelectionCallback = value; }
+			get { return OnRemoteCertificate; }
+			set { OnRemoteCertificate = value; }
 		}
 
-		public X509Certificate LocalCertificate
+		public Ssl Ssl
 		{
-			get { return ssl.LocalCertificate; }
+			get { return ssl; }
 		}
 
-		public X509Certificate RemoteCertificate
-		{
-			get { return ssl.RemoteCertificate; }
-		}
+		#region Stream methods
 
-		public CipherAlgorithmType CipherAlgorithm
-		{
-			get { return ssl.CurrentCipher.CipherAlgorithm; }
-		}
-
-		public int CipherStrength
-		{
-			get { return ssl.CurrentCipher.Strength; }
-		}
-
-		public HashAlgorithmType HashAlgorithm
-		{
-			get { return ssl.CurrentCipher.HashAlgorithm; }
-		}
-
-		public int HashStrength
-		{
-			get
-			{
-				switch (HashAlgorithm)
-				{
-					case HashAlgorithmType.Md5:
-						return 128;
-					case HashAlgorithmType.Sha1:
-						return 160;
-					default:
-						return 0;
-				}
-			}
-		}
-
-		public ExchangeAlgorithmType KeyExchangeAlgorithm
-		{
-			get { return ssl.CurrentCipher.KeyExchangeAlgorithm; }
-		}
-
-		public int KeyExchangeStrength
-		{
-			get { return ssl.CurrentCipher.KeyExchangeStrength; }
-		}
-
-		public SslProtocols SslProtocol
-		{
-			get { return ssl.CurrentCipher.SslProtocol; }
-		}
-
-		public List<string> CipherList
-		{
-			get { return sslContext.GetCipherList(); }
-		}
-
-		#region Stream methods
 		public override bool CanRead
 		{
 			get { return innerStream.CanRead; }
@@ -389,113 +346,16 @@
 		{
 			throw new NotImplementedException();
 		}
-		/*
-		public override int Read(byte[] buffer, int offset, int count)
-		{
-			// Check to see if we need to reset the decrypted data stream
-			if (decrypted_data_stream.Position == decrypted_data_stream.Length)
-			{
-				// reset the stream
-				decrypted_data_stream.Seek(0, SeekOrigin.Begin);
-				decrypted_data_stream.SetLength(0);
-			}
-			// Check to see if we have data in the decrypted memory stream, if so return it
-			if (decrypted_data_stream.Position > 0 && (decrypted_data_stream.Position != decrypted_data_stream.Length))
-			{
-				return decrypted_data_stream.Read(buffer, offset, count);
-			}
-            
-			// No pre-existing data in the stream, read from the innerStream
-			int bytesRead = 0;
-			bool haveDataToReturn = false;
 
-			while (! haveDataToReturn)
-			{
-				try
-				{
-					bytesRead = innerStream.Read(read_buffer, 0, read_buffer.Length);
-				}
-				catch(System.IO.IOException ex)
-				{
-					//!!TODO - log exception
-					return 0;
-				}
-				// if we have data, let's process it
-				if (bytesRead > 0)
-				{
-					// Copy encrypted data into the SSL read_bio
-					read_bio.Write(read_buffer, bytesRead);
-					if (inHandshakeLoop)
-					{
-						if (ProcessHandshake())
-						{
-							inHandshakeLoop = false;
-						}
-					}
-					//!!else -- Process data in read_bio after handshake if there is any
-					{
-						uint nBytesPending = read_bio.BytesPending;
-						byte[] decrypted_buf = new byte[SSL3_RT_MAX_PACKET_SIZE];
-						while (nBytesPending > 0)
-						{
-							int decryptedBytesRead = ssl.Read(decrypted_buf, decrypted_buf.Length);
-							if (decryptedBytesRead <= 0)
-							{
-								SslError lastError = ssl.GetError(decryptedBytesRead);
-								if (lastError == SslError.SSL_ERROR_WANT_READ)
-								{
-									// Renogiated requested by the client
-									if (write_bio.BytesPending > 0)
-									{
-										inHandshakeLoop = true;
-										if (ProcessHandshake())
-										{
-											inHandshakeLoop = false;
-										}
-									}
-									//!!break; -- continue processing the handshake data
-								}
-								else if (lastError == SslError.SSL_ERROR_WANT_WRITE)
-								{
-									// unexpected error!
-									//!!TODO debug log
-								}
-								else if (lastError == SslError.SSL_ERROR_ZERO_RETURN)
-								{
-									// Shutdown alert
-									SendShutdownAlert();
-									break;
-								}
-								else
-								{
-									//!!TODO - log last error, throw expection
-									break;
-								}
-							}
-							// Write decrypted data to memory stream
-							long pos = decrypted_data_stream.Position;
-							decrypted_data_stream.Seek(0, SeekOrigin.End);
-							decrypted_data_stream.Write(decrypted_buf, 0, decrypted_buf.Length);
-							decrypted_data_stream.Seek(pos, SeekOrigin.Begin);
-							haveDataToReturn = true;
-
-							// See if we have more data to process
-							nBytesPending = read_bio.BytesPending;
-						}
-					}
-				}
-			}
-			// Read data from the decrypted data stream into the user buffer
-			return decrypted_data_stream.Read(buffer, offset, count);
-		}
-		*/
-
 		public void SendShutdownAlert()
 		{
-			int nShutdownRet = ssl.Shutdown();
+			if (disposed)
+				return;
+
+			var nShutdownRet = ssl.Shutdown();
 			if (nShutdownRet == 0)
 			{
-				uint nBytesToWrite = write_bio.BytesPending;
+				var nBytesToWrite = write_bio.BytesPending;
 				if (nBytesToWrite <= 0)
 				{
 					// unexpected error
@@ -502,7 +362,7 @@
 					//!!TODO log error
 					return;
 				}
-				ArraySegment<byte> buf = write_bio.ReadBytes((int)nBytesToWrite);
+				var buf = write_bio.ReadBytes((int)nBytesToWrite);
 				if (buf.Count <= 0)
 				{
 					//!!TODO - log error
@@ -543,14 +403,19 @@
 				throw new ArgumentOutOfRangeException("count", "count is greater than buffer length - offset");
 			}
 
-			bool proceedAfterHandshake = true;
-			if (count == 0) proceedAfterHandshake = false;
+			var proceedAfterHandshake = count != 0;
 
-			InternalAsyncResult internalAsyncResult = new InternalAsyncResult(asyncCallback, asyncState, buffer, offset, count, false, proceedAfterHandshake);
+			var internalAsyncResult = new InternalAsyncResult(
+				asyncCallback, 
+				asyncState, 
+				buffer, 
+				offset, 
+				count, 
+				false, 
+				proceedAfterHandshake);
 
 			if (NeedHandshake)
 			{
-				//inHandshakeLoop = true;
 				BeginHandshake(internalAsyncResult);
 			}
 			else
@@ -563,32 +428,38 @@
 
 		private void InternalBeginRead(InternalAsyncResult asyncResult)
 		{
+			if (disposed)
+				return;
+
 			// Check to see if the decrypted data stream should be reset
-			if (decrypted_data_stream.Position == decrypted_data_stream.Length)
+			if (cleartext.Position == cleartext.Length)
 			{
-				decrypted_data_stream.Seek(0, SeekOrigin.Begin);
-				decrypted_data_stream.SetLength(0);
+				cleartext.Seek(0, SeekOrigin.Begin);
+				cleartext.SetLength(0);
 			}
 			// Check to see if we have data waiting in the decrypted data stream
-			if (decrypted_data_stream.Length > 0 && (decrypted_data_stream.Position != decrypted_data_stream.Length))
+			if (cleartext.Length > 0 && (cleartext.Position != cleartext.Length))
 			{
 				// Process the pre-existing data
-				int bytesRead = decrypted_data_stream.Read(asyncResult.Buffer, asyncResult.Offset, asyncResult.Count);
+				var bytesRead = cleartext.Read(asyncResult.Buffer, asyncResult.Offset, asyncResult.Count);
 				asyncResult.SetComplete(bytesRead);
 				return;
 			}
 			// Start the async read from the inner stream
-			innerStream.BeginRead(read_buffer, 0, read_buffer.Length, new AsyncCallback(InternalReadCallback), asyncResult);
+			innerStream.BeginRead(read_buffer, 0, read_buffer.Length, InternalReadCallback, asyncResult);
 		}
 
 		private void InternalReadCallback(IAsyncResult asyncResult)
 		{
-			InternalAsyncResult internalAsyncResult = (InternalAsyncResult)asyncResult.AsyncState;
-			bool haveDataToReturn = false;
+			if (disposed)
+				return;
 
+			var internalAsyncResult = (InternalAsyncResult)asyncResult.AsyncState;
+			var haveDataToReturn = false;
+
 			try
 			{
-				int bytesRead = 0;
+				var bytesRead = 0;
 				try
 				{
 					bytesRead = innerStream.EndRead(asyncResult);
@@ -602,7 +473,7 @@
 				{
 					// Zero byte read most likely indicates connection closed (if it's a network stream)
 					internalAsyncResult.SetComplete(0);
-					return;
+					throw new IOException("Connection was closed by the remote endpoint");
 				}
 				else
 				{
@@ -609,7 +480,7 @@
 					// Copy encrypted data into the SSL read_bio
 					read_bio.Write(read_buffer, bytesRead);
 					if (handShakeState == HandshakeState.InProcess ||
-						handShakeState == HandshakeState.RenegotiateInProcess)
+					    handShakeState == HandshakeState.RenegotiateInProcess)
 					{
 						// We are in the handshake, complete the async operation to fire the async
 						// handshake callback for processing
@@ -616,14 +487,14 @@
 						internalAsyncResult.SetComplete(bytesRead);
 						return;
 					}
-					uint nBytesPending = read_bio.BytesPending;
-					byte[] decrypted_buf = new byte[SSL3_RT_MAX_PACKET_SIZE];
+					var nBytesPending = read_bio.BytesPending;
+					var decrypted_buf = new byte[SSL3_RT_MAX_PACKET_SIZE];
 					while (nBytesPending > 0)
 					{
 						int decryptedBytesRead = ssl.Read(decrypted_buf, decrypted_buf.Length);
 						if (decryptedBytesRead <= 0)
 						{
-							SslError lastError = ssl.GetError(decryptedBytesRead);
+							var lastError = ssl.GetError(decryptedBytesRead);
 							if (lastError == SslError.SSL_ERROR_WANT_READ)
 							{
 								// if we have bytes pending in the write bio.
@@ -632,8 +503,11 @@
 								{
 									// Start the renegotiation by writing the write_bio data, and use the RenegotiationWriteCallback
 									// to handle the rest of the renegotiation
-									ArraySegment<byte> buf = write_bio.ReadBytes((int)write_bio.BytesPending);
-									innerStream.BeginWrite(buf.Array, 0, buf.Count, new AsyncCallback(RenegotiationWriteCallback), internalAsyncResult);
+									var buf = write_bio.ReadBytes((int)write_bio.BytesPending);
+									innerStream.BeginWrite(
+										buf.Array, 0, buf.Count,
+										RenegotiationWriteCallback,
+										internalAsyncResult);
 									return;
 								}
 								// no data in the out bio, we just need more data to complete the record
@@ -652,16 +526,16 @@
 							}
 							else
 							{
-								throw new OpenSslException();
+								//throw new OpenSslException();
 							}
 						}
 						if (decryptedBytesRead > 0)
 						{
 							// Write decrypted data to memory stream
-							long pos = decrypted_data_stream.Position;
-							decrypted_data_stream.Seek(0, SeekOrigin.End);
-							decrypted_data_stream.Write(decrypted_buf, 0, decryptedBytesRead);
-							decrypted_data_stream.Seek(pos, SeekOrigin.Begin);
+							var pos = cleartext.Position;
+							cleartext.Seek(0, SeekOrigin.End);
+							cleartext.Write(decrypted_buf, 0, decryptedBytesRead);
+							cleartext.Seek(pos, SeekOrigin.Begin);
 							haveDataToReturn = true;
 						}
 
@@ -671,14 +545,19 @@
 					// Check to see if we have data to return, if not, fire the async read again
 					if (!haveDataToReturn)
 					{
-						innerStream.BeginRead(read_buffer, 0, read_buffer.Length, new AsyncCallback(InternalReadCallback), internalAsyncResult);
+						innerStream.BeginRead(
+							read_buffer, 0, read_buffer.Length, 
+							InternalReadCallback,
+							internalAsyncResult);
 					}
 					else
 					{
-						int bytesReadIntoUserBuffer = 0;
+						var bytesReadIntoUserBuffer = 0;
 
 						// Read the data into the buffer provided by the user (now hosted in the InternalAsyncResult)
-						bytesReadIntoUserBuffer = decrypted_data_stream.Read(internalAsyncResult.Buffer, internalAsyncResult.Offset, internalAsyncResult.Count);
+						bytesReadIntoUserBuffer = cleartext.Read(internalAsyncResult.Buffer,
+							internalAsyncResult.Offset,
+							internalAsyncResult.Count);
 
 						internalAsyncResult.SetComplete(bytesReadIntoUserBuffer);
 					}
@@ -692,7 +571,10 @@
 
 		public override int EndRead(IAsyncResult asyncResult)
 		{
-			InternalAsyncResult internalAsyncResult = asyncResult as InternalAsyncResult;
+			if (disposed)
+				return 0;
+
+			var internalAsyncResult = asyncResult as InternalAsyncResult;
 			if (internalAsyncResult == null)
 			{
 				throw new ArgumentException("AsyncResult was not obtained via BeginRead", "asyncResult");
@@ -709,7 +591,7 @@
 			// If we completed with an error, throw the exceptions
 			if (internalAsyncResult.CompletedWithError)
 			{
-				throw internalAsyncResult.AsyncException;
+				throw new Exception("AsyncException", internalAsyncResult.AsyncException);
 			}
 
 			// Success, return the bytes read
@@ -721,58 +603,7 @@
 		{
 			throw new NotImplementedException();
 		}
-		/*
-		public override void Write(byte[] buffer, int offset, int count)
-		{
-			if (buffer == null)
-			{
-				throw new ArgumentNullException("buffer");
-			}
-			if (offset < 0)
-			{
-				throw new ArgumentOutOfRangeException("offset", "Offset must be greater than or equal to 0");
-			}
-			if (offset > buffer.Length)
-			{
-				throw new ArgumentOutOfRangeException("offset", "Offset is greater than length of the buffer");
-			}
-			if (count < 0)
-			{
-				throw new ArgumentOutOfRangeException("count", "Count must be greater than 0");    
-			}
-			if (count > (buffer.Length - offset))
-			{
-				throw new ArgumentOutOfRangeException("count", "Count is greater than buffer length - offset");
-			}
 
-			byte[] new_buffer = buffer;
-			if (offset != 0)
-			{
-				byte[] temp = new byte[count];
-				Array.Copy(buffer, offset, temp, 0, count);
-				new_buffer = temp;
-			}
-
-			int bytesWritten = ssl.Write(new_buffer, count);
-			if (bytesWritten <= 0)
-			{
-				SslError lastError = ssl.GetError(bytesWritten);
-				if (lastError == SslError.SSL_ERROR_WANT_READ)
-				{
-					//!!TODO - Log - unexpected renogiation request
-				}
-				throw new OpenSslException((uint)lastError);
-			}
-			uint bytesPending = write_bio.BytesPending;
-			while (bytesPending > 0)
-			{
-				ArraySegment<byte> buf = write_bio.ReadBytes((int)bytesPending);
-				innerStream.Write(buf.Array, 0, buf.Count);
-				bytesPending = write_bio.BytesPending;
-			}
-		}
-		*/
-
 		public override IAsyncResult BeginWrite(
 			byte[] buffer,
 			int offset,
@@ -780,6 +611,9 @@
 			AsyncCallback asyncCallback,
 			object asyncState)
 		{
+			if (disposed)
+				return null;
+
 			if (buffer == null)
 			{
 				throw new ArgumentNullException("buffer", "buffer can't be null");
@@ -801,14 +635,19 @@
 				throw new ArgumentOutOfRangeException("count", "count is greater than buffer length - offset");
 			}
 
-			bool proceedAfterHandshake = true;
-			if (count == 0) proceedAfterHandshake = false;
+			bool proceedAfterHandshake = count != 0;
 
-			InternalAsyncResult asyncResult = new InternalAsyncResult(asyncCallback, asyncState, buffer, offset, count, true, proceedAfterHandshake);
+			var asyncResult = new InternalAsyncResult(
+				asyncCallback, 
+				asyncState, 
+				buffer, 
+				offset, 
+				count, 
+				true, 
+				proceedAfterHandshake);
 
 			if (NeedHandshake)
 			{
-				//inHandshakeLoop = true;
 				// Start the handshake
 				BeginHandshake(asyncResult);
 			}
@@ -822,8 +661,11 @@
 
 		private void InternalBeginWrite(InternalAsyncResult asyncResult)
 		{
-			byte[] new_buffer = asyncResult.Buffer;
+			if (disposed)
+				return;
 
+			var new_buffer = asyncResult.Buffer;
+
 			if (asyncResult.Offset != 0 && asyncResult.Count != 0)
 			{
 				new_buffer = new byte[asyncResult.Count];
@@ -833,10 +675,10 @@
 			// Only write to the SSL object if we have data
 			if (asyncResult.Count != 0)
 			{
-				int bytesWritten = ssl.Write(new_buffer, asyncResult.Count);
+				var bytesWritten = ssl.Write(new_buffer, asyncResult.Count);
 				if (bytesWritten < 0)
 				{
-					SslError lastError = ssl.GetError(bytesWritten);
+					var lastError = ssl.GetError(bytesWritten);
 					if (lastError == SslError.SSL_ERROR_WANT_READ)
 					{
 						//!!TODO - Log - unexpected renogiation request
@@ -844,18 +686,25 @@
 					throw new OpenSslException();
 				}
 			}
-			uint bytesPending = write_bio.BytesPending;
-			//!!while (bytesPending > 0)
+
+			var bytesPending = write_bio.BytesPending;
+			if (bytesPending > 0)
 			{
-				ArraySegment<byte> buf = write_bio.ReadBytes((int)bytesPending);
-				innerStream.BeginWrite(buf.Array, 0, buf.Count, new AsyncCallback(InternalWriteCallback), asyncResult);
-				//!!bytesPending = write_bio.BytesPending;
+				var buf = write_bio.ReadBytes((int)bytesPending);
+				if (buf.Count > 0)
+				{
+					innerStream.BeginWrite(
+						buf.Array, 0, buf.Count, 
+						InternalWriteCallback, 
+						asyncResult
+					);
+				}
 			}
 		}
 
 		private void InternalWriteCallback(IAsyncResult asyncResult)
 		{
-			InternalAsyncResult internalAsyncResult = (InternalAsyncResult)asyncResult.AsyncState;
+			var internalAsyncResult = (InternalAsyncResult)asyncResult.AsyncState;
 
 			try
 			{
@@ -870,8 +719,11 @@
 
 		public override void EndWrite(IAsyncResult asyncResult)
 		{
-			InternalAsyncResult internalAsyncResult = asyncResult as InternalAsyncResult;
+			if (disposed)
+				return;
 
+			var internalAsyncResult = asyncResult as InternalAsyncResult;
+
 			if (internalAsyncResult == null)
 			{
 				throw new ArgumentException("AsyncResult object was not obtained from SslStream.BeginWrite", "asyncResult");
@@ -887,13 +739,13 @@
 
 			if (internalAsyncResult.CompletedWithError)
 			{
-				throw internalAsyncResult.AsyncException;
+				throw new Exception("AsyncException", internalAsyncResult.AsyncException);
 			}
 		}
 
 		private void RenegotiationWriteCallback(IAsyncResult asyncResult)
 		{
-			InternalAsyncResult readwriteAsyncResult = (InternalAsyncResult)asyncResult.AsyncState;
+			var readwriteAsyncResult = (InternalAsyncResult)asyncResult.AsyncState;
 
 			innerStream.EndWrite(asyncResult);
 
@@ -901,48 +753,10 @@
 			InternalBeginRead(readwriteAsyncResult);
 		}
 
-		/*
-		public abstract virtual bool ProcessRenegotiation();
-
-		private IAsyncResult BeginRenegotiate(InternalAsyncResult readwriteAsyncResult)
-		{
-			Console.WriteLine("BeginRenegotiate");
-
-			handShakeState = HandshakeState.Renegotiate;
-
-			// Wrap the readwriteAsyncResult in the renegotiateAsyncResult
-			InternalAsyncResult renegotiateAsyncResult = new InternalAsyncResult(new AsyncCallback(RenegotiateComplete), readwriteAsyncResult, null, 0, 0, readwriteAsyncResult.IsWriteOperation, readwriteAsyncResult.ContinueAfterHandshake);
-
-			if (ProcessRenegotiation())
-			{
-				handShakeState = HandshakeState.Complete;
-				renegotiateAsyncResult.SetComplete();
-			}
-			else
-			{
-				//!! if (readwriteAsyncResult.IsWriteOperation)
-				if (write_bio.BytesPending > 0)
-				{
-					renegotiateAsyncResult.IsWriteOperation = true;
-					BeginWrite(new byte[0], 0, 0, new AsyncCallback(RenegotiateCallback), renegotiateAsyncResult);
-				}
-				else
-				{
-					renegotiateAsyncResult.IsWriteOperation = false;
-					BeginRead(new byte[0], 0, 0, new AsyncCallback(RenegotiateCallback), renegotiateAsyncResult);
-				}
-			}
-			return renegotiateAsyncResult;
-		}
-
-		private void RenegotiateCallback(IAsyncResult asyncResult)
-		{
-			InternalAsyncResult renegotiateAsyncResult = asyncResult.AsyncState as InternalAsyncResult;
-		}
-		*/
-
 		private IAsyncResult BeginHandshake(InternalAsyncResult readwriteAsyncResult)
 		{
+			if (disposed)
+				return null;
 			//!!
 			// Move the handshake state to the next state
 			//if (handShakeState == HandshakeState.Renegotiate)
@@ -956,11 +770,17 @@
 			}
 
 			// Wrap the read/write InternalAsyncResult in the Handshake InternalAsyncResult instance
-			InternalAsyncResult handshakeAsyncResult = new InternalAsyncResult(new AsyncCallback(AsyncHandshakeComplete), readwriteAsyncResult, null, 0, 0, readwriteAsyncResult.IsWriteOperation, readwriteAsyncResult.ContinueAfterHandshake);
+			var handshakeAsyncResult = new InternalAsyncResult(
+				                           AsyncHandshakeComplete, 
+				                           readwriteAsyncResult, 
+				                           null, 
+				                           0, 
+				                           0, 
+				                           readwriteAsyncResult.IsWriteOperation, 
+				                           readwriteAsyncResult.ContinueAfterHandshake);
 
 			if (ProcessHandshake())
 			{
-				//inHandshakeLoop = false;
 				handShakeState = HandshakeState.Complete;
 				handshakeAsyncResult.SetComplete();
 			}
@@ -970,12 +790,12 @@
 				if (write_bio.BytesPending > 0)
 				{
 					handshakeAsyncResult.IsWriteOperation = true;
-					BeginWrite(new byte[0], 0, 0, new AsyncCallback(AsyncHandshakeCallback), handshakeAsyncResult);
+					BeginWrite(new byte[0], 0, 0, AsyncHandshakeCallback, handshakeAsyncResult);
 				}
 				else
 				{
 					handshakeAsyncResult.IsWriteOperation = false;
-					BeginRead(new byte[0], 0, 0, new AsyncCallback(AsyncHandshakeCallback), handshakeAsyncResult);
+					BeginRead(new byte[0], 0, 0, AsyncHandshakeCallback, handshakeAsyncResult);
 				}
 			}
 			return handshakeAsyncResult;
@@ -984,8 +804,8 @@
 		private void AsyncHandshakeCallback(IAsyncResult asyncResult)
 		{
 			// Get the handshake internal result instance
-			InternalAsyncResult internalAsyncResult = (InternalAsyncResult)asyncResult.AsyncState;
-			int bytesRead = 0;
+			var internalAsyncResult = (InternalAsyncResult)asyncResult.AsyncState;
+			var bytesRead = 0;
 
 			if (internalAsyncResult.IsWriteOperation)
 			{
@@ -1008,7 +828,7 @@
 				}
 				// We wrote out the handshake data, now read to get the response
 				internalAsyncResult.IsWriteOperation = false;
-				BeginRead(new byte[0], 0, 0, new AsyncCallback(AsyncHandshakeCallback), internalAsyncResult);
+				BeginRead(new byte[0], 0, 0,  AsyncHandshakeCallback, internalAsyncResult);
 			}
 			else
 			{
@@ -1019,7 +839,6 @@
 					{
 						if (ProcessHandshake())
 						{
-							//inHandshakeLoop = false;
 							handShakeState = HandshakeState.Complete;
 							// We have completed the handshake, but need to send the
 							// last response packet.
@@ -1026,7 +845,7 @@
 							if (write_bio.BytesPending > 0)
 							{
 								internalAsyncResult.IsWriteOperation = true;
-								BeginWrite(new byte[0], 0, 0, new AsyncCallback(AsyncHandshakeCallback), internalAsyncResult);
+								BeginWrite(new byte[0], 0, 0, AsyncHandshakeCallback, internalAsyncResult);
 							}
 							else
 							{
@@ -1038,7 +857,7 @@
 						{
 							// Not complete with the handshake yet, write the handshake packet out
 							internalAsyncResult.IsWriteOperation = true;
-							BeginWrite(new byte[0], 0, 0, new AsyncCallback(AsyncHandshakeCallback), internalAsyncResult);
+							BeginWrite(new byte[0], 0, 0, AsyncHandshakeCallback, internalAsyncResult);
 						}
 					}
 					else
@@ -1056,14 +875,20 @@
 
 		private void AsyncHandshakeComplete(IAsyncResult asyncResult)
 		{
+			if (disposed)
+				return;
+
 			EndHandshake(asyncResult);
 		}
 
 		private void EndHandshake(IAsyncResult asyncResult)
 		{
-			InternalAsyncResult handshakeAsyncResult = asyncResult as InternalAsyncResult;
-			InternalAsyncResult readwriteAsyncResult = asyncResult.AsyncState as InternalAsyncResult;
+			if (disposed)
+				return;
 
+			var handshakeAsyncResult = asyncResult as InternalAsyncResult;
+			var readwriteAsyncResult = asyncResult.AsyncState as InternalAsyncResult;
+
 			if (!handshakeAsyncResult.IsCompleted)
 			{
 				handshakeAsyncResult.AsyncWaitHandle.WaitOne(WaitTimeOut, false);
@@ -1095,7 +920,9 @@
 
 		public override void Close()
 		{
-			//base.Close();
+			if (disposed)
+				return;
+
 			if (ssl != null)
 			{
 				ssl.Dispose();
@@ -1106,6 +933,9 @@
 				sslContext.Dispose();
 				sslContext = null;
 			}
+
+			base.Close();
+			Dispose();
 		}
 
 		#endregion
@@ -1126,66 +956,17 @@
 
 		#region IDisposable Members
 
-		void IDisposable.Dispose()
+		protected override void Dispose(bool disposing)
 		{
-			if (!disposed)
+			if (disposed)
 			{
+				return;
 			}
+
+			disposed = true;
+			base.Dispose();
 		}
 
 		#endregion
-
-		internal string GetCipherString(bool FIPSmode, SslProtocols sslProtocols, SslStrength sslStrength)
-		{
-			string str = "";
-
-			if (FIPSmode || ((sslStrength & SslStrength.High) == SslStrength.High))
-			{
-				str = "HIGH";
-			}
-			if (FIPSmode || ((sslStrength & SslStrength.Medium) == SslStrength.Medium))
-			{
-				if (String.IsNullOrEmpty(str))
-				{
-					str = "MEDIUM";
-				}
-				else
-				{
-					str += ":MEDIUM";
-				}
-			}
-			if (!FIPSmode && ((sslStrength & SslStrength.Low) == SslStrength.Low))
-			{
-				if (String.IsNullOrEmpty(str))
-				{
-					str = "LOW";
-				}
-				else
-				{
-					str += ":LOW";
-				}
-			}
-			if ((sslProtocols == SslProtocols.Default) ||
-				(sslProtocols == SslProtocols.Tls) ||
-				(sslProtocols == SslProtocols.Ssl3))
-			{
-				if (String.IsNullOrEmpty(str))
-				{
-					str = "!SSLv2";
-				}
-				else
-				{
-					str += ":!SSLv2";
-				}
-			}
-			if (FIPSmode)
-			{
-				str += ":AES:3DES:SHA:!DES:!MD5:!IDEA:!RC2:!RC4";
-			}
-
-			// Now format the return string
-			return String.Format("{0}:!ADH:!aNULL:!eNULL:@STRENGTH", str);
-		}
-
 	}
 }
Index: ManagedOpenSsl/SSL/SslStreamClient.cs
===================================================================
--- ManagedOpenSsl/SSL/SslStreamClient.cs	(revision 47839)
+++ ManagedOpenSsl/SSL/SslStreamClient.cs	(revision 47851)
@@ -23,26 +23,24 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-using System.IO;
 using OpenSSL.Core;
 using OpenSSL.Crypto;
+using OpenSSL.Extensions;
 using OpenSSL.X509;
+using System.IO;
+using OpenSSL;
+using System;
 
 namespace OpenSSL.SSL
 {
-	class SslStreamClient : SslStreamBase
+	internal class SslStreamClient : SslStreamBase
 	{
 		string targetHost;
 		X509List clientCertificates;
 		X509Chain caCertificates;
-		// Internal callback for client certificate selection
-		protected ClientCertCallbackHandler internalCertificateSelectionCallback;
 
-		public SslStreamClient(Stream stream,
-			bool ownStream,
+		public SslStreamClient(
+			Stream stream,
 			string targetHost,
 			X509List clientCertificates,
 			X509Chain caCertificates,
@@ -50,55 +48,70 @@
 			SslStrength sslStrength,
 			bool checkCertificateRevocationStatus,
 			RemoteCertificateValidationHandler remoteCallback,
-			LocalCertificateSelectionHandler localCallback)
-			: base(stream, ownStream)
+			LocalCertificateSelectionHandler localCallback) : base(stream)
 		{
 			this.targetHost = targetHost;
 			this.clientCertificates = clientCertificates;
 			this.caCertificates = caCertificates;
 			this.checkCertificateRevocationStatus = checkCertificateRevocationStatus;
-			this.remoteCertificateSelectionCallback = remoteCallback;
-			this.localCertificateSelectionCallback = localCallback;
-			this.internalCertificateSelectionCallback = new ClientCertCallbackHandler(InternalClientCertificateSelectionCallback);
-			InitializeClientContext(clientCertificates, enabledSslProtocols, sslStrength, checkCertificateRevocationStatus);
+			OnRemoteCertificate = remoteCallback;
+			OnLocalCertificate = localCallback;
+			InitializeClientContext(
+				clientCertificates, 
+				enabledSslProtocols, 
+				sslStrength, 
+				checkCertificateRevocationStatus
+			);
 		}
 
-		protected void InitializeClientContext(X509List certificates, SslProtocols enabledSslProtocols, SslStrength sslStrength, bool checkCertificateRevocation)
+		protected void InitializeClientContext(
+			X509List certificates,
+			SslProtocols enabledSslProtocols,
+			SslStrength sslStrength,
+			bool checkCertificateRevocation)
 		{
-			// Initialize the context with the specified ssl version
-			// Initialize the context
-			sslContext = new SslContext(SslMethod.SSLv23_client_method);
+			// Initialize the context with specified TLS version
+			sslContext = new SslContext(SslMethod.TLSv12_client_method, ConnectionEnd.Client, new[] {
+				Protocols.Http2,
+				Protocols.Http1
+			});
+            
+			var options = sslContext.Options;
 
 			// Remove support for protocols not specified in the enabledSslProtocols
-			if ((enabledSslProtocols & SslProtocols.Ssl2) != SslProtocols.Ssl2)
+			if (!EnumExtensions.HasFlag(enabledSslProtocols, SslProtocols.Ssl2))
 			{
-				sslContext.Options |= SslOptions.SSL_OP_NO_SSLv2;
+				options |= SslOptions.SSL_OP_NO_SSLv2;
 			}
-			if ((enabledSslProtocols & SslProtocols.Ssl3) != SslProtocols.Ssl3 &&
-				((enabledSslProtocols & SslProtocols.Default) != SslProtocols.Default))
+
+			if (!EnumExtensions.HasFlag(enabledSslProtocols, SslProtocols.Ssl3))
 			{
-				// no SSLv3 support
-				sslContext.Options |= SslOptions.SSL_OP_NO_SSLv3;
+				options |= SslOptions.SSL_OP_NO_SSLv3;
 			}
-			if ((enabledSslProtocols & SslProtocols.Tls) != SslProtocols.Tls &&
-				(enabledSslProtocols & SslProtocols.Default) != SslProtocols.Default)
+
+			if (!EnumExtensions.HasFlag(enabledSslProtocols, SslProtocols.Tls))
 			{
-				sslContext.Options |= SslOptions.SSL_OP_NO_TLSv1;
+				options |= SslOptions.SSL_OP_NO_TLSv1;
 			}
 
+			sslContext.Options = options;
+
 			// Set the Local certificate selection callback
-			sslContext.SetClientCertCallback(this.internalCertificateSelectionCallback);
+			sslContext.SetClientCertCallback(OnClientCertificate);
 			// Set the enabled cipher list
-			sslContext.SetCipherList(GetCipherString(false, enabledSslProtocols, sslStrength));
+			sslContext.SetCipherList(SslCipher.MakeString(enabledSslProtocols, sslStrength));
 			// Set the callbacks for remote cert verification and local cert selection
-			if (remoteCertificateSelectionCallback != null)
+			if (OnRemoteCertificate != null)
 			{
-				sslContext.SetVerify(VerifyMode.SSL_VERIFY_PEER | VerifyMode.SSL_VERIFY_FAIL_IF_NO_PEER_CERT, remoteCertificateSelectionCallback);
+				sslContext.SetVerify(
+					VerifyMode.SSL_VERIFY_PEER |
+					VerifyMode.SSL_VERIFY_FAIL_IF_NO_PEER_CERT, 
+					OnRemoteCertificate);
 			}
 			// Set the CA list into the store
 			if (caCertificates != null)
 			{
-				X509Store store = new X509Store(caCertificates);
+				var store = new X509Store(caCertificates);
 				sslContext.SetCertificateStore(store);
 			}
 			// Set up the read/write bio's
@@ -105,6 +118,10 @@
 			read_bio = BIO.MemoryBuffer(false);
 			write_bio = BIO.MemoryBuffer(false);
 			ssl = new Ssl(sslContext);
+
+			sniCb = sniExt.ClientSniCb;
+			sniExt.AttachSniExtensionClient(ssl.Handle, sslContext.Handle, sniCb);
+
 			ssl.SetBIO(read_bio, write_bio);
 			read_bio.SetClose(BIO.CloseOption.Close);
 			write_bio.SetClose(BIO.CloseOption.Close);
@@ -114,28 +131,23 @@
 
 		internal protected override bool ProcessHandshake()
 		{
-			bool ret = false;
+			var ret = false;
+			var nRet = 0;
 
-			// Check to see if we have an exception from the previous call
-			//!!if (handshakeException != null)
-			//!!{
-			//!!    throw handshakeException;
-			//!!}
-
-			int nRet = 0;
 			if (handShakeState == HandshakeState.InProcess)
 			{
 				nRet = ssl.Connect();
 			}
 			else if (handShakeState == HandshakeState.RenegotiateInProcess ||
-					 handShakeState == HandshakeState.Renegotiate)
+			         handShakeState == HandshakeState.Renegotiate)
 			{
 				handShakeState = HandshakeState.RenegotiateInProcess;
 				nRet = ssl.DoHandshake();
 			}
+
 			if (nRet <= 0)
 			{
-				SslError lastError = ssl.GetError(nRet);
+				var lastError = ssl.GetError(nRet);
 				if (lastError == SslError.SSL_ERROR_WANT_READ)
 				{
 					// Do nothing -- the base stream will write the data from the bio
@@ -166,27 +178,33 @@
 				// Successful handshake
 				ret = true;
 			}
+
 			return ret;
 		}
 
-		public int InternalClientCertificateSelectionCallback(Ssl ssl, out X509Certificate x509_cert, out CryptoKey key)
+		private int OnClientCertificate(Ssl ssl, out X509Certificate x509_cert, out CryptoKey key)
 		{
-			int nRet = 0;
 			x509_cert = null;
 			key = null;
 
-			Core.Stack<X509Name> name_stack = ssl.CAList;
-			string[] strIssuers = new string[name_stack.Count];
-			int count = 0;
+			var name_stack = ssl.CAList;
+			var strIssuers = new string[name_stack.Count];
+			var count = 0;
 
-			foreach (X509Name name in name_stack)
+			foreach (var name in name_stack)
 			{
 				strIssuers[count++] = name.OneLine;
 			}
 
-			if (localCertificateSelectionCallback != null)
+			if (OnLocalCertificate != null)
 			{
-				X509Certificate cert = localCertificateSelectionCallback(this, targetHost, clientCertificates, ssl.GetPeerCertificate(), strIssuers);
+				var cert = OnLocalCertificate(
+					           this, 
+					           targetHost, 
+					           clientCertificates, 
+					           ssl.GetPeerCertificate(), 
+					           strIssuers
+				           );
 				if (cert != null && cert.HasPrivateKey)
 				{
 					x509_cert = cert;
@@ -195,11 +213,11 @@
 					x509_cert.AddRef();
 					key.AddRef();
 					// return success
-					nRet = 1;
+					return 1;
 				}
 			}
 
-			return nRet;
+			return 0;
 		}
 	}
 }
Index: ManagedOpenSsl/SSL/SslStreamServer.cs
===================================================================
--- ManagedOpenSsl/SSL/SslStreamServer.cs	(revision 47839)
+++ ManagedOpenSsl/SSL/SslStreamServer.cs	(revision 47851)
@@ -23,189 +23,179 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
+using OpenSSL.X509;
 using System;
-using System.Collections.Generic;
+using System.IO;
 using System.Text;
-using System.IO;
-using OpenSSL.Core;
-using OpenSSL.X509;
+using OpenSSL;
 
 namespace OpenSSL.SSL
 {
-    class SslStreamServer : SslStreamBase
-    {
-        public SslStreamServer(
-            Stream stream, 
-            bool ownStream,
-            X509Certificate serverCertificate,
-            bool clientCertificateRequired,
-            X509Chain caCerts,
-            SslProtocols enabledSslProtocols,
-            SslStrength sslStrength,
-            bool checkCertificateRevocation,
-            RemoteCertificateValidationHandler remote_callback)
-            : base(stream, ownStream)
-        {
-            this.checkCertificateRevocationStatus = checkCertificateRevocation;
-            this.remoteCertificateSelectionCallback = remote_callback;
+	internal class SslStreamServer : SslStreamBase
+	{
+		public SslStreamServer(
+			Stream stream, 
+			X509Certificate serverCertificate,
+			bool clientCertificateRequired,
+			X509Chain caCerts,
+			SslProtocols enabledSslProtocols,
+			SslStrength sslStrength,
+			bool checkCertificateRevocation,
+			RemoteCertificateValidationHandler remote_callback) : base(stream)
+		{
+			checkCertificateRevocationStatus = checkCertificateRevocation;
+			OnRemoteCertificate = remote_callback;
 
-            // Initialize the SslContext object
-            InitializeServerContext(serverCertificate, clientCertificateRequired, caCerts, enabledSslProtocols, sslStrength, checkCertificateRevocation);
+			// Initialize the SslContext object
+			InitializeServerContext(
+				serverCertificate, 
+				clientCertificateRequired, 
+				caCerts, 
+				enabledSslProtocols, 
+				sslStrength, 
+				checkCertificateRevocation);
             
-            // Initalize the Ssl object
-            ssl = new Ssl(sslContext);
-            // Initialze the read/write bio
-            read_bio = BIO.MemoryBuffer(false);
-            write_bio = BIO.MemoryBuffer(false);
-            // Set the read/write bio's into the the Ssl object
-            ssl.SetBIO(read_bio, write_bio);
-            read_bio.SetClose(BIO.CloseOption.Close);
-            write_bio.SetClose(BIO.CloseOption.Close);
-            // Set the Ssl object into server mode
-            ssl.SetAcceptState();
-        }
+			// Initalize the Ssl object
+			ssl = new Ssl(sslContext);
 
-        internal protected override bool ProcessHandshake()
-        {
-            bool bRet = false;
-            int nRet = 0;
+			sniCb = sniExt.ServerSniCb;
+			sniExt.AttachSniExtensionServer(ssl.Handle, sslContext.Handle, sniCb);
+
+			// Initialze the read/write bio
+			read_bio = BIO.MemoryBuffer(false);
+			write_bio = BIO.MemoryBuffer(false);
+			// Set the read/write bio's into the the Ssl object
+			ssl.SetBIO(read_bio, write_bio);
+			read_bio.SetClose(BIO.CloseOption.Close);
+			write_bio.SetClose(BIO.CloseOption.Close);
+			// Set the Ssl object into server mode
+			ssl.SetAcceptState();
+		}
+
+		internal protected override bool ProcessHandshake()
+		{
+			var nRet = 0;
             
-            if (handShakeState == HandshakeState.InProcess)
-            {
-                nRet = ssl.Accept();
-            }
-            else if (handShakeState == HandshakeState.RenegotiateInProcess)
-            {
-                nRet = ssl.DoHandshake();
-            }
-            else if (handShakeState == HandshakeState.Renegotiate)
-            {
-                nRet = ssl.DoHandshake();
-                ssl.State = Ssl.SSL_ST_ACCEPT;
-                handShakeState = HandshakeState.RenegotiateInProcess;
-            }
-            SslError lastError = ssl.GetError(nRet);
-            if (lastError == SslError.SSL_ERROR_WANT_READ || lastError == SslError.SSL_ERROR_WANT_WRITE || lastError == SslError.SSL_ERROR_NONE)
-            {
-                if (nRet == 1) // success
-                {
-                    bRet = true;
-                }
-            }
-            else
-            {
-                // Check to see if we have alert data in the write_bio that needs to be sent
-                if (write_bio.BytesPending > 0)
-                {
-                    // We encountered an error, but need to send the alert
-                    // set the handshakeException so that it will be processed
-                    // and thrown after the alert is sent
-                    handshakeException = new OpenSslException();
-                }
-                else
-                {
-                    // No alert to send, throw the exception
-                    throw new OpenSslException();
-                }
-            }
-            return bRet;
-        }
+			if (handShakeState == HandshakeState.InProcess)
+			{
+				nRet = ssl.Accept();
+			}
+			else if (handShakeState == HandshakeState.RenegotiateInProcess)
+			{
+				nRet = ssl.DoHandshake();
+			}
+			else if (handShakeState == HandshakeState.Renegotiate)
+			{
+				nRet = ssl.DoHandshake();
+				ssl.State = Ssl.SSL_ST_ACCEPT;
+				handShakeState = HandshakeState.RenegotiateInProcess;
+			}
 
-        private void InitializeServerContext(
-            X509Certificate serverCertificate,
-            bool clientCertificateRequired,
-            X509Chain caCerts,
-            SslProtocols enabledSslProtocols,
-            SslStrength sslStrength,
-            bool checkCertificateRevocation)
-        {
-            if (serverCertificate == null)
-            {
-                throw new ArgumentNullException("serverCertificate", "Server certificate cannot be null");
-            }
-            if (!serverCertificate.HasPrivateKey)
-            {
-                throw new ArgumentException("Server certificate must have a private key", "serverCertificate");
-            }
+			var lastError = ssl.GetError(nRet);
+			if (lastError == SslError.SSL_ERROR_WANT_READ || 
+				lastError == SslError.SSL_ERROR_WANT_WRITE || 
+				lastError == SslError.SSL_ERROR_NONE)
+			{
+				return nRet == 1;
+			}
 
-            // Initialize the context
-            sslContext = new SslContext(SslMethod.SSLv23_server_method);
+			// Check to see if we have alert data in the write_bio that needs to be sent
+			if (write_bio.BytesPending > 0)
+			{
+				// We encountered an error, but need to send the alert
+				// set the handshakeException so that it will be processed
+				// and thrown after the alert is sent
+				handshakeException = new OpenSslException();
+				return false;
+			}
+
+			// No alert to send, throw the exception
+			throw new OpenSslException();
+		}
+
+		private void InitializeServerContext(
+			X509Certificate serverCertificate,
+			bool clientCertificateRequired,
+			X509Chain caCerts,
+			SslProtocols enabledSslProtocols,
+			SslStrength sslStrength,
+			bool checkCertificateRevocation)
+		{
+			if (serverCertificate == null)
+			{
+				throw new ArgumentNullException("serverCertificate", "Server certificate cannot be null");
+			}
+			if (!serverCertificate.HasPrivateKey)
+			{
+				throw new ArgumentException("Server certificate must have a private key", "serverCertificate");
+			}
+
+			// Initialize the context with specified TLS version
+			sslContext = new SslContext(SslMethod.TLSv12_server_method, ConnectionEnd.Server, new[] {
+				Protocols.Http2,
+				Protocols.Http1
+			});
             
-            // Remove support for protocols not specified in the enabledSslProtocols
-            if ((enabledSslProtocols & SslProtocols.Ssl2) != SslProtocols.Ssl2)
-            {
-                sslContext.Options |= SslOptions.SSL_OP_NO_SSLv2;
-            }
-            if ((enabledSslProtocols & SslProtocols.Ssl3) != SslProtocols.Ssl3 &&
-                ((enabledSslProtocols & SslProtocols.Default) != SslProtocols.Default))
-            {
-                // no SSLv3 support
-                sslContext.Options |= SslOptions.SSL_OP_NO_SSLv3;
-            }
-            if ((enabledSslProtocols & SslProtocols.Tls) != SslProtocols.Tls &&
-                (enabledSslProtocols & SslProtocols.Default) != SslProtocols.Default)
-            {
-                sslContext.Options |= SslOptions.SSL_OP_NO_TLSv1;
-            }
-            /*
-            // Initialize the context with the specified ssl version
-            switch (enabledSslProtocols)
-            {
-                case SslProtocols.None:
-                    throw new ArgumentException("SslProtocol.None is not supported", "enabledSslProtocols");
-                    break;
-                case SslProtocols.Ssl2:
-                    sslContext = new SslContext(SslMethod.SSLv2_server_method);
-                    break;
-                case SslProtocols.Ssl3:
-                case SslProtocols.Default:
-                    sslContext = new SslContext(SslMethod.SSLv3_server_method);
-                    break;
-                case SslProtocols.Tls:
-                    sslContext = new SslContext(SslMethod.TLSv1_server_method);
-                    break;
-            }
-            */
-            // Set the context mode
-            sslContext.Mode = SslMode.SSL_MODE_AUTO_RETRY;
-            // Set the workaround options
-            sslContext.Options = SslOptions.SSL_OP_ALL;
-            // Set the client certificate verification callback if we are requiring client certs
-            if (clientCertificateRequired)
-            {
-                sslContext.SetVerify(VerifyMode.SSL_VERIFY_PEER | VerifyMode.SSL_VERIFY_FAIL_IF_NO_PEER_CERT, remoteCertificateSelectionCallback);
-            }
-            else
-            {
-                sslContext.SetVerify(VerifyMode.SSL_VERIFY_NONE, null);
-            }
+			var options = sslContext.Options;
 
-            // Set the client certificate max verification depth
-            sslContext.SetVerifyDepth(10);
-            // Set the certificate store and ca list
-            if (caCerts != null)
-            {
-                // Don't take ownership of the X509Store IntPtr.  When we
-                // SetCertificateStore, the context takes ownership of the store pointer.
-                X509Store cert_store = new X509Store(caCerts, false);
-                sslContext.SetCertificateStore(cert_store);
-                Core.Stack<X509Name> name_stack = new Core.Stack<X509Name>();
-                foreach (X509Certificate cert in caCerts)
-                {
-                    X509Name subject = cert.Subject;
-                    name_stack.Add(subject);
-                }
-                // Assign the stack to the context
-                sslContext.CAList = name_stack;
-            }
-            // Set the cipher string
-            sslContext.SetCipherList(GetCipherString(false, enabledSslProtocols, sslStrength));
-            // Set the certificate
-            sslContext.UseCertificate(serverCertificate);
-            // Set the private key
-            sslContext.UsePrivateKey(serverCertificate.PrivateKey);
-            // Set the session id context
-            sslContext.SetSessionIdContext(Encoding.ASCII.GetBytes(AppDomain.CurrentDomain.FriendlyName));
-        }
-    }
+			// Remove support for protocols not specified in the enabledSslProtocols
+			if (!EnumExtensions.HasFlag(enabledSslProtocols, SslProtocols.Ssl2))
+			{
+				options |= SslOptions.SSL_OP_NO_SSLv2;
+			}
+
+			if (!EnumExtensions.HasFlag(enabledSslProtocols, SslProtocols.Ssl3))
+			{
+				options |= SslOptions.SSL_OP_NO_SSLv3;
+			}
+
+			if (!EnumExtensions.HasFlag(enabledSslProtocols, SslProtocols.Tls))
+			{
+				options |= SslOptions.SSL_OP_NO_TLSv1;
+			}
+
+			// Set the workaround options
+			sslContext.Options = options | SslOptions.SSL_OP_ALL;
+
+			// Set the context mode
+			sslContext.Mode = SslMode.SSL_MODE_AUTO_RETRY;
+
+			// Set the client certificate verification callback if we are requiring client certs
+			if (clientCertificateRequired)
+			{
+				sslContext.SetVerify(VerifyMode.SSL_VERIFY_PEER | VerifyMode.SSL_VERIFY_FAIL_IF_NO_PEER_CERT, OnRemoteCertificate);
+			}
+			else
+			{
+				sslContext.SetVerify(VerifyMode.SSL_VERIFY_NONE, null);
+			}
+
+			// Set the client certificate max verification depth
+			sslContext.SetVerifyDepth(10);
+			// Set the certificate store and ca list
+			if (caCerts != null)
+			{
+				// Don't take ownership of the X509Store IntPtr.  When we
+				// SetCertificateStore, the context takes ownership of the store pointer.
+				sslContext.SetCertificateStore(new X509Store(caCerts, false));
+				var name_stack = new Core.Stack<X509Name>();
+				foreach (var cert in caCerts)
+				{
+					var subject = cert.Subject;
+					name_stack.Add(subject);
+				}
+				// Assign the stack to the context
+				sslContext.CAList = name_stack;
+			}
+			// Set the cipher string
+			sslContext.SetCipherList(SslCipher.MakeString(enabledSslProtocols, sslStrength));
+			// Set the certificate
+			sslContext.UseCertificate(serverCertificate);
+			// Set the private key
+			sslContext.UsePrivateKey(serverCertificate.PrivateKey);
+			// Set the session id context
+			sslContext.SetSessionIdContext(Encoding.ASCII.GetBytes(AppDomain.CurrentDomain.FriendlyName));
+		}
+	}
 }
Index: ManagedOpenSsl/App.config
===================================================================
--- ManagedOpenSsl/App.config	(revision 47839)
+++ ManagedOpenSsl/App.config	(revision 47851)
@@ -1,6 +1,9 @@
-<configuration>
-	<dllmap os="osx" dll="libeay32" target="libcrypto.dylib"/>
-	<dllmap os="osx" dll="ssleay32" target="libssl.dylib"/>
-	<dllmap os="!windows,osx" dll="libeay32" target="libcrypto.so"/>
-	<dllmap os="!windows,osx" dll="ssleay32" target="libssl.so"/>
-</configuration>
+<configuration>
+	<dllmap os="osx" dll="libeay32" target="libcrypto.1.0.0.dylib"/>
+	<dllmap os="osx" dll="ssleay32" target="libssl.1.0.0.dylib"/>
+	<dllmap os="!windows,osx" dll="libeay32" target="libcrypto.so"/>
+	<dllmap os="!windows,osx" dll="ssleay32" target="libssl.so"/>
+	<startup>
+		<supportedRuntime version="v4.0" sku=".NETFramework,Version=v4.0,Profile=Client"/>
+	</startup>
+</configuration>
Index: ManagedOpenSsl/Crypto/Cipher.cs
===================================================================
--- ManagedOpenSsl/Crypto/Cipher.cs	(revision 47839)
+++ ManagedOpenSsl/Crypto/Cipher.cs	(revision 47851)
@@ -21,14 +21,13 @@
 // DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+using System.IO;
+using OpenSSL.Core;
 using System;
-using System.Collections.Generic;
+using System.Runtime.InteropServices;
 using System.Text;
-using System.Runtime.InteropServices;
-using System.IO;
-using OpenSSL.Core;
 
 namespace OpenSSL.Crypto
 {
@@ -39,9 +38,10 @@
 	public class Cipher : Base
 	{
 		private EVP_CIPHER raw;
-		internal Cipher(IntPtr ptr, bool owner) : base(ptr, owner) 
+		internal Cipher(IntPtr ptr, bool owner)
+			: base(ptr, owner)
 		{
-			this.raw = (EVP_CIPHER)Marshal.PtrToStructure(this.ptr, typeof(EVP_CIPHER));
+			raw = (EVP_CIPHER)Marshal.PtrToStructure(this.ptr, typeof(EVP_CIPHER));
 		}
 
 		/// <summary>
@@ -50,13 +50,14 @@
 		/// <param name="bio"></param>
 		public override void Print(BIO bio)
 		{
-			bio.Write(this.LongName);
+			bio.Write(LongName);
 		}
 
 		/// <summary>
 		/// Not implemented, these objects should never be disposed
 		/// </summary>
-		protected override void OnDispose() {
+		protected override void OnDispose()
+		{
 			throw new NotImplementedException();
 		}
 
@@ -67,10 +68,12 @@
 		/// <returns></returns>
 		public static Cipher CreateByName(string name)
 		{
-			byte[] buf = Encoding.ASCII.GetBytes(name);
-			IntPtr ptr = Native.EVP_get_cipherbyname(buf);
-			if(ptr == IntPtr.Zero)
+			var buf = Encoding.ASCII.GetBytes(name);
+			var ptr = Native.EVP_get_cipherbyname(buf);
+
+			if (ptr == IntPtr.Zero)
 				return null;
+
 			return new Cipher(ptr, false);
 		}
 
@@ -77,7 +80,7 @@
 		/// <summary>
 		/// Calls OBJ_NAME_do_all_sorted(OBJ_NAME_TYPE_CIPHER_METH)
 		/// </summary>
-		public static string[] AllNamesSorted 
+		public static string[] AllNamesSorted
 		{
 			get { return new NameCollector(Native.OBJ_NAME_TYPE_CIPHER_METH, true).Result.ToArray(); }
 		}
@@ -85,7 +88,7 @@
 		/// <summary>
 		/// Calls OBJ_NAME_do_all(OBJ_NAME_TYPE_CIPHER_METH)
 		/// </summary>
-		public static string[] AllNames 
+		public static string[] AllNames
 		{
 			get { return new NameCollector(Native.OBJ_NAME_TYPE_CIPHER_METH, false).Result.ToArray(); }
 		}
@@ -106,7 +109,7 @@
 			public IntPtr set_asn1_parameters;
 			public IntPtr get_asn1_parameters;
 			public IntPtr ctrl;
-			public IntPtr app_data;		
+			public IntPtr app_data;
 		}
 		#endregion
 
@@ -125,187 +128,187 @@
 		/// EVP_des_ede()
 		/// </summary>
 		public static Cipher DES_EDE = new Cipher(Native.EVP_des_ede(), false);
-	
+
 		/// <summary>
 		/// EVP_des_ede3()
 		/// </summary>
 		public static Cipher DES_EDE3 = new Cipher(Native.EVP_des_ede3(), false);
-		
+
 		/// <summary>
 		/// EVP_des_ede_ecb()
 		/// </summary>
 		public static Cipher DES_EDE_ECB = new Cipher(Native.EVP_des_ede_ecb(), false);
-		
+
 		/// <summary>
 		/// EVP_des_ede3_ecb()
 		/// </summary>
 		public static Cipher DES_EDE3_ECB = new Cipher(Native.EVP_des_ede3_ecb(), false);
-		
+
 		/// <summary>
 		/// EVP_des_cfb64()
 		/// </summary>
 		public static Cipher DES_CFB64 = new Cipher(Native.EVP_des_cfb64(), false);
-		
+
 		/// <summary>
 		/// EVP_des_cfb1()
 		/// </summary>
 		public static Cipher DES_CFB1 = new Cipher(Native.EVP_des_cfb1(), false);
-		
+
 		/// <summary>
 		/// EVP_des_cfb8()
 		/// </summary>
 		public static Cipher DES_CFB8 = new Cipher(Native.EVP_des_cfb8(), false);
-		
+
 		/// <summary>
 		/// EVP_des_ede_cfb64()
 		/// </summary>
 		public static Cipher DES_EDE_CFB64 = new Cipher(Native.EVP_des_ede_cfb64(), false);
-		
+
 		/// <summary>
 		/// EVP_des_ede3_cfb64()
 		/// </summary>
 		public static Cipher DES_EDE3_CFB64 = new Cipher(Native.EVP_des_ede3_cfb64(), false);
-		
+
 		/// <summary>
 		/// EVP_des_ede3_cfb1()
 		/// </summary>
 		public static Cipher DES_EDE3_CFB1 = new Cipher(Native.EVP_des_ede3_cfb1(), false);
-		
+
 		/// <summary>
 		/// EVP_des_ede3_cfb8()
 		/// </summary>
 		public static Cipher DES_EDE3_CFB8 = new Cipher(Native.EVP_des_ede3_cfb8(), false);
-		
+
 		/// <summary>
 		/// EVP_des_ofb()
 		/// </summary>
 		public static Cipher DES_OFB = new Cipher(Native.EVP_des_ofb(), false);
-		
+
 		/// <summary>
 		/// EVP_ded_ede_ofb()
 		/// </summary>
 		public static Cipher DES_EDE_OFB = new Cipher(Native.EVP_des_ede_ofb(), false);
-		
+
 		/// <summary>
 		/// EVP_des_ede3_ofb()
 		/// </summary>
 		public static Cipher DES_EDE3_OFB = new Cipher(Native.EVP_des_ede3_ofb(), false);
-		
+
 		/// <summary>
 		/// EVP_des_cbc()
 		/// </summary>
 		public static Cipher DES_CBC = new Cipher(Native.EVP_des_cbc(), false);
-		
+
 		/// <summary>
 		/// EVP_des_ede_cbc()
 		/// </summary>
 		public static Cipher DES_EDE_CBC = new Cipher(Native.EVP_des_ede_cbc(), false);
-		
+
 		/// <summary>
 		/// EVP_des_ede3_cbc()
 		/// </summary>
 		public static Cipher DES_EDE3_CBC = new Cipher(Native.EVP_des_ede3_cbc(), false);
-		
+
 		/// <summary>
 		/// EVP_desx_cbc()
 		/// </summary>
 		public static Cipher DESX_CBC = new Cipher(Native.EVP_desx_cbc(), false);
-		
+
 		/// <summary>
 		/// EVP_rc4()
 		/// </summary>
 		public static Cipher RC4 = new Cipher(Native.EVP_rc4(), false);
-		
+
 		/// <summary>
 		/// EVP_rc4_40()
 		/// </summary>
 		public static Cipher RC4_40 = new Cipher(Native.EVP_rc4_40(), false);
-		
+
 		/// <summary>
 		/// EVP_idea_ecb()
 		/// </summary>
 		public static Cipher Idea_ECB = new Cipher(Native.EVP_idea_ecb(), false);
-		
+
 		/// <summary>
 		/// EVP_idea_cfb64()
 		/// </summary>
 		public static Cipher Idea_CFB64 = new Cipher(Native.EVP_idea_cfb64(), false);
-		
+
 		/// <summary>
 		/// EVP_idea_ofb()
 		/// </summary>
 		public static Cipher Idea_OFB = new Cipher(Native.EVP_idea_ofb(), false);
-		
+
 		/// <summary>
 		/// EVP_idea_cbc()
 		/// </summary>
 		public static Cipher Idea_CBC = new Cipher(Native.EVP_idea_cbc(), false);
-		
+
 		/// <summary>
 		/// EVP_rc2_ecb()
 		/// </summary>
 		public static Cipher RC2_ECB = new Cipher(Native.EVP_rc2_ecb(), false);
-		
+
 		/// <summary>
 		/// EVP_rc2_cbc()
 		/// </summary>
 		public static Cipher RC2_CBC = new Cipher(Native.EVP_rc2_cbc(), false);
-		
+
 		/// <summary>
 		/// EVP_rc2_40_cbc()
 		/// </summary>
 		public static Cipher RC2_40_CBC = new Cipher(Native.EVP_rc2_40_cbc(), false);
-		
+
 		/// <summary>
 		/// EVP_rc2_64_cbc()
 		/// </summary>
 		public static Cipher RC2_64_CBC = new Cipher(Native.EVP_rc2_64_cbc(), false);
-		
+
 		/// <summary>
 		/// EVP_rc2_cfb64()
 		/// </summary>
 		public static Cipher RC2_CFB64 = new Cipher(Native.EVP_rc2_cfb64(), false);
-		
+
 		/// <summary>
 		/// EVP_rc2_ofb()
 		/// </summary>
 		public static Cipher RC2_OFB = new Cipher(Native.EVP_rc2_ofb(), false);
-		
+
 		/// <summary>
 		/// EVP_bf_ecb()
 		/// </summary>
 		public static Cipher Blowfish_ECB = new Cipher(Native.EVP_bf_ecb(), false);
-		
+
 		/// <summary>
 		/// EVP_bf_cbc()
 		/// </summary>
 		public static Cipher Blowfish_CBC = new Cipher(Native.EVP_bf_cbc(), false);
-		
+
 		/// <summary>
 		/// EVP_bf_cfb64()
 		/// </summary>
 		public static Cipher Blowfish_CFB64 = new Cipher(Native.EVP_bf_cfb64(), false);
-		
+
 		/// <summary>
 		/// EVP_bf_ofb()
 		/// </summary>
 		public static Cipher Blowfish_OFB = new Cipher(Native.EVP_bf_ofb(), false);
-		
+
 		/// <summary>
 		/// EVP_cast5_ecb()
 		/// </summary>
 		public static Cipher Cast5_ECB = new Cipher(Native.EVP_cast5_ecb(), false);
-		
+
 		/// <summary>
 		/// EVP_cast5_cbc()
 		/// </summary>
 		public static Cipher Cast5_CBC = new Cipher(Native.EVP_cast5_cbc(), false);
-		
+
 		/// <summary>
 		/// EVP_cast5_cfb64()
 		/// </summary>
 		public static Cipher Cast5_OFB64 = new Cipher(Native.EVP_cast5_cfb64(), false);
-		
+
 		/// <summary>
 		/// EVP_cast5_ofb()
 		/// </summary>
@@ -407,7 +410,7 @@
 		/// EVP_aes_256_ofb()
 		/// </summary>
 		public static Cipher AES_256_OFB = new Cipher(Native.EVP_aes_256_ofb(), false);
-		
+
 		#endregion
 
 		#region Properties
@@ -417,7 +420,7 @@
 		/// </summary>
 		public int KeyLength
 		{
-			get { return this.raw.key_len; }
+			get { return raw.key_len; }
 		}
 
 		/// <summary>
@@ -425,7 +428,7 @@
 		/// </summary>
 		public int IVLength
 		{
-			get { return this.raw.iv_len; }
+			get { return raw.iv_len; }
 		}
 
 		/// <summary>
@@ -433,7 +436,7 @@
 		/// </summary>
 		public int BlockSize
 		{
-			get { return this.raw.block_size; }
+			get { return raw.block_size; }
 		}
 
 		/// <summary>
@@ -441,7 +444,7 @@
 		/// </summary>
 		public uint Flags
 		{
-			get { return this.raw.flags; }
+			get { return raw.flags; }
 		}
 
 		/// <summary>
@@ -449,7 +452,7 @@
 		/// </summary>
 		public string LongName
 		{
-			get { return Native.OBJ_nid2ln(this.raw.nid); }
+			get { return Native.StaticString(Native.OBJ_nid2ln(raw.nid)); }
 		}
 
 		/// <summary>
@@ -457,7 +460,7 @@
 		/// </summary>
 		public string Name
 		{
-			get { return Native.OBJ_nid2sn(this.raw.nid); }
+			get { return Native.StaticString(Native.OBJ_nid2sn(raw.nid)); }
 		}
 
 		/// <summary>
@@ -465,7 +468,7 @@
 		/// </summary>
 		public int Type
 		{
-			get { return Native.EVP_CIPHER_type(this.ptr); }
+			get { return Native.EVP_CIPHER_type(ptr); }
 		}
 
 		/// <summary>
@@ -473,7 +476,7 @@
 		/// </summary>
 		public string TypeName
 		{
-			get { return Native.OBJ_nid2ln(this.Type); }
+			get { return Native.StaticString(Native.OBJ_nid2ln(Type)); }
 		}
 		#endregion
 	}
@@ -487,7 +490,7 @@
 		/// <summary>
 		/// The key for a crypto operation
 		/// </summary>
-		public ArraySegment<byte>[] Keys;
+		public byte[][] Keys;
 
 		/// <summary>
 		/// The IV (Initialization Vector)
@@ -543,7 +546,7 @@
 		public CipherContext(Cipher cipher)
 			: base(Native.OPENSSL_malloc(Marshal.SizeOf(typeof(EVP_CIPHER_CTX))), true)
 		{
-			Native.EVP_CIPHER_CTX_init(this.ptr);
+			Native.EVP_CIPHER_CTX_init(ptr);
 			this.cipher = cipher;
 		}
 
@@ -553,7 +556,7 @@
 		/// <param name="bio"></param>
 		public override void Print(BIO bio)
 		{
-			bio.Write("CipherContext: " + this.cipher.LongName);
+			bio.Write("CipherContext: " + cipher.LongName);
 		}
 
 		#region Methods
@@ -562,21 +565,26 @@
 		/// Calls EVP_OpenInit() and EVP_OpenFinal()
 		/// </summary>
 		/// <param name="input"></param>
+		/// <param name="ekey"></param>
 		/// <param name="iv"></param>
 		/// <param name="pkey"></param>
 		/// <returns></returns>
-		public byte[] Open(byte[] input, byte[] iv, CryptoKey pkey) 
+		public byte[] Open(byte[] input, byte[] ekey, byte[] iv, CryptoKey pkey)
 		{
 			Native.ExpectSuccess(Native.EVP_OpenInit(
-				this.ptr, this.cipher.Handle, input, input.Length, iv, pkey.Handle));
+				ptr, cipher.Handle, ekey, ekey.Length, iv, pkey.Handle));
 
+			var memory = new MemoryStream();
+			var output = new byte[input.Length + Cipher.BlockSize];
 			int len;
-			Native.ExpectSuccess(Native.EVP_OpenFinal(this.ptr, null, out len));
 
-			byte[] output = new byte[len];
-			Native.ExpectSuccess(Native.EVP_OpenFinal(this.ptr, output, out len));
+			Native.ExpectSuccess(Native.EVP_DecryptUpdate(ptr, output, out len, input, input.Length));
+			memory.Write(output, 0, len);
 
-			return output;
+			Native.ExpectSuccess(Native.EVP_OpenFinal(ptr, output, out len));
+			memory.Write(output, 0, len);
+
+			return memory.ToArray();
 		}
 
 		/// <summary>
@@ -583,41 +591,63 @@
 		/// Calls EVP_SealInit() and EVP_SealFinal()
 		/// </summary>
 		/// <param name="pkeys"></param>
-		/// <param name="needsIV"></param>
+		/// <param name="input"></param>
 		/// <returns></returns>
-		public Envelope Seal(CryptoKey[] pkeys, bool needsIV) 
+		public Envelope Seal(CryptoKey[] pkeys, byte[] input)
 		{
-			Envelope ret = new Envelope();
-			byte[][] bufs = new byte[pkeys.Length][];
-			int[] lens = new int[pkeys.Length];
-			IntPtr[] pubkeys = new IntPtr[pkeys.Length];
-			ret.Keys = new ArraySegment<byte>[pkeys.Length];
-			for (int i = 0; i < pkeys.Length; ++i)
-			{
-				bufs[i] = new byte[pkeys[i].Size];
-				lens[i] = pkeys[i].Size;
-				pubkeys[i] = pkeys[i].Handle;
-			}
+			var env = new Envelope();
 
-			if(needsIV)
-				ret.IV = new byte[this.cipher.IVLength];
+			var ptrs = new IntPtr[pkeys.Length];
 
-			int len;
-			Native.ExpectSuccess(Native.EVP_SealInit(
-				this.ptr, this.cipher.Handle, bufs, lens, ret.IV, pubkeys, pubkeys.Length));
-			for (int i = 0; i < pkeys.Length; ++i)
+			try
 			{
-				ret.Keys[i] = new ArraySegment<byte>(bufs[i], 0, lens[i]);
-			}
+				env.Keys = new byte[pkeys.Length][];
+				var pubkeys = new IntPtr[pkeys.Length];
+				var ekeylens = new int[pkeys.Length];
 
-			Native.ExpectSuccess(Native.EVP_SealFinal(this.ptr, null, out len));
+				for (var i = 0; i < pkeys.Length; i++)
+				{
+					ptrs[i] = Marshal.AllocHGlobal(pkeys[i].Size);
+					pubkeys[i] = pkeys[i].Handle;
+				}
 
-			ret.Data = new byte[len];
-			Native.ExpectSuccess(Native.EVP_SealFinal(this.ptr, ret.Data, out len));
+				if (Cipher.IVLength > 0)
+				{
+					env.IV = new byte[Cipher.IVLength];
+				}
 
-			return ret;
-		}
+				Native.ExpectSuccess(Native.EVP_SealInit(
+					ptr, Cipher.Handle, ptrs, ekeylens, env.IV, pubkeys, pubkeys.Length));
 
+				for (var i = 0; i < pkeys.Length; i++)
+				{
+					env.Keys[i] = new byte[ekeylens[i]];
+					Marshal.Copy(ptrs[i], env.Keys[i], 0, ekeylens[i]);
+				}
+
+				var memory = new MemoryStream();
+				var output = new byte[input.Length + Cipher.BlockSize];
+
+				int len;
+				Native.ExpectSuccess(Native.EVP_EncryptUpdate(ptr, output, out len, input, input.Length));
+				memory.Write(output, 0, len);
+
+				Native.ExpectSuccess(Native.EVP_SealFinal(ptr, output, out len));
+				memory.Write(output, 0, len);
+
+				env.Data = memory.ToArray();
+
+				return env;
+			}
+			finally
+			{
+				foreach (var ptr in ptrs)
+				{
+					Marshal.FreeHGlobal(ptr);
+				}
+			}
+		}
+
 		/// <summary>
 		/// Encrypts or decrypts the specified payload.
 		/// </summary>
@@ -628,56 +658,41 @@
 		/// <returns></returns>
 		public byte[] Crypt(byte[] input, byte[] key, byte[] iv, bool doEncrypt)
 		{
-			return this.Crypt(input, key, iv, doEncrypt, -1);
+			return Crypt(input, key, iv, doEncrypt, -1);
 		}
 
 		private byte[] SetupKey(byte[] key)
 		{
-			byte[] real_key;
-			bool isStreamCipher = (this.cipher.Flags & Native.EVP_CIPH_MODE) == Native.EVP_CIPH_STREAM_CIPHER;
-			if (isStreamCipher)
+			if (key == null)
 			{
-				real_key = new byte[this.Cipher.KeyLength];
-				if (key == null)
-					real_key.Initialize();
-				else
-					Buffer.BlockCopy(key, 0, real_key, 0, Math.Min(key.Length, real_key.Length));
+				key = new byte[Cipher.KeyLength];
+				key.Initialize();
+				return key;
 			}
-			else
+
+			if (Cipher.KeyLength == key.Length)
 			{
-				if (key == null)
-				{
-					real_key = new byte[this.Cipher.KeyLength];
-					real_key.Initialize();
-				}
-				else
-				{
-					if (this.Cipher.KeyLength != key.Length)
-					{
-						real_key = new byte[this.Cipher.KeyLength];
-						real_key.Initialize();
-						Buffer.BlockCopy(key, 0, real_key, 0, Math.Min(key.Length, real_key.Length));
-					}
-					else
-					{
-						real_key = key;
-					}
-				}
-				// FIXME: what was this for??
-//				total += this.cipher.BlockSize;
+				return key;
 			}
+
+			byte[] real_key = new byte[Cipher.KeyLength];
+			real_key.Initialize();
+			Buffer.BlockCopy(key, 0, real_key, 0, Math.Min(key.Length, real_key.Length));
+
 			return real_key;
 		}
 
 		private byte[] SetupIV(byte[] iv)
 		{
-			if (this.cipher.IVLength > iv.Length)
+			if (cipher.IVLength > iv.Length)
 			{
-				byte[] ret = new byte[this.cipher.IVLength];
+				var ret = new byte[cipher.IVLength];
 				ret.Initialize();
 				Buffer.BlockCopy(iv, 0, ret, 0, iv.Length);
+
 				return ret;
 			}
+
 			return iv;
 		}
 
@@ -692,23 +707,21 @@
 		/// <returns></returns>
 		public byte[] Crypt(byte[] input, byte[] key, byte[] iv, bool doEncrypt, int padding)
 		{
-			int enc = doEncrypt ? 1 : 0;
+			var enc = doEncrypt ? 1 : 0;
 
-			int total = Math.Max(input.Length, this.cipher.BlockSize);
-			byte[] real_key = SetupKey(key);
-			byte[] real_iv = SetupIV(iv);
+			var total = Math.Max(input.Length, cipher.BlockSize);
+			var real_key = SetupKey(key);
+			var real_iv = SetupIV(iv);
 
-			byte[] buf = new byte[total];
-			MemoryStream memory = new MemoryStream(total);
+			var buf = new byte[total];
+			var memory = new MemoryStream(total);
 
 			Native.ExpectSuccess(Native.EVP_CipherInit_ex(
-				this.ptr, this.cipher.Handle, IntPtr.Zero, null, null, enc));
-			Native.ExpectSuccess(Native.EVP_CIPHER_CTX_set_key_length(this.ptr, real_key.Length));
-			if (padding >= 0)
-				Native.ExpectSuccess(Native.EVP_CIPHER_CTX_set_padding(this.ptr, padding));
+				ptr, cipher.Handle, IntPtr.Zero, null, null, enc));
 
-			bool isStreamCipher = (this.cipher.Flags & Native.EVP_CIPH_MODE) == Native.EVP_CIPH_STREAM_CIPHER;
-			if (isStreamCipher)
+			Native.ExpectSuccess(Native.EVP_CIPHER_CTX_set_key_length(ptr, real_key.Length));
+
+			if (IsStream)
 			{
 				for (int i = 0; i < Math.Min(real_key.Length, iv.Length); i++)
 				{
@@ -716,29 +729,62 @@
 				}
 
 				Native.ExpectSuccess(Native.EVP_CipherInit_ex(
-					this.ptr, this.cipher.Handle, IntPtr.Zero, real_key, null, enc));
+					ptr, cipher.Handle, IntPtr.Zero, real_key, null, enc));
 			}
 			else
 			{
 				Native.ExpectSuccess(Native.EVP_CipherInit_ex(
-					this.ptr, this.cipher.Handle, IntPtr.Zero, real_key, real_iv, enc));
+					ptr, cipher.Handle, IntPtr.Zero, real_key, real_iv, enc));
 			}
 
-			int len = buf.Length;
-			Native.ExpectSuccess(Native.EVP_CipherUpdate(
-				this.ptr, buf, out len, input, input.Length));
+			if (padding >= 0)
+				Native.ExpectSuccess(Native.EVP_CIPHER_CTX_set_padding(ptr, padding));
 
+			var len = 0;
+			Native.ExpectSuccess(Native.EVP_CipherUpdate(ptr, buf, out len, input, input.Length));
+
 			memory.Write(buf, 0, len);
 
 			len = buf.Length;
-			Native.EVP_CipherFinal_ex(this.ptr, buf, ref len);
-			
+			Native.EVP_CipherFinal_ex(ptr, buf, ref len);
+
 			memory.Write(buf, 0, len);
 
 			return memory.ToArray();
-		}
-
-		/// <summary>
+		}
+
+        /// <summary>
+        /// Calls EVP_CipherInit_ex(), EVP_DecryptUpdate()
+        /// This function has been added by Micropross
+        /// </summary>
+        /// <param name="input"></param>
+        /// <param name="key"></param>
+        /// <returns></returns>
+        public byte[] MICROPROSS_Decrypt(byte[] input, byte[] key)
+        {
+            int total = Math.Max(input.Length, cipher.BlockSize);
+            var real_key = SetupKey(key);
+
+            var buf = new byte[total];
+            using (var memory = new MemoryStream(total))
+            {
+                Native.ExpectSuccess(Native.EVP_DecryptInit_ex(
+                    ptr, cipher.Handle, IntPtr.Zero, real_key, null));
+
+                int len = buf.Length;
+                Native.ExpectSuccess(Native.EVP_DecryptUpdate(
+                    ptr, buf, out len, input, input.Length));
+
+                // GC, 22/06/2012 : Bon, ici, je ne comprends pas pourquoi la variable len est  0, alors que buf contient les infos que je veux.
+                // Du coup, j'utilise buf.Length.
+                // Attention, j'ai galement chang Native pour utiliser EVP_DecryptInit_ex
+                memory.Write(buf, 0, buf.Length);
+
+                return memory.ToArray();
+            }
+        }
+        
+        /// <summary>
 		/// Encrypts the specified plaintext
 		/// </summary>
 		/// <param name="input"></param>
@@ -747,7 +793,7 @@
 		/// <returns></returns>
 		public byte[] Encrypt(byte[] input, byte[] key, byte[] iv)
 		{
-			return this.Crypt(input, key, iv, true);
+			return Crypt(input, key, iv, true);
 		}
 
 		/// <summary>
@@ -759,7 +805,7 @@
 		/// <returns></returns>
 		public byte[] Decrypt(byte[] input, byte[] key, byte[] iv)
 		{
-			return this.Crypt(input, key, iv, false);
+			return Crypt(input, key, iv, false);
 		}
 
 		/// <summary>
@@ -772,7 +818,7 @@
 		/// <returns></returns>
 		public byte[] Encrypt(byte[] input, byte[] key, byte[] iv, int padding)
 		{
-			return this.Crypt(input, key, iv, true, padding);
+			return Crypt(input, key, iv, true, padding);
 		}
 
 		/// <summary>
@@ -785,7 +831,7 @@
 		/// <returns></returns>
 		public byte[] Decrypt(byte[] input, byte[] key, byte[] iv, int padding)
 		{
-			return this.Crypt(input, key, iv, false, padding);
+			return Crypt(input, key, iv, false, padding);
 		}
 
 		/// <summary>
@@ -799,10 +845,22 @@
 		/// <returns></returns>
 		public byte[] BytesToKey(MessageDigest md, byte[] salt, byte[] data, int count, out byte[] iv)
 		{
-			byte[] key = new byte[this.cipher.KeyLength];
-			iv = new byte[this.cipher.IVLength];
+			var keylen = Cipher.KeyLength;
+			if (keylen == 0)
+			{
+				keylen = 8;
+			}
+			var key = new byte[keylen];
+
+			var ivlen = Cipher.IVLength;
+			if (ivlen == 0)
+			{
+				ivlen = 8;
+			}
+			iv = new byte[ivlen];
+
 			Native.ExpectSuccess(Native.EVP_BytesToKey(
-				this.cipher.Handle,
+				cipher.Handle,
 				md.Handle,
 				salt,
 				data,
@@ -821,13 +879,21 @@
 		/// </summary>
 		public Cipher Cipher
 		{
-			get { return this.cipher; }
+			get { return cipher; }
 		}
 
+		/// <summary>
+		/// Returns if EVP_CIPH_STREAM_CIPHER is set in flags
+		/// </summary>
+		public bool IsStream
+		{
+			get { return (cipher.Flags & Native.EVP_CIPH_MODE) == Native.EVP_CIPH_STREAM_CIPHER; }
+		}
+
 		private EVP_CIPHER_CTX Raw
 		{
-			get { return (EVP_CIPHER_CTX)Marshal.PtrToStructure(this.ptr, typeof(EVP_CIPHER_CTX)); }
-			set { Marshal.StructureToPtr(value, this.ptr, false); }
+			get { return (EVP_CIPHER_CTX)Marshal.PtrToStructure(ptr, typeof(EVP_CIPHER_CTX)); }
+			set { Marshal.StructureToPtr(value, ptr, false); }
 		}
 		#endregion
 
@@ -836,11 +902,12 @@
 		/// <summary>
 		/// Calls EVP_CIPHER_CTX_clean() and then OPENSSL_free()
 		/// </summary>
-		protected override void OnDispose() {
-			Native.EVP_CIPHER_CTX_cleanup(this.ptr);
-			Native.OPENSSL_free(this.ptr);
+		protected override void OnDispose()
+		{
+			Native.EVP_CIPHER_CTX_cleanup(ptr);
+			Native.OPENSSL_free(ptr);
 		}
 
 		#endregion
 	}
-}
\ No newline at end of file
+}
Index: ManagedOpenSsl/Crypto/CryptoKey.cs
===================================================================
--- ManagedOpenSsl/Crypto/CryptoKey.cs	(revision 47839)
+++ ManagedOpenSsl/Crypto/CryptoKey.cs	(revision 47851)
@@ -23,376 +23,438 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Runtime.InteropServices;
-using OpenSSL.Core;
 
 namespace OpenSSL.Crypto
-{
-	/// <summary>
-	/// Wraps the native OpenSSL EVP_PKEY object
-	/// </summary>
-	public class CryptoKey : BaseCopyableRef<CryptoKey>
-	{
-		/// <summary>
-		/// Set of types that this CryptoKey can be.
-		/// </summary>
-		public enum KeyType
-		{
-			/// <summary>
-			/// EVP_PKEY_RSA 
-			/// </summary>
-			RSA = 6,
-			/// <summary>
-			/// EVP_PKEY_DSA
-			/// </summary>
-			DSA = 116,
-			/// <summary>
-			/// EVP_PKEY_DH
-			/// </summary>
-			DH = 28,
-			/// <summary>
-			/// EVP_PKEY_EC
-			/// </summary>
-			EC = 408
-		}
-
-		const int EVP_PKEY_RSA = 6;
-		const int EVP_PKEY_DSA = 116;
-		const int EVP_PKEY_DH = 28;
-		const int EVP_PKEY_EC = 408;
-
-		[StructLayout(LayoutKind.Sequential)]
-		struct EVP_PKEY
-		{
-			public int type;
-			public int save_type;
-			public int references;
-			public IntPtr ptr;
-			public int save_parameters;
-			public IntPtr attributes;
-		}
-
-		#region Initialization
-		internal CryptoKey(IntPtr ptr, bool owner) 
-			: base(ptr, owner) 
-		{ }
-
-		/// <summary>
-		/// Calls EVP_PKEY_new()
-		/// </summary>
-		public CryptoKey() 
-			: base(Native.ExpectNonNull(Native.EVP_PKEY_new()), true) 
-		{ }
-
-		/// <summary>
-		/// Calls PEM_read_bio_PUBKEY()
-		/// </summary>
-		/// <param name="pem"></param>
-		/// <param name="password"></param>
-		/// <returns></returns>
-		public static CryptoKey FromPublicKey(string pem, string password)
-		{
-			using (BIO bio = new BIO(pem))
-			{
-				return FromPublicKey(bio, password);
-			}
-		}
-
-		/// <summary>
-		/// Calls PEM_read_bio_PUBKEY()
-		/// </summary>
-		/// <param name="bio"></param>
-		/// <param name="password"></param>
-		/// <returns></returns>
-		public static CryptoKey FromPublicKey(BIO bio, string password)
-		{
-			PasswordCallback callback = new PasswordCallback(password);
-			return FromPublicKey(bio, callback.OnPassword, null);
-		}
-
-		/// <summary>
-		/// Calls PEM_read_bio_PUBKEY()
-		/// </summary>
-		/// <param name="bio"></param>
-		/// <param name="handler"></param>
-		/// <param name="arg"></param>
-		/// <returns></returns>
-		public static CryptoKey FromPublicKey(BIO bio, PasswordHandler handler, object arg)
-		{
-			PasswordThunk thunk = new PasswordThunk(handler, arg);
-			IntPtr ptr = Native.ExpectNonNull(Native.PEM_read_bio_PUBKEY(
-				bio.Handle,
-				IntPtr.Zero,
-				thunk.Callback,
-				IntPtr.Zero
-			));
-
-			return new CryptoKey(ptr, true);
-		}
-
-		/// <summary>
-		/// Calls PEM_read_bio_PrivateKey()
-		/// </summary>
-		/// <param name="pem"></param>
-		/// <param name="password"></param>
-		/// <returns></returns>
-		public static CryptoKey FromPrivateKey(string pem, string password)
-		{
-			using (BIO bio = new BIO(pem))
-			{
-				return FromPrivateKey(bio, password);
-			}
-		}
-
-		/// <summary>
-		/// Calls PEM_read_bio_PrivateKey()
-		/// </summary>
-		/// <param name="bio"></param>
-		/// <param name="passwd"></param>
-		/// <returns></returns>
-		public static CryptoKey FromPrivateKey(BIO bio, string passwd)
-		{
-			PasswordCallback callback = new PasswordCallback(passwd);
-			return FromPrivateKey(bio, callback.OnPassword, null);
-		}
-
-		/// <summary>
-		/// Calls PEM_read_bio_PrivateKey()
-		/// </summary>
-		/// <param name="bio"></param>
-		/// <param name="handler"></param>
-		/// <param name="arg"></param>
-		/// <returns></returns>
-		public static CryptoKey FromPrivateKey(BIO bio, PasswordHandler handler, object arg)
-		{
-			PasswordThunk thunk = new PasswordThunk(handler, arg);
-			IntPtr ptr = Native.ExpectNonNull(Native.PEM_read_bio_PrivateKey(
-				bio.Handle,
-				IntPtr.Zero,
-				thunk.Callback,
-				IntPtr.Zero
-			));
-
-			return new CryptoKey(ptr, true);
-		}
-
-		/// <summary>
-		/// Calls EVP_PKEY_set1_DSA()
-		/// </summary>
-		/// <param name="dsa"></param>
-		public CryptoKey(DSA dsa)
-			: this()
-		{
-			Native.ExpectSuccess(Native.EVP_PKEY_set1_DSA(this.ptr, dsa.Handle));
-		}
-
-		/// <summary>
-		/// Calls EVP_PKEY_set1_RSA()
-		/// </summary>
-		/// <param name="rsa"></param>
-		public CryptoKey(RSA rsa)
-			: this()
-		{
-			Native.ExpectSuccess(Native.EVP_PKEY_set1_RSA(this.ptr, rsa.Handle));
-		}
-
-		/// <summary>
-		/// Calls EVP_PKEY_set1_DH()
-		/// </summary>
-		/// <param name="dh"></param>
-		public CryptoKey(DH dh)
-			: this()
-		{
-			Native.ExpectSuccess(Native.EVP_PKEY_set1_DH(this.ptr, dh.Handle));
-		}
-		#endregion
-
-		#region Properties
-		private EVP_PKEY Raw
-		{
-			get { return (EVP_PKEY)Marshal.PtrToStructure(this.ptr, typeof(EVP_PKEY)); }
-		}
-
-		/// <summary>
-		/// Returns EVP_PKEY_type()
-		/// </summary>
-		public KeyType Type
-		{
-			get
-			{
-				int ret = Native.EVP_PKEY_type(this.Raw.type);
-				switch (ret)
-				{
-					case EVP_PKEY_EC:
-						return KeyType.EC;
-					case EVP_PKEY_DH:
-						return KeyType.DH;
-					case EVP_PKEY_DSA:
-						return KeyType.DSA;
-					case EVP_PKEY_RSA:
-						return KeyType.RSA;
-					default:
-						throw new NotSupportedException();
-				}
-			}
-		}
-
-		/// <summary>
-		/// Returns EVP_PKEY_bits()
-		/// </summary>
-		public int Bits
-		{
-			get { return Native.EVP_PKEY_bits(this.ptr); }
-		}
-
-		/// <summary>
-		/// Returns EVP_PKEY_size()
-		/// </summary>
-		public int Size
-		{
-			get { return Native.EVP_PKEY_size(this.ptr); }
-		}
-		#endregion
-
-		#region Methods
-
-		/// <summary>
-		/// Calls EVP_PKEY_assign()
-		/// </summary>
-		/// <param name="type"></param>
-		/// <param name="key"></param>
-		public void Assign(int type, byte[] key)
-		{
-			Native.ExpectSuccess(Native.EVP_PKEY_assign(this.ptr, type, key));
-		}
-
-		/// <summary>
-		/// Returns EVP_PKEY_get1_DSA()
-		/// </summary>
-		/// <returns></returns>
-		public DSA GetDSA()
-		{
-			if (this.Type != KeyType.DSA)
-				throw new InvalidOperationException();
-			return new DSA(Native.ExpectNonNull(Native.EVP_PKEY_get1_DSA(this.ptr)), true);
-		}
-
-		/// <summary>
-		/// Returns EVP_PKEY_get1_DH()
-		/// </summary>
-		/// <returns></returns>
-		public DH GetDH()
-		{
-			if (this.Type != KeyType.DH)
-				throw new InvalidOperationException();
-			return new DH(Native.ExpectNonNull(Native.EVP_PKEY_get1_DH(this.ptr)), false);
-		}
-
-		/// <summary>
-		/// Returns EVP_PKEY_get1_RSA()
-		/// </summary>
-		/// <returns></returns>
-		public RSA GetRSA()
-		{
-			if (this.Type != KeyType.RSA)
-				throw new InvalidOperationException();
-			return new RSA(Native.ExpectNonNull(Native.EVP_PKEY_get1_RSA(this.ptr)), false);
-		}
-
-		/// <summary>
-		/// Calls PEM_write_bio_PKCS8PrivateKey
-		/// </summary>
-		/// <param name="bp"></param>
-		/// <param name="cipher"></param>
-		/// <param name="password"></param>
-		public void WritePrivateKey(BIO bp, Cipher cipher, string password)
-		{
-			PasswordCallback callback = new PasswordCallback(password);
-			WritePrivateKey(bp, cipher, callback.OnPassword, null);
-		}
-
-		/// <summary>
-		/// Calls PEM_write_bio_PKCS8PrivateKey
-		/// </summary>
-		/// <param name="bp"></param>
-		/// <param name="cipher"></param>
-		/// <param name="handler"></param>
-		/// <param name="arg"></param>
-		public void WritePrivateKey(BIO bp, Cipher cipher, PasswordHandler handler, object arg)
-		{
-			PasswordThunk thunk = new PasswordThunk(handler, null);
-			Native.ExpectSuccess(Native.PEM_write_bio_PKCS8PrivateKey(bp.Handle, this.ptr, cipher.Handle, IntPtr.Zero, 0, thunk.Callback, IntPtr.Zero));
-		}
-
-		#endregion
-
-		#region Overrides
-
-		/// <summary>
-		/// Calls EVP_PKEY_free()
-		/// </summary>
-		protected override void OnDispose()
-		{
-			Native.EVP_PKEY_free(this.ptr);
-		}
-
-		/// <summary>
-		/// Returns CompareTo(obj)
-		/// </summary>
-		/// <param name="obj"></param>
-		/// <returns></returns>
-		public override bool Equals(object obj)
-		{
-			CryptoKey rhs = obj as CryptoKey;
-			if (rhs == null)
-				return false;
-			return Native.EVP_PKEY_cmp(this.ptr, rhs.Handle) == 1;
-		}
-
-		/// <summary>
-		/// 
-		/// </summary>
-		/// <returns></returns>
-		public override int GetHashCode()
-		{
-			return base.GetHashCode();
-		}
-
-		internal override CryptoLockTypes LockType
-		{
-			get { return CryptoLockTypes.CRYPTO_LOCK_X509_PKEY; }
-		}
-
-		internal override Type RawReferenceType
-		{
-			get { return typeof(EVP_PKEY); }
-		}
-
-		/// <summary>
-		/// Calls appropriate Print() based on the type.
-		/// </summary>
-		/// <param name="bio"></param>
-		public override void Print(BIO bio)
-		{
-			switch (this.Type)
-			{
-				case KeyType.RSA:
-					GetRSA().Print(bio);
-					break;
-				case KeyType.DSA:
-					GetDSA().Print(bio);
-					break;
-				case KeyType.EC:
-					break;
-				case KeyType.DH:
-					GetDH().Print(bio);
-					break;
-			}
-		}
-
-		#endregion
-	}
+{
+    /// <summary>
+    /// Wraps the native OpenSSL EVP_PKEY object
+    /// </summary>
+    public class CryptoKey : BaseReferenceImpl
+    {
+        /// <summary>
+        /// Set of types that this CryptoKey can be.
+        /// </summary>
+        public enum KeyType
+        {
+            /// <summary>
+            /// EVP_PKEY_RSA 
+            /// </summary>
+            RSA = 6,
+
+            /// <summary>
+            /// EVP_PKEY_DSA
+            /// </summary>
+            DSA = 116,
+
+            /// <summary>
+            /// EVP_PKEY_DH
+            /// </summary>
+            DH = 28,
+
+            /// <summary>
+            /// EVP_PKEY_EC
+            /// </summary>
+            EC = 408
+        }
+
+        [StructLayout(LayoutKind.Sequential)]
+        private struct EVP_PKEY
+        {
+            public int type;
+            public int save_type;
+            public int references;
+            public IntPtr ameth;
+            public IntPtr engine;
+            public IntPtr pkey;
+            public int save_parameters;
+            public IntPtr attributes;
+        }
+
+        #region Initialization
+
+        internal CryptoKey(IntPtr ptr, bool owner)
+            : base(ptr, owner)
+        {
+        }
+
+        /// <summary>
+        /// Calls EVP_PKEY_new()
+        /// </summary>
+        public CryptoKey()
+            : base(Native.ExpectNonNull(Native.EVP_PKEY_new()), true)
+        {
+        }
+
+        private CryptoKey(CryptoKey other)
+            : base(other.Handle, true)
+        {
+            AddRef();
+        }
+
+        /// <summary>
+        /// Returns a copy of this object.
+        /// </summary>
+        /// <returns></returns>
+        public CryptoKey CopyRef()
+        {
+            return new CryptoKey(this);
+        }
+
+        /// <summary>
+        /// Calls PEM_read_bio_PUBKEY()
+        /// </summary>
+        /// <param name="pem"></param>
+        /// <param name="password"></param>
+        /// <returns></returns>
+        public static CryptoKey FromPublicKey(string pem, string password)
+        {
+            using (var bio = new BIO(pem))
+            {
+                return FromPublicKey(bio, password);
+            }
+        }
+
+        /// <summary>
+        /// Calls PEM_read_bio_PUBKEY()
+        /// </summary>
+        /// <param name="bio"></param>
+        /// <param name="password"></param>
+        /// <returns></returns>
+        public static CryptoKey FromPublicKey(BIO bio, string password)
+        {
+            var callback = new PasswordCallback(password);
+            return FromPublicKey(bio, callback.OnPassword, null);
+        }
+
+        /// <summary>
+        /// Calls PEM_read_bio_PUBKEY()
+        /// </summary>
+        /// <param name="bio"></param>
+        /// <param name="handler"></param>
+        /// <param name="arg"></param>
+        /// <returns></returns>
+        public static CryptoKey FromPublicKey(BIO bio, PasswordHandler handler, object arg)
+        {
+            var thunk = new PasswordThunk(handler, arg);
+            var ptr = Native.ExpectNonNull(Native.PEM_read_bio_PUBKEY(
+                bio.Handle,
+                IntPtr.Zero,
+                thunk.Callback,
+                IntPtr.Zero
+                ));
+
+            return new CryptoKey(ptr, true);
+        }
+
+        /// <summary>
+        /// Calls PEM_read_bio_PrivateKey()
+        /// </summary>
+        /// <param name="pem"></param>
+        /// <param name="password"></param>
+        /// <returns></returns>
+        public static CryptoKey FromPrivateKey(string pem, string password)
+        {
+            using (var bio = new BIO(pem))
+            {
+                return FromPrivateKey(bio, password);
+            }
+        }
+
+        /// <summary>
+        /// Calls PEM_read_bio_PrivateKey()
+        /// </summary>
+        /// <param name="bio"></param>
+        /// <param name="passwd"></param>
+        /// <returns></returns>
+        public static CryptoKey FromPrivateKey(BIO bio, string passwd)
+        {
+            var callback = new PasswordCallback(passwd);
+            return FromPrivateKey(bio, callback.OnPassword, null);
+        }
+
+        /// <summary>
+        /// Calls PEM_read_bio_PrivateKey()
+        /// </summary>
+        /// <param name="bio"></param>
+        /// <param name="handler"></param>
+        /// <param name="arg"></param>
+        /// <returns></returns>
+        public static CryptoKey FromPrivateKey(BIO bio, PasswordHandler handler, object arg)
+        {
+            var thunk = new PasswordThunk(handler, arg);
+            var ptr = Native.ExpectNonNull(Native.PEM_read_bio_PrivateKey(
+                bio.Handle,
+                IntPtr.Zero,
+                thunk.Callback,
+                IntPtr.Zero
+                ));
+
+            return new CryptoKey(ptr, true);
+        }
+
+        /// <summary>
+        /// Calls EVP_PKEY_set1_DSA()
+        /// </summary>
+        /// <param name="dsa"></param>
+        public CryptoKey(DSA dsa)
+            : this()
+        {
+            Native.ExpectSuccess(Native.EVP_PKEY_set1_DSA(ptr, dsa.Handle));
+        }
+
+        /// <summary>
+        /// Calls EVP_PKEY_set1_RSA()
+        /// </summary>
+        /// <param name="rsa"></param>
+        public CryptoKey(RSA rsa)
+            : this()
+        {
+            Native.ExpectSuccess(Native.EVP_PKEY_set1_RSA(ptr, rsa.Handle));
+        }
+
+        /// <summary>
+        /// Calls EVP_PKEY_set1_EC()
+        /// </summary>
+        /// <param name="ec"></param>
+        public CryptoKey(EC.Key ec)
+            : this()
+        {
+            Native.ExpectSuccess(Native.EVP_PKEY_set1_EC_KEY(ptr, ec.Handle));
+        }
+
+        /// <summary>
+        /// Calls EVP_PKEY_set1_DH()
+        /// </summary>
+        /// <param name="dh"></param>
+        public CryptoKey(DH dh)
+            : this()
+        {
+            Native.ExpectSuccess(Native.EVP_PKEY_set1_DH(ptr, dh.Handle));
+        }
+
+        #endregion
+
+        #region Properties
+
+        private EVP_PKEY Raw
+        {
+            get { return (EVP_PKEY) Marshal.PtrToStructure(ptr, typeof (EVP_PKEY)); }
+        }
+
+        /// <summary>
+        /// Returns EVP_PKEY_type()
+        /// </summary>
+        public KeyType Type
+        {
+            get { return (KeyType) Native.EVP_PKEY_type(Raw.type); }
+        }
+
+        /// <summary>
+        /// Returns EVP_PKEY_bits()
+        /// </summary>
+        public int Bits
+        {
+            get { return Native.EVP_PKEY_bits(ptr); }
+        }
+
+        /// <summary>
+        /// Returns EVP_PKEY_size()
+        /// </summary>
+        public int Size
+        {
+            get { return Native.EVP_PKEY_size(ptr); }
+        }
+
+        #endregion
+
+        #region Methods
+
+        /// <summary>
+        /// Calls EVP_PKEY_assign()
+        /// </summary>
+        /// <param name="key">Key.</param>
+        public void Assign(RSA key)
+        {
+            key.AddRef();
+            Native.ExpectSuccess(Native.EVP_PKEY_assign(ptr, (int) KeyType.RSA, key.Handle));
+        }
+
+        /// <summary>
+        /// Calls EVP_PKEY_assign()
+        /// </summary>
+        /// <param name="key">Key.</param>
+        public void Assign(DSA key)
+        {
+            key.AddRef();
+            Native.ExpectSuccess(Native.EVP_PKEY_assign(ptr, (int) KeyType.DSA, key.Handle));
+        }
+
+        /// <summary>
+        /// Calls EVP_PKEY_assign()
+        /// </summary>
+        /// <param name="key">Key.</param>
+        public void Assign(DH key)
+        {
+            key.AddRef();
+            Native.ExpectSuccess(Native.EVP_PKEY_assign(ptr, (int) KeyType.DH, key.Handle));
+        }
+
+        /// <summary>
+        /// Calls EVP_PKEY_assign()
+        /// </summary>
+        /// <param name="key">Key.</param>
+        public void Assign(EC.Key key)
+        {
+            key.AddRef();
+            Native.ExpectSuccess(Native.EVP_PKEY_assign(ptr, (int) KeyType.EC, key.Handle));
+        }
+
+        /// <summary>
+        /// Returns EVP_PKEY_get1_DSA()
+        /// </summary>
+        /// <returns></returns>
+        public DSA GetDSA()
+        {
+            if (Type != KeyType.DSA)
+                throw new InvalidOperationException();
+
+            return new DSA(Native.ExpectNonNull(Native.EVP_PKEY_get1_DSA(ptr)), true);
+        }
+
+        /// <summary>
+        /// Returns EVP_PKEY_get1_DH()
+        /// </summary>
+        /// <returns></returns>
+        public DH GetDH()
+        {
+            if (Type != KeyType.DH)
+                throw new InvalidOperationException();
+
+            return new DH(Native.ExpectNonNull(Native.EVP_PKEY_get1_DH(ptr)), true);
+        }
+
+        /// <summary>
+        /// Returns EVP_PKEY_get1_RSA()
+        /// </summary>
+        /// <returns></returns>
+        public RSA GetRSA()
+        {
+            if (Type != KeyType.RSA)
+                throw new InvalidOperationException();
+
+            return new RSA(Native.ExpectNonNull(Native.EVP_PKEY_get1_RSA(ptr)), true);
+        }
+
+        /// <summary>
+        /// Returns EVP_PKEY_get1_EC()
+        /// </summary>
+        /// <returns></returns>
+        public EC.Key GetEC()
+        {
+            if (Type != KeyType.EC)
+                throw new InvalidOperationException();
+
+            return new EC.Key(Native.ExpectNonNull(Native.EVP_PKEY_get1_EC_KEY(ptr)), true);
+        }
+
+
+        /// <summary>
+        /// Calls PEM_write_bio_PKCS8PrivateKey
+        /// </summary>
+        /// <param name="bp"></param>
+        /// <param name="cipher"></param>
+        /// <param name="password"></param>
+        public void WritePrivateKey(BIO bp, Cipher cipher, string password)
+        {
+            PasswordCallback callback = new PasswordCallback(password);
+            WritePrivateKey(bp, cipher, callback.OnPassword, null);
+        }
+
+        /// <summary>
+        /// Calls PEM_write_bio_PKCS8PrivateKey
+        /// </summary>
+        /// <param name="bp"></param>
+        /// <param name="cipher"></param>
+        /// <param name="handler"></param>
+        /// <param name="arg"></param>
+        public void WritePrivateKey(BIO bp, Cipher cipher, PasswordHandler handler, object arg)
+        {
+            var thunk = new PasswordThunk(handler, null);
+            Native.ExpectSuccess(Native.PEM_write_bio_PKCS8PrivateKey(bp.Handle, ptr, cipher.Handle, IntPtr.Zero, 0,
+                thunk.Callback, IntPtr.Zero));
+        }
+
+        #endregion
+
+        #region Overrides
+
+        /// <summary>
+        /// Calls EVP_PKEY_free()
+        /// </summary>
+        protected override void OnDispose()
+        {
+            Native.EVP_PKEY_free(ptr);
+        }
+
+        /// <summary>
+        /// Returns CompareTo(obj)
+        /// </summary>
+        /// <param name="obj"></param>
+        /// <returns></returns>
+        public override bool Equals(object obj)
+        {
+            var rhs = obj as CryptoKey;
+
+            if (rhs == null)
+                return false;
+
+            return Native.EVP_PKEY_cmp(ptr, rhs.Handle) == 1;
+        }
+
+        /// <summary>
+        /// 
+        /// </summary>
+        /// <returns></returns>
+        public override int GetHashCode()
+        {
+            return base.GetHashCode();
+        }
+
+        /// <summary>
+        /// Calls appropriate Print() based on the type.
+        /// </summary>
+        /// <param name="bio"></param>
+        public override void Print(BIO bio)
+        {
+            switch (Type)
+            {
+                case KeyType.RSA:
+                    GetRSA().Print(bio);
+                    break;
+                case KeyType.DSA:
+                    GetDSA().Print(bio);
+                    break;
+                case KeyType.EC:
+                    break;
+                case KeyType.DH:
+                    GetDH().Print(bio);
+                    break;
+            }
+        }
+
+        internal override CryptoLockTypes LockType
+        {
+            get { return CryptoLockTypes.CRYPTO_LOCK_EVP_PKEY; }
+        }
+
+        internal override Type RawReferenceType
+        {
+            get { return typeof (EVP_PKEY); }
+        }
+
+        #endregion
+    }
 }
Index: ManagedOpenSsl/Crypto/DH.cs
===================================================================
--- ManagedOpenSsl/Crypto/DH.cs	(revision 47839)
+++ ManagedOpenSsl/Crypto/DH.cs	(revision 47851)
@@ -23,18 +23,16 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
 using System;
-using System.Collections.Generic;
-using System.Text;
-using System.Runtime.InteropServices;
-using OpenSSL.Core;
-
+using System.Runtime.InteropServices;
+
 namespace OpenSSL.Crypto
-{
-	/// <summary>
+{
+    /// <summary>
 	/// Encapsulates the native openssl Diffie-Hellman functions (DH_*)
 	/// </summary>
-	public class DH : Base
+	public class DH : BaseReference
 	{
 		/// <summary>
 		/// Constant generator value of 2.
@@ -131,12 +129,12 @@
 		public DH(int primeLen, int generator, BigNumber.GeneratorHandler callback, object arg)
 			: base(Native.ExpectNonNull(Native.DH_new()), true)
 		{
-			this.thunk = new BigNumber.GeneratorThunk(callback, arg);
+			thunk = new BigNumber.GeneratorThunk(callback, arg);
 			Native.ExpectSuccess(Native.DH_generate_parameters_ex(
-				this.ptr,
+				ptr,
 				primeLen,
- 				generator,
-				this.thunk.CallbackStruct)
+				generator,
+				thunk.CallbackStruct)
 			);
 		}
 
@@ -146,10 +144,10 @@
 		public DH() 
 			: base(Native.ExpectNonNull(Native.DH_new()), true) 
 		{
-			dh_st raw = this.Raw;
+			var raw = Raw;
 			raw.p = Native.BN_dup(BigNumber.One.Handle);
 			raw.g = Native.BN_dup(BigNumber.One.Handle);
-			this.Raw = raw;
+			Raw = raw;
 		}
 
 		/// <summary>
@@ -157,14 +155,14 @@
 		/// </summary>
 		/// <param name="p"></param>
 		/// <param name="g"></param>
-        public DH(BigNumber p, BigNumber g)
-            : base(Native.ExpectNonNull(Native.DH_new()), true)
-        {
-            dh_st raw = this.Raw;
-            raw.p = Native.BN_dup(p.Handle);
-            raw.g = Native.BN_dup(g.Handle);
-            this.Raw = raw;
-        }
+		public DH(BigNumber p, BigNumber g)
+				: base(Native.ExpectNonNull(Native.DH_new()), true)
+		{
+			var raw = Raw;
+			raw.p = Native.BN_dup(p.Handle);
+			raw.g = Native.BN_dup(g.Handle);
+			Raw = raw;
+		}
 
 		/// <summary>
 		/// Calls DH_new().
@@ -176,12 +174,12 @@
 		public DH(BigNumber p, BigNumber g, BigNumber pub_key, BigNumber priv_key)
 			: base(Native.ExpectNonNull(Native.DH_new()), true)
 		{
-			dh_st raw = this.Raw;
+			var raw = Raw;
 			raw.p = Native.BN_dup(p.Handle);
 			raw.g = Native.BN_dup(g.Handle);
 			raw.pub_key = Native.BN_dup(pub_key.Handle);
 			raw.priv_key = Native.BN_dup(priv_key.Handle);
-			this.Raw = raw;
+			Raw = raw;
 		}
 
 		/// <summary>
@@ -203,27 +201,27 @@
 		/// <returns></returns>
 		public static DH FromParametersPEM(BIO bio)
 		{
-			IntPtr ptr = Native.ExpectNonNull(Native.PEM_read_bio_DHparams(
+			var ptr = Native.ExpectNonNull(Native.PEM_read_bio_DHparams(
 				bio.Handle, IntPtr.Zero, null, IntPtr.Zero));
 			return new DH(ptr, true);
 		}
 
-        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
-        private delegate IntPtr DH_new_delegate();
+		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
+		private delegate IntPtr DH_new_delegate();
 
-        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
-        private delegate IntPtr d2i_DHparams_delegate(out IntPtr a, IntPtr pp, int length);
+		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
+		private delegate IntPtr d2i_DHparams_delegate(out IntPtr a, IntPtr pp, int length);
 
-        private static IntPtr Managed_DH_new()
-        {
-            return Native.DH_new();
-        }
+		private static IntPtr Managed_DH_new()
+		{
+			return Native.DH_new();
+		}
 
-        private static IntPtr Managed_d2i_DHparams(out IntPtr a, IntPtr pp, int length)
-        {
-            return Native.d2i_DHparams(out a, pp, length);
-        }
-        /// <summary>
+		private static IntPtr Managed_d2i_DHparams(out IntPtr a, IntPtr pp, int length)
+		{
+			return Native.d2i_DHparams(out a, pp, length);
+		}
+		/// <summary>
 		/// Factory method that calls XXX() to deserialize
 		/// a DH object from a DER-formatted buffer using the BIO interface.
 		/// </summary>
@@ -231,13 +229,14 @@
 		/// <returns></returns>
 		public static DH FromParametersDER(BIO bio)
 		{
-            DH_new_delegate dh_new = new DH_new_delegate(Managed_DH_new);
-            d2i_DHparams_delegate d2i_DHparams = new d2i_DHparams_delegate(Managed_d2i_DHparams);
-            IntPtr dh_new_ptr = Marshal.GetFunctionPointerForDelegate(dh_new);
-            IntPtr d2i_DHparams_ptr = Marshal.GetFunctionPointerForDelegate(d2i_DHparams);
-            IntPtr ptr = Native.ExpectNonNull(Native.ASN1_d2i_bio(dh_new_ptr, d2i_DHparams_ptr, bio.Handle, IntPtr.Zero));
-            DH dh = new DH(ptr, true);
-            return dh;
+			var dh_new = new DH_new_delegate(Managed_DH_new);
+			var d2i_DHparams = new d2i_DHparams_delegate(Managed_d2i_DHparams);
+			var dh_new_ptr = Marshal.GetFunctionPointerForDelegate(dh_new);
+			var d2i_DHparams_ptr = Marshal.GetFunctionPointerForDelegate(d2i_DHparams);
+			var ptr = Native.ExpectNonNull(Native.ASN1_d2i_bio(dh_new_ptr, d2i_DHparams_ptr, bio.Handle, IntPtr.Zero));
+			var dh = new DH(ptr, true);
+			
+			return dh;
 		}
 		#endregion
 
@@ -247,7 +246,7 @@
 		/// </summary>
 		public void GenerateKeys()
 		{
-			Native.ExpectSuccess(Native.DH_generate_key(this.ptr));
+			Native.ExpectSuccess(Native.DH_generate_key(ptr));
 		}
 
 		/// <summary>
@@ -257,9 +256,10 @@
 		/// <returns></returns>
 		public byte[] ComputeKey(BigNumber pubkey)
 		{
-			int len = Native.DH_size(this.ptr);
-			byte[] key = new byte[len];
-			Native.DH_compute_key(key, pubkey.Handle, this.ptr);
+			var len = Native.DH_size(ptr);
+			var key = new byte[len];
+			Native.DH_compute_key(key, pubkey.Handle, ptr);
+
 			return key;
 		}
 
@@ -269,16 +269,16 @@
 		/// <param name="bio"></param>
 		public void WriteParametersPEM(BIO bio)
 		{
-			Native.ExpectSuccess(Native.PEM_write_bio_DHparams(bio.Handle, this.ptr));
+			Native.ExpectSuccess(Native.PEM_write_bio_DHparams(bio.Handle, ptr));
 		}
 
-        [UnmanagedFunctionPointer(CallingConvention.Cdecl)]
-        private delegate int i2d_DHparams_delegate(IntPtr a, IntPtr pp);
+		[UnmanagedFunctionPointer(CallingConvention.Cdecl)]
+		private delegate int i2d_DHparams_delegate(IntPtr a, IntPtr pp);
 
-        private int Managed_i2d_DHparams(IntPtr a, IntPtr pp)
-        {
-            return Native.i2d_DHparams(a, pp);
-        }
+		private int Managed_i2d_DHparams(IntPtr a, IntPtr pp)
+		{
+			return Native.i2d_DHparams(a, pp);
+		}
 
 		/// <summary>
 		/// Calls ASN1_i2d_bio() with the i2d = i2d_DHparams().
@@ -286,17 +286,18 @@
 		/// <param name="bio"></param>
 		public void WriteParametersDER(BIO bio)
 		{
-            i2d_DHparams_delegate i2d_DHparams = new i2d_DHparams_delegate(Managed_i2d_DHparams);
-            IntPtr i2d_DHparams_ptr = Marshal.GetFunctionPointerForDelegate(i2d_DHparams);
-            Native.ExpectSuccess(Native.ASN1_i2d_bio(i2d_DHparams_ptr, bio.Handle, this.ptr));
-            //!!
-            /*
-            IntPtr hModule = Native.LoadLibrary(Native.DLLNAME);
+			var i2d_DHparams = new i2d_DHparams_delegate(Managed_i2d_DHparams);
+			var i2d_DHparams_ptr = Marshal.GetFunctionPointerForDelegate(i2d_DHparams);
+			
+			Native.ExpectSuccess(Native.ASN1_i2d_bio(i2d_DHparams_ptr, bio.Handle, ptr));
+			//!!
+			/*
+			IntPtr hModule = Native.LoadLibrary(Native.DLLNAME);
 			IntPtr i2d = Native.GetProcAddress(hModule, "i2d_DHparams");
 			Native.FreeLibrary(hModule);
 			
 			Native.ExpectSuccess(Native.ASN1_i2d_bio(i2d, bio.Handle, this.ptr));
-            */
+			*/
 		}
 
 		/// <summary>
@@ -305,7 +306,7 @@
 		/// <param name="bio"></param>
 		public override void Print(BIO bio)
 		{
-			Native.ExpectSuccess(Native.DHparams_print(bio.Handle, this.ptr));
+			Native.ExpectSuccess(Native.DHparams_print(bio.Handle, ptr));
 		}
 
 		/// <summary>
@@ -314,8 +315,9 @@
 		/// <returns></returns>
 		public CheckCode Check()
 		{
-			int codes = 0;
-			Native.ExpectSuccess(Native.DH_check(this.ptr, out codes));
+			var codes = 0;
+			Native.ExpectSuccess(Native.DH_check(ptr, out codes));
+
 			return (CheckCode)codes;
 		}
 		#endregion
@@ -323,8 +325,8 @@
 		#region Properties
 		private dh_st Raw
 		{
-			get { return (dh_st)Marshal.PtrToStructure(this.ptr, typeof(dh_st)); }
-            set { Marshal.StructureToPtr(value, this.ptr, false); }
+			get { return (dh_st)Marshal.PtrToStructure(ptr, typeof(dh_st)); }
+			set { Marshal.StructureToPtr(value, ptr, false); }
 		}
 
 		/// <summary>
@@ -332,12 +334,12 @@
 		/// </summary>
 		public BigNumber P
 		{
-			get { return new BigNumber(this.Raw.p, false); }
+			get { return new BigNumber(Raw.p, false); }
 			set 
 			{
-				dh_st raw = this.Raw;
+				var raw = Raw;
 				raw.p = Native.BN_dup(value.Handle);
-				this.Raw = raw;
+				Raw = raw;
 			}
 		}
 
@@ -346,12 +348,12 @@
 		/// </summary>
 		public BigNumber G
 		{
-			get { return new BigNumber(this.Raw.g, false); }
+			get { return new BigNumber(Raw.g, false); }
 			set 
 			{
-				dh_st raw = this.Raw;
+				var raw = Raw;
 				raw.g = Native.BN_dup(value.Handle);
-				this.Raw = raw;
+				Raw = raw;
 			}
 		}
 
@@ -360,14 +362,14 @@
 		/// </summary>
 		public BigNumber PublicKey
 		{
-			get { return new BigNumber(this.Raw.pub_key, false); }
-            set
-            {
-                dh_st raw = this.Raw;
-                raw.pub_key = Native.BN_dup(value.Handle);
-                this.Raw = raw;
-            }
-        }
+			get { return new BigNumber(Raw.pub_key, false); }
+			set
+			{
+				var raw = Raw;
+				raw.pub_key = Native.BN_dup(value.Handle);
+				Raw = raw;
+			}
+		}
 
 		/// <summary>
 		/// Accessor for the priv_key value.
@@ -374,13 +376,13 @@
 		/// </summary>
 		public BigNumber PrivateKey
 		{
-			get { return new BigNumber(this.Raw.priv_key, false); } 
+			get { return new BigNumber(Raw.priv_key, false); } 
 			set
-            {
-                dh_st raw = this.Raw;
-                raw.priv_key = Native.BN_dup(value.Handle);
-                this.Raw = raw;
-            }
+			{
+				var raw = Raw;
+				raw.priv_key = Native.BN_dup(value.Handle);
+				Raw = raw;
+			}
 		}
 
 		/// <summary>
@@ -391,9 +393,9 @@
 		{
 			get
 			{
-				using (BIO bio = BIO.MemoryBuffer())
+				using (var bio = BIO.MemoryBuffer())
 				{
-					this.WriteParametersPEM(bio);
+					WriteParametersPEM(bio);
 					return bio.ReadString();
 				}
 			}
@@ -407,9 +409,9 @@
 		{
 			get
 			{
-				using (BIO bio = BIO.MemoryBuffer())
+				using (var bio = BIO.MemoryBuffer())
 				{
-					this.WriteParametersDER(bio);
+					WriteParametersDER(bio);
 					return bio.ReadBytes((int)bio.NumberWritten).Array;
 				}
 			}
@@ -420,20 +422,26 @@
 		/// </summary>
 		public bool NoExpConstantTime
 		{
-			get { return (this.Raw.flags & FlagNoExpConstTime) != 0; }
+			get { return (Raw.flags & FlagNoExpConstTime) != 0; }
 			set
 			{
-				dh_st raw = this.Raw;
+				var raw = Raw;
 				if (value)
 					raw.flags |= FlagNoExpConstTime;
 				else
 					raw.flags &= ~FlagNoExpConstTime;
-				this.Raw = raw;
+
+				Raw = raw;
 			}
 		}
 
 		#endregion
 
+		internal override void AddRef()
+		{
+			Native.DH_up_ref(ptr);
+		}
+
 		#region IDisposable Members
 
 		/// <summary>
@@ -440,7 +448,7 @@
 		/// Calls DH_free().
 		/// </summary>
 		protected override void OnDispose() {
-			Native.DH_free(this.ptr);
+			Native.DH_free(ptr);
 		}
 
 		#endregion
Index: ManagedOpenSsl/Crypto/DSA.cs
===================================================================
--- ManagedOpenSsl/Crypto/DSA.cs	(revision 47839)
+++ ManagedOpenSsl/Crypto/DSA.cs	(revision 47851)
@@ -23,11 +23,9 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Runtime.InteropServices;
-using OpenSSL.Core;
 
 namespace OpenSSL.Crypto
 {
@@ -34,7 +32,7 @@
 	/// <summary>
 	/// Wraps the DSA_* functions
 	/// </summary>
-	public class DSA : Base
+	public class DSA : BaseReference
 	{
 		#region dsa_st
 
@@ -90,15 +88,16 @@
 			: base(Native.ExpectNonNull(Native.DSA_new()), true)
 		{
 			Native.ExpectSuccess(Native.DSA_generate_parameters_ex(
-				this.ptr,
+				ptr,
 				512,
 				null, 0,
-				out this.counter,
-				out this.h,
+				out counter,
+				out h,
 				null)
 			);
+
 			if (generateKeys)
-				this.GenerateKeys();
+				GenerateKeys();
 		}
 
 		/// <summary>
@@ -110,14 +109,15 @@
 		public DSA(int bits, BigNumber.GeneratorHandler callback, object arg)
 			: base(Native.ExpectNonNull(Native.DSA_new()), true)
 		{
-			this.thunk = new BigNumber.GeneratorThunk(callback, arg);
+			thunk = new BigNumber.GeneratorThunk(callback, arg);
+
 			Native.ExpectSuccess(Native.DSA_generate_parameters_ex(
-				this.ptr,
+				ptr,
 				bits,
 				null, 0,
-				out this.counter,
-				out this.h,
-				this.thunk.CallbackStruct)
+				out counter,
+				out h,
+				thunk.CallbackStruct)
 			);
 		}
 
@@ -133,14 +133,15 @@
 			: base(Native.ExpectNonNull(Native.DSA_new()), true)
 		{
 			this.counter = counter;
-			this.thunk = new BigNumber.GeneratorThunk(callback, arg);
+			thunk = new BigNumber.GeneratorThunk(callback, arg);
+
 			Native.ExpectSuccess(Native.DSA_generate_parameters_ex(
-				this.ptr,
+				ptr,
 				bits,
 				seed, seed.Length,
 				out this.counter,
-				out this.h,
-				this.thunk.CallbackStruct)
+				out h,
+				thunk.CallbackStruct)
 			);
 		}
 
@@ -186,11 +187,11 @@
 
 		#endregion
 
-		#region Properites
+		#region Properties
 		private dsa_st Raw
 		{
-			get { return (dsa_st)Marshal.PtrToStructure(this.ptr, typeof(dsa_st)); }
-			set { Marshal.StructureToPtr(value, this.ptr, false); }
+			get { return (dsa_st)Marshal.PtrToStructure(ptr, typeof(dsa_st)); }
+			set { Marshal.StructureToPtr(value, ptr, false); }
 		}
 
 		/// <summary>
@@ -198,7 +199,7 @@
 		/// </summary>
 		public BigNumber P
 		{
-			get { return new BigNumber(this.Raw.p, false); }
+			get { return new BigNumber(Raw.p, false); }
 		}
 
 		/// <summary>
@@ -206,7 +207,7 @@
 		/// </summary>
 		public BigNumber Q
 		{
-			get { return new BigNumber(this.Raw.q, false); }
+			get { return new BigNumber(Raw.q, false); }
 		}
 
 		/// <summary>
@@ -214,7 +215,7 @@
 		/// </summary>
 		public BigNumber G
 		{
-			get { return new BigNumber(this.Raw.g, false); }
+			get { return new BigNumber(Raw.g, false); }
 		}
 
 		/// <summary>
@@ -222,7 +223,7 @@
 		/// </summary>
 		public int Size
 		{
-			get { return Native.ExpectSuccess(Native.DSA_size(this.ptr)); }
+			get { return Native.ExpectSuccess(Native.DSA_size(ptr)); }
 		}
 
 		/// <summary>
@@ -246,16 +247,17 @@
 		{
 			get 
 			{
-				IntPtr pKey = this.Raw.priv_key;
+				var pKey = Raw.priv_key;
 				if (pKey == IntPtr.Zero)
 					return null;
+
 				return new BigNumber(pKey, false); 
 			}
 			set
 			{
-				dsa_st raw = this.Raw;
+				var raw = Raw;
 				raw.priv_key = Native.BN_dup(value.Handle);
-				this.Raw = raw;
+				Raw = raw;
 			}
 		}
 
@@ -266,9 +268,9 @@
 		{
 			get
 			{
-				using (BIO bio = BIO.MemoryBuffer())
+				using (var bio = BIO.MemoryBuffer())
 				{
-					this.WritePublicKey(bio);
+					WritePublicKey(bio);
 					return bio.ReadString();
 				}
 			}
@@ -281,9 +283,10 @@
 		{
 			get
 			{
-				using (BIO bio = BIO.MemoryBuffer())
+				using (var bio = BIO.MemoryBuffer())
 				{
-					this.WritePrivateKey(bio, null, null, null);
+					WritePrivateKey(bio, null, null, null);
+
 					return bio.ReadString();
 				}
 			}
@@ -294,7 +297,7 @@
 		/// </summary>
 		public int Counter
 		{
-			get { return this.counter; }
+			get { return counter; }
 		}
 
 		/// <summary>
@@ -302,7 +305,7 @@
 		/// </summary>
 		public IntPtr H
 		{
-			get { return this.h; }
+			get { return h; }
 		}
 
 		/// <summary>
@@ -310,15 +313,17 @@
 		/// </summary>
 		public bool ConstantTime
 		{
-			get { return (this.Raw.flags & FlagNoExpConstTime) != 0; }
+			get { return (Raw.flags & FlagNoExpConstTime) != 0; }
 			set
 			{
-				dsa_st raw = this.Raw;
+				var raw = Raw;
+
 				if (value)
 					raw.flags |= FlagNoExpConstTime;
 				else
 					raw.flags &= ~FlagNoExpConstTime;
-				this.Raw = raw;
+
+				Raw = raw;
 			}
 		}
 		#endregion
@@ -329,7 +334,7 @@
 		/// </summary>
 		public void GenerateKeys()
 		{
-			Native.ExpectSuccess(Native.DSA_generate_key(this.ptr));
+			Native.ExpectSuccess(Native.DSA_generate_key(ptr));
 		}
 
 		/// <summary>
@@ -339,15 +344,17 @@
 		/// <returns></returns>
 		public byte[] Sign(byte[] msg)
 		{
-			byte[] sig = new byte[this.Size];
+			var sig = new byte[Size];
 			uint siglen;
-			Native.ExpectSuccess(Native.DSA_sign(0, msg, msg.Length, sig, out siglen, this.ptr));
+			Native.ExpectSuccess(Native.DSA_sign(0, msg, msg.Length, sig, out siglen, ptr));
+
 			if (sig.Length != siglen)
 			{
-				byte[] ret = new byte[siglen];
+				var ret = new byte[siglen];
 				Buffer.BlockCopy(sig, 0, ret, 0, (int)siglen);
 				return ret;
 			}
+
 			return sig;
 		}
 
@@ -360,7 +367,7 @@
 		public bool Verify(byte[] msg, byte[] sig)
 		{
 			return Native.ExpectSuccess(
-				Native.DSA_verify(0, msg, msg.Length, sig, sig.Length, this.ptr)
+				Native.DSA_verify(0, msg, msg.Length, sig, sig.Length, ptr)
 			) == 1;
 		}
 		
@@ -370,7 +377,7 @@
 		/// <param name="bio"></param>
 		public void WritePublicKey(BIO bio)
 		{
-			Native.ExpectSuccess(Native.PEM_write_bio_DSA_PUBKEY(bio.Handle, this.ptr));
+			Native.ExpectSuccess(Native.PEM_write_bio_DSA_PUBKEY(bio.Handle, ptr));
 		}
 
 		/// <summary>
@@ -382,10 +389,11 @@
 		/// <param name="arg"></param>
 		public void WritePrivateKey(BIO bio, Cipher enc, PasswordHandler passwd, object arg)
 		{
-			PasswordThunk thunk = new PasswordThunk(passwd, arg);
+			var thunk = new PasswordThunk(passwd, arg);
+
 			Native.ExpectSuccess(Native.PEM_write_bio_DSAPrivateKey(
 				bio.Handle,
-				this.ptr,
+				ptr,
 				enc == null ? IntPtr.Zero : enc.Handle,
 				null,
 				0,
@@ -403,7 +411,7 @@
 		/// <param name="bio"></param>
 		public override void Print(BIO bio)
 		{
-			Native.ExpectSuccess(Native.DSA_print(bio.Handle, this.ptr, 0));
+			Native.ExpectSuccess(Native.DSA_print(bio.Handle, ptr, 0));
 		}
 
 		/// <summary>
@@ -411,7 +419,7 @@
 		/// </summary>
 		protected override void OnDispose() 
 		{
-			Native.DSA_free(this.ptr);
+			Native.DSA_free(ptr);
 		}
 
 		/// <summary>
@@ -422,24 +430,24 @@
 		/// <returns></returns>
 		public override bool Equals(object obj)
 		{
-			DSA rhs = obj as DSA;
+			var rhs = obj as DSA;
 			if (rhs == null)
 				return false;
 
-			bool paramsEqual = (
-				this.P == rhs.P &&
-				this.Q == rhs.Q &&
-				this.G == rhs.G
+			var paramsEqual = (
+				P == rhs.P &&
+				Q == rhs.Q &&
+				G == rhs.G
 			);
 
 			if (!paramsEqual)
 				return false;
 
-			if (this.PublicKey != rhs.PublicKey)
+			if (PublicKey != rhs.PublicKey)
 				return false;
 
-			BigNumber lhsPrivateKey = this.PrivateKey;
-			BigNumber rhsPrivateKey = rhs.PrivateKey;
+			var lhsPrivateKey = PrivateKey;
+			var rhsPrivateKey = rhs.PrivateKey;
 
 			if (lhsPrivateKey == null || rhsPrivateKey == null)
 				return true;
@@ -453,16 +461,23 @@
 		/// <returns></returns>
 		public override int GetHashCode()
 		{
-			int code = 
-				this.P.GetHashCode() ^ 
-				this.Q.GetHashCode() ^ 
-				this.G.GetHashCode() ^ 
-				this.PublicKey.GetHashCode();
-			if (this.PrivateKey != null)
-				code ^= this.PrivateKey.GetHashCode();
+			var code = 
+				P.GetHashCode() ^ 
+				Q.GetHashCode() ^ 
+				G.GetHashCode() ^ 
+				PublicKey.GetHashCode();
+			
+			if (PrivateKey != null)
+				code ^= PrivateKey.GetHashCode();
+			
 			return code;
 		}
 
+		internal override void AddRef()
+		{
+			Native.DSA_up_ref(ptr);
+		}
+
 		#endregion
 	}
 }
Index: ManagedOpenSsl/Crypto/EC/BuiltinCurve.cs
===================================================================
--- ManagedOpenSsl/Crypto/EC/BuiltinCurve.cs	(revision 47839)
+++ ManagedOpenSsl/Crypto/EC/BuiltinCurve.cs	(revision 47851)
@@ -22,12 +22,16 @@
 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+using OpenSSL.Core;
 using System;
 using System.Runtime.InteropServices;
-using OpenSSL.Core;
 
 namespace OpenSSL.Crypto.EC
 {
+	/// <summary>
+	/// Wraps EC_builtin_curve
+	/// </summary>
 	public class BuiltinCurve
 	{
 		[StructLayout(LayoutKind.Sequential)]
@@ -36,34 +40,53 @@
 			public int nid;
 			public string comment;
 		}
-		
+
 		private Asn1Object obj;
 		private string comment;
-		
-		private BuiltinCurve(int nid, string comment) {
-			this.obj = new Asn1Object(nid);
+
+		private BuiltinCurve(int nid, string comment)
+		{
+			obj = new Asn1Object(nid);
 			this.comment = comment;
 		}
-		
-		public Asn1Object Object { get { return this.obj; } }
-		public string Comment { get { return this.comment; } }
-		
-		public static BuiltinCurve[] Get() {
-			int count = Native.EC_get_builtin_curves(IntPtr.Zero, 0);
-			BuiltinCurve[] curves = new BuiltinCurve[count];
-			IntPtr ptr = Native.OPENSSL_malloc(Marshal.SizeOf(typeof(EC_builtin_curve)) * count);
-			try {
+
+		/// <summary>
+		/// Returns obj
+		/// </summary>
+		public Asn1Object Object { get { return obj; } }
+
+		/// <summary>
+		/// Returns comment
+		/// </summary>
+		public string Comment { get { return comment; } }
+
+		/// <summary>
+		/// Calls EC_get_builtin_curves()
+		/// </summary>
+		/// <returns></returns>
+		public static BuiltinCurve[] Get()
+		{
+			var count = Native.EC_get_builtin_curves(IntPtr.Zero, 0);
+			var curves = new BuiltinCurve[count];
+			var ptr = Native.OPENSSL_malloc(Marshal.SizeOf(typeof(EC_builtin_curve)) * count);
+
+			try
+			{
 				Native.ExpectSuccess(Native.EC_get_builtin_curves(ptr, count));
-				IntPtr pItem = ptr;
-				for (int i = 0; i < count; i++) {
-					EC_builtin_curve raw = (EC_builtin_curve)Marshal.PtrToStructure(pItem, typeof(EC_builtin_curve));
+				var pItem = ptr;
+
+				for (var i = 0; i < count; i++)
+				{
+					var raw = (EC_builtin_curve)Marshal.PtrToStructure(pItem, typeof(EC_builtin_curve));
 					curves[i] = new BuiltinCurve(raw.nid, raw.comment);
 					pItem = new IntPtr(pItem.ToInt64() + Marshal.SizeOf(typeof(EC_builtin_curve)));
 				}
 			}
-			finally {
+			finally
+			{
 				Native.OPENSSL_free(ptr);
 			}
+
 			return curves;
 		}
 	}
Index: ManagedOpenSsl/Crypto/EC/DSASignature.cs
===================================================================
--- ManagedOpenSsl/Crypto/EC/DSASignature.cs	(revision 47839)
+++ ManagedOpenSsl/Crypto/EC/DSASignature.cs	(revision 47851)
@@ -22,12 +22,16 @@
 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+using OpenSSL.Core;
 using System;
 using System.Runtime.InteropServices;
-using OpenSSL.Core;
 
 namespace OpenSSL.Crypto.EC
 {
+	/// <summary>
+	/// Wraps ECDSA_SIG_st
+	/// </summary>
 	public class DSASignature : Base
 	{
 		[StructLayout(LayoutKind.Sequential)]
@@ -38,27 +42,41 @@
 		}
 
 		#region Initialization
-		internal DSASignature(IntPtr ptr, bool owner) 
-			: base(ptr, owner) {
+		internal DSASignature(IntPtr ptr, bool owner)
+			: base(ptr, owner)
+		{
 		}
-		
-		public DSASignature() 
-			: base(Native.ExpectNonNull(Native.ECDSA_SIG_new()), true) {
+
+		/// <summary>
+		/// Calls ECDSA_SIG_new()
+		/// </summary>
+		public DSASignature()
+			: base(Native.ExpectNonNull(Native.ECDSA_SIG_new()), true)
+		{
 		}
 		#endregion
 
 		#region Properties
-		private ECDSA_SIG_st Raw {
-			get { return (ECDSA_SIG_st)Marshal.PtrToStructure(this.ptr, typeof(ECDSA_SIG_st)); }
-			set { Marshal.StructureToPtr(value, this.ptr, false); }
+		private ECDSA_SIG_st Raw
+		{
+			get { return (ECDSA_SIG_st)Marshal.PtrToStructure(ptr, typeof(ECDSA_SIG_st)); }
+			set { Marshal.StructureToPtr(value, ptr, false); }
 		}
 
-		public BigNumber R {
-			get { return new BigNumber(this.Raw.r, false); }
+		/// <summary>
+		/// Returns R
+		/// </summary>
+		public BigNumber R
+		{
+			get { return new BigNumber(Raw.r, false); }
 		}
 
-		public BigNumber S {
-			get { return new BigNumber(this.Raw.s, false); }
+		/// <summary>
+		/// Returns S
+		/// </summary>
+		public BigNumber S
+		{
+			get { return new BigNumber(Raw.s, false); }
 		}
 		#endregion
 
@@ -66,8 +84,12 @@
 		#endregion
 
 		#region Overrides
-		protected override void OnDispose() {
-			Native.ECDSA_SIG_free(this.ptr);
+		/// <summary>
+		/// Calls ECDSA_SIG_free()
+		/// </summary>
+		protected override void OnDispose()
+		{
+			Native.ECDSA_SIG_free(ptr);
 		}
 		#endregion
 	}
Index: ManagedOpenSsl/Crypto/EC/Group.cs
===================================================================
--- ManagedOpenSsl/Crypto/EC/Group.cs	(revision 47839)
+++ ManagedOpenSsl/Crypto/EC/Group.cs	(revision 47851)
@@ -22,34 +22,58 @@
 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+using OpenSSL.Core;
 using System;
-using OpenSSL.Core;
 
 namespace OpenSSL.Crypto.EC
 {
+	/// <summary>
+	/// 
+	/// </summary>
 	public class Group : Base
 	{
 		#region Initialization
-		internal Group(IntPtr ptr, bool owner) 
-			: base(ptr, owner) { 
+		internal Group(IntPtr ptr, bool owner)
+			: base(ptr, owner)
+		{
 		}
 
+		/// <summary>
+		/// Calls EC_GROUP_new()
+		/// </summary>
+		/// <param name="method"></param>
 		public Group(Method method)
-			: base(Native.ExpectNonNull(Native.EC_GROUP_new(method.Handle)), true) {
+			: base(Native.ExpectNonNull(Native.EC_GROUP_new(method.Handle)), true)
+		{
 		}
-		
-		public static Group FromCurveName(Asn1Object obj) {
+
+		/// <summary>
+		/// Calls EC_GROUP_new_by_curve_name()
+		/// </summary>
+		/// <param name="obj"></param>
+		/// <returns></returns>
+		public static Group FromCurveName(Asn1Object obj)
+		{
 			return new Group(Native.ExpectNonNull(Native.EC_GROUP_new_by_curve_name(obj.NID)), true);
 		}
 		#endregion
 
 		#region Properties
-		public int Degree {
-			get { return Native.EC_GROUP_get_degree(this.ptr); }
+		/// <summary>
+		/// Calls EC_GROUP_get_degree()
+		/// </summary>
+		public int Degree
+		{
+			get { return Native.EC_GROUP_get_degree(ptr); }
 		}
-		
-		public Method Method {
-			get { return new Method(Native.EC_GROUP_method_of(this.ptr), false); }
+
+		/// <summary>
+		/// Calls EC_GROUP_method_of()
+		/// </summary>
+		public Method Method
+		{
+			get { return new Method(Native.EC_GROUP_method_of(ptr), false); }
 		}
 		#endregion
 
@@ -57,7 +81,11 @@
 		#endregion
 
 		#region Overrides
-		protected override void OnDispose() {
+		/// <summary>
+		/// Calls EC_GROUP_free()
+		/// </summary>
+		protected override void OnDispose()
+		{
 			Native.EC_GROUP_free(this.ptr);
 		}
 		#endregion
Index: ManagedOpenSsl/Crypto/EC/Key.cs
===================================================================
--- ManagedOpenSsl/Crypto/EC/Key.cs	(revision 47839)
+++ ManagedOpenSsl/Crypto/EC/Key.cs	(revision 47851)
@@ -1,162 +1,273 @@
-// Copyright (c) 2012 Frank Laub
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-using System;
-using OpenSSL.Core;
-using System.Runtime.InteropServices;
-
-namespace OpenSSL.Crypto.EC
-{
-	public class Key : BaseCopyableRef<Key>
-	{
-		public delegate byte[] ComputeKeyHandler(byte[] msg);
-		
-		[StructLayout(LayoutKind.Sequential)]
-		struct ec_key_st 
-		{
-			public int version;
-			public IntPtr group;
-			public IntPtr pub_key;
-			public IntPtr priv_key;
-			public uint enc_flag;
-			public int conv_form;
-			public int references;
-			public IntPtr method_data;
-		}
-		
-		#region Initialization
-		internal Key(IntPtr ptr, bool owner) 
-			: base(ptr, owner) { 
-		}
-
-		public Key()
-			: base(Native.ExpectNonNull(Native.EC_KEY_new()), true) {
-		}
-		
-		public static Key FromCurveName(Asn1Object obj) {
-			return new Key(Native.ExpectNonNull(Native.EC_KEY_new_by_curve_name(obj.NID)), true);
-		}
-		#endregion
-
-		#region Properties
-		public int Size {
-			get { return Native.ECDSA_size(this.ptr); }
-		}
-		
-		public Group Group {
-			get { return new Group(Native.ExpectNonNull(Native.EC_KEY_get0_group(this.ptr)), false); }
-			set { Native.ExpectSuccess(Native.EC_KEY_set_group(this.ptr, value.Handle)); }
-		}
-		
-		public Point PublicKey {
-			get { 
-				return new Point(
-					this.Group,
-					Native.ExpectNonNull(Native.EC_KEY_get0_public_key(this.ptr)), 
-					false); 
-			}
-		}
-
-		public Point PrivateKey {
-			get { 
-				return new Point(
-					this.Group,
-					Native.ExpectNonNull(Native.EC_KEY_get0_private_key(this.ptr)), 
-					false); 
-			}
-		}
-		
-		#endregion
-
-		#region Methods
-		public void GenerateKey() {
-			Native.ExpectSuccess(Native.EC_KEY_generate_key(this.ptr));
-		}
-		
-		public bool CheckKey() {
-			return Native.ExpectSuccess(Native.EC_KEY_check_key(this.ptr)) == 1;
-		}
-		
-		public DSASignature Sign(byte[] digest) {
-			IntPtr sig = Native.ExpectNonNull(Native.ECDSA_do_sign(digest, digest.Length, this.ptr));
-			return new DSASignature(sig, true);
-		}
-		
-		public uint Sign(int type, byte[] digest, byte[] sig) {
-			uint siglen = (uint)sig.Length;
-			Native.ExpectSuccess(Native.ECDSA_sign(type, digest, digest.Length, sig, ref siglen, this.ptr));
-			return siglen;
-		}
-		
-		public bool Verify(byte[] digest, DSASignature sig) {
-			return Native.ECDSA_do_verify(digest, digest.Length, sig.Handle, this.ptr) == 1;
-		}
-		
-		public bool Verify(int type, byte[] digest, byte[] sig) {
-			return Native.ECDSA_verify(type, digest, digest.Length, sig, sig.Length, this.ptr) == 1;
-		}
-		
-		public int ComputeKey(Key b, byte[] buf, ComputeKeyHandler kdf) {
-			ComputeKeyThunk thunk = new ComputeKeyThunk(kdf);
-			return Native.ExpectSuccess(
-				Native.ECDH_compute_key(buf, buf.Length, b.PublicKey.Handle, this.ptr, thunk.Wrapper)
-			);
-		}
-		
-		class ComputeKeyThunk
-		{
-			private ComputeKeyHandler kdf;
-			
-			public ComputeKeyThunk(ComputeKeyHandler kdf) {
-				this.kdf = kdf;
-			}
-			
-			public IntPtr Wrapper(byte[] pin, int inlen, IntPtr pout, ref int outlen) {
-				byte[] result = kdf(pin);
-				if (result.Length > outlen) 
-					return IntPtr.Zero;
-				Marshal.Copy(result, 0, pout, Math.Min(outlen, result.Length));
-				outlen = result.Length;
-				return pout;
-			}
-		}
-
-		#endregion
-
-		#region Overrides
-		protected override void OnDispose() {
-			Native.EC_KEY_free(this.ptr);
-		}
-
-		internal override CryptoLockTypes LockType {
-			get { return CryptoLockTypes.CRYPTO_LOCK_EC; }
-		}
-
-		internal override Type RawReferenceType {
-			get { return typeof(ec_key_st); }
-		}
-		#endregion
-	}
-}
-
+// Copyright (c) 2012 Frank Laub
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+using OpenSSL.Core;
+using System;
+using System.Runtime.InteropServices;
+
+namespace OpenSSL.Crypto.EC
+{
+	/// <summary>
+	/// Wraps EC_KEY
+	/// </summary>
+	public class Key : BaseReference
+	{
+		/// <summary>
+		/// Compute key handler.
+		/// </summary>
+		public delegate byte[] ComputeKeyHandler(byte[] msg);
+
+		#region Initialization
+
+		internal Key(IntPtr ptr, bool owner) : base(ptr, owner)
+		{ 
+		}
+
+		/// <summary>
+		/// Calls EC_KEY_new()
+		/// </summary>
+		public Key() : base(Native.ExpectNonNull(Native.EC_KEY_new()), true)
+		{
+		}
+
+		/// <summary>
+		/// Calls EC_KEY_new_by_curve_name()
+		/// </summary>
+		/// <returns>The curve name.</returns>
+		/// <param name="obj">Object.</param>
+		public static Key FromCurveName(Asn1Object obj)
+		{
+			return new Key(Native.ExpectNonNull(Native.EC_KEY_new_by_curve_name(obj.NID)), true);
+		}
+
+		#endregion
+
+		#region Properties
+
+		/// <summary>
+		/// Calls ECDSA_size()
+		/// </summary>
+		/// <value>The size.</value>
+		public int Size
+		{
+			get { return Native.ECDSA_size(ptr); }
+		}
+
+		/// <summary>
+		/// EC_KEY_get0_group()/Calls EC_KEY_set_group()
+		/// </summary>
+		/// <value>The group.</value>
+		public Group Group
+		{
+			get { return new Group(Native.ExpectNonNull(Native.EC_KEY_get0_group(ptr)), false); }
+			set { Native.ExpectSuccess(Native.EC_KEY_set_group(ptr, value.Handle)); }
+		}
+
+		/// <summary>
+		/// Calls EC_KEY_get0_public_key()
+		/// </summary>
+		/// <value>The public key.</value>
+		public Point PublicKey
+		{
+			get
+			{ 
+				return new Point(
+					Group,
+					Native.ExpectNonNull(Native.EC_KEY_get0_public_key(ptr)), 
+					false); 
+			}
+		}
+
+		/// <summary>
+		/// Calls EC_KEY_get0_private_key()
+		/// </summary>
+		/// <value>The private key.</value>
+		public Point PrivateKey
+		{
+			get
+			{ 
+				return new Point(
+					this.Group,
+					Native.ExpectNonNull(Native.EC_KEY_get0_private_key(ptr)), 
+					false); 
+			}
+		}
+
+		#endregion
+
+		#region Methods
+
+		/// <summary>
+		/// Calls EC_KEY_generate_key()
+		/// </summary>
+		public void GenerateKey()
+		{
+			Native.ExpectSuccess(Native.EC_KEY_generate_key(ptr));
+		}
+
+        /// <summary>
+        /// Calls EC_KEY_set_private_key()
+        /// </summary>
+        /// <param name="sk"></param>
+        public void SetPrivateKey(BigNumber sk)
+        {
+            Native.ExpectSuccess(Native.EC_KEY_set_private_key(ptr, sk.Handle));
+        }
+
+        /// <summary>
+        /// Calls EC_KEY_set_public_key
+        /// </summary>
+        /// <param name="pk"></param>
+        public void SetPublicKey(Point pk)
+        {
+            Native.ExpectSuccess(Native.EC_KEY_set_public_key(ptr, pk.Handle));
+        }
+
+		/// <summary>
+		/// Calls EC_KEY_check_key()
+		/// </summary>
+		/// <returns><c>true</c>, if key was checked, <c>false</c> otherwise.</returns>
+		public bool CheckKey()
+		{
+			return Native.ExpectSuccess(Native.EC_KEY_check_key(ptr)) == 1;
+		}
+
+		/// <summary>
+		/// Calls ECDSA_do_sign()
+		/// </summary>
+		/// <param name="digest">Digest.</param>
+		public DSASignature Sign(byte[] digest)
+		{
+			var sig = Native.ExpectNonNull(Native.ECDSA_do_sign(digest, digest.Length, ptr));
+			return new DSASignature(sig, true);
+		}
+
+		/// <summary>
+		/// Calls ECDSA_sign()
+		/// </summary>
+		/// <param name="type">Type.</param>
+		/// <param name="digest">Digest.</param>
+		/// <param name="sig">Sig.</param>
+		public uint Sign(int type, byte[] digest, byte[] sig)
+		{
+		    uint siglen = 0;//(uint)sig.Length;
+			Native.ExpectSuccess(Native.ECDSA_sign(type, digest, digest.Length, sig, ref siglen, ptr));
+
+			return siglen;
+		}
+
+		/// <summary>
+		/// Calls ECDSA_do_verify()
+		/// </summary>
+		/// <param name="digest">Digest.</param>
+		/// <param name="sig">Sig.</param>
+		public bool Verify(byte[] digest, DSASignature sig)
+		{
+			return Native.ECDSA_do_verify(digest, digest.Length, sig.Handle, ptr) == 1;
+		}
+
+		/// <summary>
+		/// Calls ECDSA_verify()
+		/// </summary>
+		/// <param name="type">Type.</param>
+		/// <param name="digest">Digest.</param>
+		/// <param name="sig">Sig.</param>
+		public bool Verify(int type, byte[] digest, byte[] sig)
+		{
+			return Native.ECDSA_verify(type, digest, digest.Length, sig, sig.Length, ptr) == 1;
+		}
+
+		/// <summary>
+		/// Calls ECDH_compute_key()
+		/// </summary>
+		/// <returns>The key.</returns>
+		/// <param name="b">The blue component.</param>
+		/// <param name="buf">Buffer.</param>
+		/// <param name="kdf">Kdf.</param>
+		public int ComputeKey(Key b, byte[] buf, ComputeKeyHandler kdf)
+		{
+			ComputeKeyThunk thunk = new ComputeKeyThunk(kdf);
+			return Native.ExpectSuccess(
+				Native.ECDH_compute_key(buf, buf.Length, b.PublicKey.Handle, ptr, thunk.Wrapper)
+			);
+		}
+
+        /// <summary>
+        /// Calls ECDH_compute_key()
+        /// </summary>
+        /// <returns>The key.</returns>
+        /// <param name="buf">Buffer.</param>
+        public int ComputeKey(Point b, byte[] buf)
+        {
+            return Native.ExpectSuccess(
+                Native.ECDH_compute_key(buf, buf.Length, b.Handle, ptr, null)
+            );
+        }
+
+		class ComputeKeyThunk
+		{
+			private ComputeKeyHandler kdf;
+
+			public ComputeKeyThunk(ComputeKeyHandler kdf)
+			{
+				this.kdf = kdf;
+			}
+
+			public IntPtr Wrapper(byte[] pin, int inlen, IntPtr pout, ref int outlen)
+			{
+				var result = kdf(pin);
+
+				if (result.Length > outlen)
+					return IntPtr.Zero;
+
+				Marshal.Copy(result, 0, pout, Math.Min(outlen, result.Length));
+				outlen = result.Length;
+
+				return pout;
+			}
+		}
+
+		#endregion
+
+		#region Overrides
+
+		/// <summary>
+		/// This method must be implemented in derived classes.
+		/// </summary>
+		protected override void OnDispose()
+		{
+			Native.EC_KEY_free(ptr);
+		}
+
+		internal override void AddRef()
+		{
+			Native.EC_KEY_up_ref(ptr);
+		}
+
+		#endregion
+
+    }
+}
+
Index: ManagedOpenSsl/Crypto/EC/Method.cs
===================================================================
--- ManagedOpenSsl/Crypto/EC/Method.cs	(revision 47839)
+++ ManagedOpenSsl/Crypto/EC/Method.cs	(revision 47851)
@@ -22,35 +22,57 @@
 // THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+using OpenSSL.Core;
 using System;
-using OpenSSL.Core;
 
 namespace OpenSSL.Crypto.EC
 {
+	/// <summary>
+	/// 
+	/// </summary>
 	public class Method : Base
 	{
 		#region Initialization
-		internal Method(IntPtr ptr, bool owner) 
-			: base(ptr, owner) { 
+		internal Method(IntPtr ptr, bool owner)
+			: base(ptr, owner)
+		{
 		}
-		
+
+		/// <summary>
+		/// Returns EC_GFp_simple_method()
+		/// </summary>
 		public static Method GFpSimple = new Method(Native.EC_GFp_simple_method(), false);
+		/// <summary>
+		/// Returns EC_GFp_mont_method()
+		/// </summary>
 		public static Method GFpMont = new Method(Native.EC_GFp_mont_method(), false);
+		/// <summary>
+		/// Returns EC_GFp_nist_method()
+		/// </summary>
 		public static Method GFpNist = new Method(Native.EC_GFp_nist_method(), false);
+		/// <summary>
+		/// Returns EC_GF2m_simple_method()
+		/// </summary>
 		public static Method GF2mSimple = new Method(Native.EC_GF2m_simple_method(), false);
 		#endregion
 
 		#region Properties
-		public int FieldType {
-			get { return Native.EC_METHOD_get_field_type(this.ptr); }
+		/// <summary>
+		/// Returns EC_METHOD_get_field_type()
+		/// </summary>
+		public int FieldType
+		{
+			get { return Native.EC_METHOD_get_field_type(ptr); }
 		}
 		#endregion
-		
-		#region Methods
-		#endregion
 
 		#region Overrides
-		protected override void OnDispose() {
+		/// <summary>
+		/// 
+		/// </summary>
+		protected override void OnDispose()
+		{
 		}
 		#endregion
 	}
Index: ManagedOpenSsl/Crypto/EC/Point.cs
===================================================================
--- ManagedOpenSsl/Crypto/EC/Point.cs	(revision 47839)
+++ ManagedOpenSsl/Crypto/EC/Point.cs	(revision 47851)
@@ -1,70 +1,122 @@
-// Copyright (c) 2012 Frank Laub
-// All rights reserved.
-//
-// Redistribution and use in source and binary forms, with or without
-// modification, are permitted provided that the following conditions
-// are met:
-// 1. Redistributions of source code must retain the above copyright
-//    notice, this list of conditions and the following disclaimer.
-// 2. Redistributions in binary form must reproduce the above copyright
-//    notice, this list of conditions and the following disclaimer in the
-//    documentation and/or other materials provided with the distribution.
-// 3. The name of the author may not be used to endorse or promote products
-//    derived from this software without specific prior written permission.
-//
-// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
-// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
-// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
-// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
-// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
-// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
-// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
-// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
-// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
-// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
-using System;
-using OpenSSL.Core;
-
-namespace OpenSSL.Crypto.EC
-{
-	public class Point : Base
-	{
-		private Group group;
-		
-		#region Initialization
-		internal Point(Group group, IntPtr ptr, bool owner) 
-			: base(ptr, owner) { 
-			this.group = group;
-		}
-		
-		public Point(Group group) 
-			: base(Native.EC_POINT_new(group.Handle), true) {
-			this.group = group;
-		}
-		#endregion
-
-		#region Properties
-		#endregion
-		
-		#region Methods
-		public void GetAffineCoordinatesGF2m(BigNumber x, BigNumber y, BigNumber.Context ctx) {
-			Native.ExpectSuccess(
-				Native.EC_POINT_get_affine_coordinates_GF2m(this.group.Handle, this.ptr, x.Handle, y.Handle, ctx.Handle)
-			);
-		}
-		
-		public void GetAffineCoordinatesGFp(BigNumber x, BigNumber y, BigNumber.Context ctx) {
-			Native.ExpectSuccess(
-				Native.EC_POINT_get_affine_coordinates_GFp(this.group.Handle, this.ptr, x.Handle, y.Handle, ctx.Handle)
-			);
-		}
-		#endregion
-		
-		#region Overrides
-		protected override void OnDispose() {
-			Native.EC_POINT_free(this.ptr);
-		}
-		#endregion
-	}
-}
-
+// Copyright (c) 2012 Frank Laub
+// All rights reserved.
+//
+// Redistribution and use in source and binary forms, with or without
+// modification, are permitted provided that the following conditions
+// are met:
+// 1. Redistributions of source code must retain the above copyright
+//    notice, this list of conditions and the following disclaimer.
+// 2. Redistributions in binary form must reproduce the above copyright
+//    notice, this list of conditions and the following disclaimer in the
+//    documentation and/or other materials provided with the distribution.
+// 3. The name of the author may not be used to endorse or promote products
+//    derived from this software without specific prior written permission.
+//
+// THIS SOFTWARE IS PROVIDED BY THE AUTHOR ``AS IS'' AND ANY EXPRESS OR
+// IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED WARRANTIES
+// OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE ARE DISCLAIMED.
+// IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY DIRECT, INDIRECT,
+// INCIDENTAL, SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT
+// NOT LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
+// DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
+// THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
+// (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
+// THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
+
+using OpenSSL.Core;
+using System;
+
+namespace OpenSSL.Crypto.EC
+{
+	/// <summary>
+	/// Wraps EC_POINT
+	/// </summary>
+	public class Point : Base
+	{
+		private Group group;
+
+		#region Initialization
+		internal Point(Group group, IntPtr ptr, bool owner)
+			: base(ptr, owner)
+		{
+			this.group = group;
+		}
+
+		/// <summary>
+		/// Calls EC_POINT_new()
+		/// </summary>
+		/// <param name="group"></param>
+		public Point(Group group)
+			: base(Native.EC_POINT_new(group.Handle), true)
+		{
+			this.group = group;
+		}
+		#endregion
+
+		#region Properties
+		#endregion
+
+		#region Methods
+        public void Add(Point r, Point y, BigNumber.Context ctx)
+        {
+            Native.ExpectSuccess(
+                Native.EC_POINT_add(group.Handle, r.Handle, ptr, y.Handle, ctx.Handle)
+            );
+        }
+
+        public void Multiply(Point r, BigNumber y, BigNumber.Context ctx)
+        {
+            BigNumber n = new BigNumber((uint)0);
+            Native.ExpectSuccess(
+                Native.EC_POINT_mul(group.Handle, r.Handle, n.Handle, ptr, y.Handle, ctx.Handle)
+            );
+        }
+        
+        /// <summary>
+		/// Calls EC_POINT_get_affine_coordinates_GF2m()
+		/// </summary>
+		/// <param name="x"></param>
+		/// <param name="y"></param>
+		/// <param name="ctx"></param>
+		public void GetAffineCoordinatesGF2m(BigNumber x, BigNumber y, BigNumber.Context ctx)
+		{
+			Native.ExpectSuccess(
+				Native.EC_POINT_get_affine_coordinates_GF2m(group.Handle, ptr, x.Handle, y.Handle, ctx.Handle)
+			);
+		}
+
+		/// <summary>
+		/// Calls EC_POINT_get_affine_coordinates_GFp()
+		/// </summary>
+		/// <param name="x"></param>
+		/// <param name="y"></param>
+		/// <param name="ctx"></param>
+		public void GetAffineCoordinatesGFp(BigNumber x, BigNumber y, BigNumber.Context ctx)
+		{
+			Native.ExpectSuccess(
+				Native.EC_POINT_get_affine_coordinates_GFp(group.Handle, ptr, x.Handle, y.Handle, ctx.Handle)
+			);
+		}
+		#endregion
+
+		#region Overrides
+		/// <summary>
+		/// Calls EC_POINT_free()
+		/// </summary>
+		protected override void OnDispose()
+		{
+			Native.EC_POINT_free(ptr);
+		}
+
+        /// <summary>
+        /// Calls BN_print()
+        /// </summary>
+        /// <param name="bio"></param>
+        public override void Print(BIO bio)
+        {
+            Native.ExpectSuccess(Native.BN_print(bio.Handle, ptr));
+        }
+		#endregion
+	}
+}
+
Index: ManagedOpenSsl/Crypto/HMAC.cs
===================================================================
--- ManagedOpenSsl/Crypto/HMAC.cs	(revision 47839)
+++ ManagedOpenSsl/Crypto/HMAC.cs	(revision 47851)
@@ -23,11 +23,9 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Runtime.InteropServices;
-using OpenSSL.Core;
 
 namespace OpenSSL.Crypto
 {
@@ -45,6 +43,7 @@
 			public EVP_MD_CTX i_ctx;
 			public EVP_MD_CTX o_ctx;
 			public uint key_length;    //unsigned int key_length;
+
 			[MarshalAs(UnmanagedType.ByValArray, SizeConst = Native.HMAC_MAX_MD_CBLOCK)]
 			public byte[] key;
 		}
@@ -57,9 +56,10 @@
 		public HMAC()
 			: base(IntPtr.Zero, true) {
 			// Allocate the context
-			this.ptr = Native.OPENSSL_malloc(Marshal.SizeOf(typeof(HMAC_CTX)));
+			ptr = Native.OPENSSL_malloc(Marshal.SizeOf(typeof(HMAC_CTX)));
+
 			// Initialize the context
-			Native.HMAC_CTX_init(this.ptr);
+			Native.HMAC_CTX_init(ptr);
 		}
 		#endregion
 
@@ -73,9 +73,10 @@
 		/// <param name="data"></param>
 		/// <returns></returns>
 		public static byte[] Digest(MessageDigest digest, byte[] key, byte[] data) {
-			byte[] hash_value = new byte[digest.Size];
+			var hash_value = new byte[digest.Size];
 			uint hash_value_length = Native.EVP_MAX_MD_SIZE;
 			Native.HMAC(digest.Handle, key, key.Length, data, data.Length, hash_value, ref hash_value_length);
+			
 			return hash_value;
 		}
 
@@ -85,9 +86,9 @@
 		/// <param name="key"></param>
 		/// <param name="digest"></param>
 		public void Init(byte[] key, MessageDigest digest) {
-			Native.HMAC_Init_ex(this.ptr, key, key.Length, digest.Handle, IntPtr.Zero);
-			this.digest_size = digest.Size;
-			this.initialized = true;
+			Native.HMAC_Init_ex(ptr, key, key.Length, digest.Handle, IntPtr.Zero);
+			digest_size = digest.Size;
+			initialized = true;
 		}
 
 		/// <summary>
@@ -98,7 +99,8 @@
 			if (!initialized) {
 				throw new Exception("Failed to call Initialize before calling Update");
 			}
-			Native.HMAC_Update(this.ptr, data, data.Length);
+
+			Native.HMAC_Update(ptr, data, data.Length);
 		}
 
 		/// <summary>
@@ -123,8 +125,9 @@
 			if (data.Length < (count - offset)) {
 				throw new ArgumentException("invalid length specified.  Count is greater than buffer length.");
 			}
-			ArraySegment<byte> seg = new ArraySegment<byte>(data, offset, count);
-			Native.HMAC_Update(this.ptr, seg.Array, seg.Count);
+
+			var seg = new ArraySegment<byte>(data, offset, count);
+			Native.HMAC_Update(ptr, seg.Array, seg.Count);
 		}
 
 		/// <summary>
@@ -135,10 +138,11 @@
 			if (!initialized) {
 				throw new Exception("Failed to call Initialize before calling DigestFinal");
 			}
-			byte[] hash_value = new byte[digest_size];
+
+			var hash_value = new byte[digest_size];
 			uint hash_value_length = Native.EVP_MAX_MD_SIZE;
 
-			Native.HMAC_Final(this.ptr, hash_value, ref hash_value_length);
+			Native.HMAC_Final(ptr, hash_value, ref hash_value_length);
 			return hash_value;
 		}
 
@@ -150,9 +154,10 @@
 		/// </summary>
 		protected override void OnDispose() {
 			// Clean up the context
-			Native.HMAC_CTX_cleanup(this.ptr);
+			Native.HMAC_CTX_cleanup(ptr);
+
 			// Free the structure allocation
-			Native.OPENSSL_free(this.ptr);
+			Native.OPENSSL_free(ptr);
 		}
 		#endregion
 
Index: ManagedOpenSsl/Crypto/MessageDigest.cs
===================================================================
--- ManagedOpenSsl/Crypto/MessageDigest.cs	(revision 47839)
+++ ManagedOpenSsl/Crypto/MessageDigest.cs	(revision 47851)
@@ -23,11 +23,10 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
 using System;
-using System.Collections.Generic;
+using System.Runtime.InteropServices;
 using System.Text;
-using System.Runtime.InteropServices;
-using OpenSSL.Core;
 
 namespace OpenSSL.Crypto
 {
@@ -37,7 +36,6 @@
 	/// </summary>
 	public class MessageDigest : Base
 	{
-		private EVP_MD raw;
 		/// <summary>
 		/// Creates a EVP_MD struct
 		/// </summary>
@@ -45,7 +43,6 @@
 		/// <param name="owner"></param>
 		internal MessageDigest(IntPtr ptr, bool owner) : base(ptr, owner) 
 		{
-			this.raw = (EVP_MD)Marshal.PtrToStructure(this.ptr, typeof(EVP_MD));
 		}
 
 		/// <summary>
@@ -70,10 +67,12 @@
 		/// <param name="name"></param>
 		/// <returns></returns>
 		public static MessageDigest CreateByName(string name) {
-			byte[] buf = Encoding.ASCII.GetBytes(name);
-			IntPtr ptr = Native.EVP_get_digestbyname(buf);
+			var buf = Encoding.ASCII.GetBytes(name);
+			var ptr = Native.EVP_get_digestbyname(buf);
+
 			if (ptr == IntPtr.Zero)
 				return null;
+
 			return new MessageDigest(ptr, false);
 		}
 
@@ -93,28 +92,6 @@
 			get { return new NameCollector(Native.OBJ_NAME_TYPE_MD_METH, false).Result.ToArray(); }
 		}
 
-		#region EVP_MD
-		[StructLayout(LayoutKind.Sequential)]
-		struct EVP_MD
-		{
-			public int type;
-			public int pkey_type;
-			public int md_size;
-			public uint flags;
-			public IntPtr init;
-			public IntPtr update;
-			public IntPtr final;
-			public IntPtr copy;
-			public IntPtr cleanup;
-			public IntPtr sign;
-			public IntPtr verify;
-			[MarshalAs(UnmanagedType.ByValArray, SizeConst = 5)]
-			public int[] required_pkey_type;
-			public int block_size;
-			public int ctx_size;
-		}
-		#endregion
-
 		#region MessageDigests
 		/// <summary>
 		/// EVP_md_null()
@@ -188,7 +165,7 @@
 		/// </summary>
 		public int BlockSize
 		{
-			get { return this.raw.block_size; }
+			get { return Native.EVP_MD_block_size(ptr); }
 		}
 
 		/// <summary>
@@ -196,7 +173,7 @@
 		/// </summary>
 		public int Size
 		{
-			get { return this.raw.md_size; }
+			get { return Native.EVP_MD_size(ptr); }
 		}
 
 		/// <summary>
@@ -204,7 +181,7 @@
 		/// </summary>
 		public string LongName
 		{
-			get { return Native.OBJ_nid2ln(this.raw.type); }
+			get { return Native.StaticString(Native.OBJ_nid2ln(Native.EVP_MD_type(ptr))); }
 		}
 
 		/// <summary>
@@ -212,7 +189,7 @@
 		/// </summary>
 		public string Name
 		{
-			get { return Native.OBJ_nid2sn(this.raw.type); }
+			get { return Native.StaticString(Native.OBJ_nid2sn(Native.EVP_MD_type(ptr))); }
 		}
 
 		#endregion
@@ -246,7 +223,7 @@
 		public MessageDigestContext(BIO bio)
 			: base(Native.ExpectNonNull(Native.BIO_get_md_ctx(bio.Handle)), false)
 		{
-			this.md = new MessageDigest(Native.ExpectNonNull(Native.BIO_get_md(bio.Handle)), false);
+			md = new MessageDigest(Native.ExpectNonNull(Native.BIO_get_md(bio.Handle)), false);
 		}
 
 		/// <summary>
@@ -256,7 +233,7 @@
 		public MessageDigestContext(MessageDigest md)
 			: base(Native.EVP_MD_CTX_create(), true)
 		{
-			Native.EVP_MD_CTX_init(this.ptr);
+			Native.EVP_MD_CTX_init(ptr);
 			this.md = md;
 		}
 
@@ -266,7 +243,7 @@
 		/// <param name="bio"></param>
 		public override void Print(BIO bio)
 		{
-			bio.Write("MessageDigestContext: " + this.md.LongName);
+			bio.Write("MessageDigestContext: " + md.LongName);
 		}
 
 		#region Methods
@@ -278,11 +255,11 @@
 		/// <returns></returns>
 		public byte[] Digest(byte[] msg) 
 		{
-			byte[] digest = new byte[this.md.Size];
-			uint len = (uint)digest.Length;
-			Native.ExpectSuccess(Native.EVP_DigestInit_ex(this.ptr, this.md.Handle, IntPtr.Zero));
-			Native.ExpectSuccess(Native.EVP_DigestUpdate(this.ptr, msg, (uint)msg.Length));
-			Native.ExpectSuccess(Native.EVP_DigestFinal_ex(this.ptr, digest, ref len));
+			var digest = new byte[md.Size];
+			var len = (uint)digest.Length;
+			Native.ExpectSuccess(Native.EVP_DigestInit_ex(ptr, md.Handle, IntPtr.Zero));
+			Native.ExpectSuccess(Native.EVP_DigestUpdate(ptr, msg, (uint)msg.Length));
+			Native.ExpectSuccess(Native.EVP_DigestFinal_ex(ptr, digest, ref len));
 			return digest;
 		}
 
@@ -291,7 +268,7 @@
 		/// </summary>
 		public void Init()
 		{
-			Native.ExpectSuccess(Native.EVP_DigestInit_ex(this.ptr, this.md.Handle, IntPtr.Zero));
+			Native.ExpectSuccess(Native.EVP_DigestInit_ex(ptr, md.Handle, IntPtr.Zero));
 		}
 
 		/// <summary>
@@ -300,7 +277,7 @@
 		/// <param name="msg"></param>
 		public void Update(byte[] msg)
 		{
-			Native.ExpectSuccess(Native.EVP_DigestUpdate(this.ptr, msg, (uint)msg.Length));
+			Native.ExpectSuccess(Native.EVP_DigestUpdate(ptr, msg, (uint)msg.Length));
 		}
 
 		/// <summary>
@@ -309,9 +286,10 @@
 		/// <returns></returns>
 		public byte[] DigestFinal()
 		{
-			byte[] digest = new byte[this.md.Size];
-			uint len = (uint)digest.Length;
-			Native.ExpectSuccess(Native.EVP_DigestFinal_ex(this.ptr, digest, ref len));
+			var digest = new byte[md.Size];
+			var len = (uint)digest.Length;
+			Native.ExpectSuccess(Native.EVP_DigestFinal_ex(ptr, digest, ref len));
+			
 			return digest;
 		}
 
@@ -322,9 +300,10 @@
 		/// <returns></returns>
 		public byte[] SignFinal(CryptoKey pkey)
 		{
-			byte[] sig = new byte[pkey.Size];
-			uint len = (uint)sig.Length;
-			Native.ExpectSuccess(Native.EVP_SignFinal(this.ptr, sig, ref len, pkey.Handle));
+			var sig = new byte[pkey.Size];
+			var len = (uint)sig.Length;
+			Native.ExpectSuccess(Native.EVP_SignFinal(ptr, sig, ref len, pkey.Handle));
+
 			return sig;
 		}
 
@@ -336,7 +315,8 @@
 		/// <returns></returns>
 		public bool VerifyFinal(byte[] sig, CryptoKey pkey)
 		{
-			int ret = Native.ExpectSuccess(Native.EVP_VerifyFinal(this.ptr, sig, (uint)sig.Length, pkey.Handle));
+			var ret = Native.ExpectSuccess(Native.EVP_VerifyFinal(ptr, sig, (uint)sig.Length, pkey.Handle));
+
 			return ret == 1;
 		}
 
@@ -348,13 +328,15 @@
 		/// <returns></returns>
 		public byte[] Sign(byte[] msg, CryptoKey pkey) 
 		{
-			byte[] sig = new byte[pkey.Size];
-			uint len = (uint)sig.Length;
-			Native.ExpectSuccess(Native.EVP_DigestInit_ex(this.ptr, this.md.Handle, IntPtr.Zero));
-			Native.ExpectSuccess(Native.EVP_DigestUpdate(this.ptr, msg, (uint)msg.Length));
-			Native.ExpectSuccess(Native.EVP_SignFinal(this.ptr, sig, ref len, pkey.Handle));
-			byte[] ret = new byte[len];
+			var sig = new byte[pkey.Size];
+			var len = (uint)sig.Length;
+			Native.ExpectSuccess(Native.EVP_DigestInit_ex(ptr, md.Handle, IntPtr.Zero));
+			Native.ExpectSuccess(Native.EVP_DigestUpdate(ptr, msg, (uint)msg.Length));
+			Native.ExpectSuccess(Native.EVP_SignFinal(ptr, sig, ref len, pkey.Handle));
+
+			var ret = new byte[len];
 			Buffer.BlockCopy(sig, 0, ret, 0, (int)len);
+
 			return ret;
 		}
 
@@ -367,23 +349,24 @@
 		/// <returns></returns>
 		public static byte[] Sign(MessageDigest md, BIO bio, CryptoKey pkey)
 		{
-			BIO bmd = BIO.MessageDigest(md);
+			var bmd = BIO.MessageDigest(md);
 			bmd.Push(bio);
 
 			while (true)
 			{
-				ArraySegment<byte> bytes = bmd.ReadBytes(1024 * 4);
+				var bytes = bmd.ReadBytes(1024 * 4);
 				if (bytes.Count == 0)
 					break;
 			}
 
-			MessageDigestContext ctx = new MessageDigestContext(bmd);
+			var ctx = new MessageDigestContext(bmd);
 
-			byte[] sig = new byte[pkey.Size];
-			uint len = (uint)sig.Length;
+			var sig = new byte[pkey.Size];
+			var len = (uint)sig.Length;
 			Native.ExpectSuccess(Native.EVP_SignFinal(ctx.Handle, sig, ref len, pkey.Handle));
-			byte[] ret = new byte[len];
+			var ret = new byte[len];
 			Buffer.BlockCopy(sig, 0, ret, 0, (int)len);
+
 			return ret;
 		}
 
@@ -396,9 +379,10 @@
 		/// <returns></returns>
 		public bool Verify(byte[] msg, byte[] sig, CryptoKey pkey) 
 		{
-			Native.ExpectSuccess(Native.EVP_DigestInit_ex(this.ptr, this.md.Handle, IntPtr.Zero));
-			Native.ExpectSuccess(Native.EVP_DigestUpdate(this.ptr, msg, (uint)msg.Length));
-			int ret = Native.ExpectSuccess(Native.EVP_VerifyFinal(this.ptr, sig, (uint)sig.Length, pkey.Handle));
+			Native.ExpectSuccess(Native.EVP_DigestInit_ex(ptr, md.Handle, IntPtr.Zero));
+			Native.ExpectSuccess(Native.EVP_DigestUpdate(ptr, msg, (uint)msg.Length));
+
+			var ret = Native.ExpectSuccess(Native.EVP_VerifyFinal(ptr, sig, (uint)sig.Length, pkey.Handle));
 			return ret == 1;
 		}
 
@@ -412,19 +396,19 @@
 		/// <returns></returns>
 		public static bool Verify(MessageDigest md, BIO bio, byte[] sig, CryptoKey pkey)
 		{
-			BIO bmd = BIO.MessageDigest(md);
+			var bmd = BIO.MessageDigest(md);
 			bmd.Push(bio);
 
 			while (true)
 			{
-				ArraySegment<byte> bytes = bmd.ReadBytes(1024 * 4);
+				var bytes = bmd.ReadBytes(1024 * 4);
 				if (bytes.Count == 0)
 					break;
 			}
 
-			MessageDigestContext ctx = new MessageDigestContext(bmd);
+			var ctx = new MessageDigestContext(bmd);
 
-			int ret = Native.ExpectSuccess(Native.EVP_VerifyFinal(ctx.Handle, sig, (uint)sig.Length, pkey.Handle));
+			var ret = Native.ExpectSuccess(Native.EVP_VerifyFinal(ctx.Handle, sig, (uint)sig.Length, pkey.Handle));
 			return ret == 1;
 		}
 
@@ -436,10 +420,10 @@
 		/// Calls EVP_MD_CTX_cleanup() and EVP_MD_CTX_destroy()
 		/// </summary>
 		protected override void OnDispose() {
-			Native.EVP_MD_CTX_cleanup(this.ptr);
-			Native.EVP_MD_CTX_destroy(this.ptr);
+			Native.EVP_MD_CTX_cleanup(ptr);
+			Native.EVP_MD_CTX_destroy(ptr);
 		}
 
 		#endregion
 	}
-}
\ No newline at end of file
+}
Index: ManagedOpenSsl/Crypto/Micropross_SpeciaWrapper.cs
===================================================================
--- ManagedOpenSsl/Crypto/Micropross_SpeciaWrapper.cs	(revision 0)
+++ ManagedOpenSsl/Crypto/Micropross_SpeciaWrapper.cs	(revision 47851)
@@ -0,0 +1,121 @@
+﻿using OpenSSL.Core;
+using OpenSSL.Crypto.EC;
+
+namespace OpenSSL.Crypto
+{
+    /// <summary>
+    /// 
+    /// </summary>
+    public class Micropross_SpeciaWrapper
+    {
+        public static int EC_GROUP_set_curve_GFp(Group group, BigNumber p, BigNumber a, BigNumber b, BigNumber.Context context)
+        {
+            return Native.EC_GROUP_set_curve_GFp(group.Handle, p.Handle, a.Handle, b.Handle, context.Handle);
+        }
+
+        public static int EC_POINT_get_affine_coordinates_GFp(Group group, Point pk, BigNumber pk_x, BigNumber pk_y, BigNumber.Context context)
+        {
+            return Native.EC_POINT_get_affine_coordinates_GFp(group.Handle, pk.Handle, pk_x.Handle, pk_y.Handle, context.Handle);
+        }
+
+        public static int EC_POINT_set_affine_coordinates_GFp(Group group, Point g, BigNumber g_x, BigNumber g_y, BigNumber.Context context)
+        {
+            return Native.EC_POINT_set_affine_coordinates_GFp(group.Handle, g.Handle, g_x.Handle, g_y.Handle, context.Handle);
+        }
+
+        public static int EC_POINT_is_on_curve(Group group, Point g, BigNumber.Context context)
+        {
+            return Native.EC_POINT_is_on_curve(group.Handle, g.Handle, context.Handle);
+        }
+
+        public static int EC_GROUP_set_generator(Group group, Point g, BigNumber n, BigNumber f)
+        {
+            return Native.EC_GROUP_set_generator(group.Handle, g.Handle, n.Handle, f.Handle);
+        }
+
+        public static int EC_GROUP_check(Group group, BigNumber.Context context)
+        {
+            return Native.EC_GROUP_check(group.Handle, context.Handle);
+        }
+
+        public static int EC_KEY_set_group(Key key, Group group)
+        {
+            return Native.EC_KEY_set_group(key.Handle, group.Handle);
+        }
+
+        public static int EC_KEY_set_private_key(Key key, BigNumber privateKey)
+        {
+            return Native.EC_KEY_set_private_key(key.Handle, privateKey.Handle);
+        }
+
+        public static BigNumber EC_KEY_get0_private_key(Key key)
+        {
+            return new BigNumber(Native.EC_KEY_get0_private_key(key.Handle), false);
+        }
+
+        public static int EC_KEY_set_public_key(Key key, Point publicKey)
+        {
+            return Native.EC_KEY_set_public_key(key.Handle, publicKey.Handle);
+        }
+
+        public static int EC_KEY_check_key(Key key)
+        {
+            return Native.EC_KEY_check_key(key.Handle);
+        }
+
+        public static void BN_copy(BigNumber dest, Point pk)
+        {
+            Native.BN_copy(dest.Handle, pk.Handle);
+        }
+
+        public static int BN_mod(BigNumber r, BigNumber a, BigNumber m, BigNumber.Context ctx)
+        {
+            return Native.BN_mod(r.Handle, a.Handle, m.Handle, ctx.Handle);
+        }
+
+        public static int BN_nnmod(BigNumber r, BigNumber a, BigNumber m, BigNumber.Context ctx)
+        {
+            return Native.BN_nnmod(r.Handle, a.Handle, m.Handle, ctx.Handle);
+        }
+
+        public static int BN_mod_add(BigNumber r, BigNumber a, BigNumber b, BigNumber m, BigNumber.Context ctx)
+        {
+            return Native.BN_mod_add(r.Handle, a.Handle, b.Handle, m.Handle, ctx.Handle);
+        }
+
+        public static int BN_mod_sub(BigNumber r, BigNumber a, BigNumber b, BigNumber m, BigNumber.Context ctx)
+        {
+            return Native.BN_mod_sub(r.Handle, a.Handle, b.Handle, m.Handle, ctx.Handle);
+        }
+
+        public static int BN_mod_mul(BigNumber r, BigNumber a, BigNumber b, BigNumber m, BigNumber.Context ctx)
+        {
+            return Native.BN_mod_mul(r.Handle, a.Handle, b.Handle, m.Handle, ctx.Handle);
+        }
+
+        public static int BN_mod_sqr(BigNumber r, BigNumber a, BigNumber m, BigNumber.Context ctx)
+        {
+            return Native.BN_mod_sqr(r.Handle, a.Handle, m.Handle, ctx.Handle);
+        }
+
+        public static int BN_mod_exp(BigNumber r, BigNumber a, BigNumber b, BigNumber m, BigNumber.Context ctx)
+        {
+            return Native.BN_mod_exp(r.Handle, a.Handle, b.Handle, m.Handle, ctx.Handle);
+        }
+
+        public static int BN_mod_inverse(BigNumber r, BigNumber a, BigNumber n, BigNumber.Context ctx)
+        {
+            return Native.BN_mod_inverse(r.Handle, a.Handle, n.Handle, ctx.Handle);
+        }
+
+        public static int BN_exp(BigNumber r, BigNumber a, BigNumber p, BigNumber.Context ctx)
+        {
+            return Native.BN_exp(r.Handle, a.Handle, p.Handle, ctx.Handle);
+        }
+
+        public static int BN_gcd(BigNumber r, BigNumber a, BigNumber b, BigNumber.Context ctx)
+        {
+            return Native.BN_gcd(r.Handle, a.Handle, b.Handle, ctx.Handle);
+        }
+    }
+}
\ No newline at end of file
Index: ManagedOpenSsl/Crypto/RSA.cs
===================================================================
--- ManagedOpenSsl/Crypto/RSA.cs	(revision 47839)
+++ ManagedOpenSsl/Crypto/RSA.cs	(revision 47851)
@@ -23,11 +23,9 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Runtime.InteropServices;
-using OpenSSL.Core;
 
 namespace OpenSSL.Crypto
 {
@@ -34,7 +32,7 @@
 	/// <summary>
 	/// Wraps the RSA_* functions
 	/// </summary>
-	public class RSA : Base, IDisposable
+	public class RSA : BaseReference
 	{
 		#region rsa_st
 		[StructLayout(LayoutKind.Sequential)]
@@ -155,8 +153,9 @@
 		/// <returns></returns>
 		public static RSA FromPublicKey(BIO bio, PasswordHandler callback, object arg)
 		{
-			PasswordThunk thunk = new PasswordThunk(callback, arg);
-			IntPtr ptr = Native.PEM_read_bio_RSA_PUBKEY(bio.Handle, IntPtr.Zero, thunk.Callback, IntPtr.Zero);
+			var thunk = new PasswordThunk(callback, arg);
+			var ptr = Native.PEM_read_bio_RSA_PUBKEY(bio.Handle, IntPtr.Zero, thunk.Callback, IntPtr.Zero);
+			
 			return new RSA(Native.ExpectNonNull(ptr), true);
 		}
 
@@ -169,8 +168,9 @@
 		/// <returns></returns>
 		public static RSA FromPrivateKey(BIO bio, PasswordHandler callback, object arg)
 		{
-			PasswordThunk thunk = new PasswordThunk(callback, arg);
-			IntPtr ptr = Native.PEM_read_bio_RSAPrivateKey(bio.Handle, IntPtr.Zero, thunk.Callback, IntPtr.Zero);
+			var thunk = new PasswordThunk(callback, arg);
+			var ptr = Native.PEM_read_bio_RSAPrivateKey(bio.Handle, IntPtr.Zero, thunk.Callback, IntPtr.Zero);
+			
 			return new RSA(Native.ExpectNonNull(ptr), true);
 		}
 
@@ -179,8 +179,8 @@
 		#region Properties
 		private rsa_st Raw
 		{
-			get { return (rsa_st)Marshal.PtrToStructure(this.ptr, typeof(rsa_st)); }
-			set { Marshal.StructureToPtr(value, this.ptr, false); }
+			get { return (rsa_st)Marshal.PtrToStructure(ptr, typeof(rsa_st)); }
+			set { Marshal.StructureToPtr(value, ptr, false); }
 		}
 
 		/// <summary>
@@ -188,7 +188,7 @@
 		/// </summary>
 		public int Size
 		{
-			get { return Native.ExpectSuccess(Native.RSA_size(this.ptr)); }
+			get { return Native.ExpectSuccess(Native.RSA_size(ptr)); }
 		}
 
 		/// <summary>
@@ -207,12 +207,12 @@
 		/// </summary>
 		public BigNumber PublicExponent
 		{
-			get { return new BigNumber(this.Raw.e, false); }
+			get { return new BigNumber(Raw.e, false); }
 			set
 			{
-				rsa_st raw = this.Raw;
+				var raw = Raw;
 				raw.e = Native.BN_dup(value.Handle);
-				this.Raw = raw;
+				Raw = raw;
 			}
 		}
 
@@ -221,12 +221,12 @@
 		/// </summary>
 		public BigNumber PublicModulus
 		{
-			get { return new BigNumber(this.Raw.n, false); }
+			get { return new BigNumber(Raw.n, false); }
 			set
 			{
-				rsa_st raw = this.Raw;
+				var raw = Raw;
 				raw.n = Native.BN_dup(value.Handle);
-				this.Raw = raw;
+				Raw = raw;
 			}
 		}
 
@@ -235,12 +235,12 @@
 		/// </summary>
 		public BigNumber PrivateExponent
 		{
-			get { return new BigNumber(this.Raw.d, false); }
+			get { return new BigNumber(Raw.d, false); }
 			set
 			{
-				rsa_st raw = this.Raw;
+				var raw = Raw;
 				raw.d = Native.BN_dup(value.Handle);
-				this.Raw = raw;
+				Raw = raw;
 			}
 		}
 
@@ -249,12 +249,12 @@
 		/// </summary>
 		public BigNumber SecretPrimeFactorP
 		{
-			get { return new BigNumber(this.Raw.p, false); }
+			get { return new BigNumber(Raw.p, false); }
 			set
 			{
-				rsa_st raw = this.Raw;
+				var raw = Raw;
 				raw.p = Native.BN_dup(value.Handle);
-				this.Raw = raw;
+				Raw = raw;
 			}
 		}
 
@@ -263,12 +263,12 @@
 		/// </summary>
 		public BigNumber SecretPrimeFactorQ
 		{
-			get { return new BigNumber(this.Raw.q, false); }
+			get { return new BigNumber(Raw.q, false); }
 			set
 			{
-				rsa_st raw = this.Raw;
+				var raw = Raw;
 				raw.q = Native.BN_dup(value.Handle);
-				this.Raw = raw;
+				Raw = raw;
 			}
 		}
 
@@ -278,12 +278,12 @@
 		/// </summary>
 		public BigNumber DmodP1
 		{
-			get { return new BigNumber(this.Raw.dmp1, false); }
+			get { return new BigNumber(Raw.dmp1, false); }
 			set
 			{
-				rsa_st raw = this.Raw;
+				var raw = Raw;
 				raw.dmp1 = Native.BN_dup(value.Handle);
-				this.Raw = raw;
+				Raw = raw;
 			}
 		}
 
@@ -293,12 +293,12 @@
 		/// </summary>
 		public BigNumber DmodQ1
 		{
-			get { return new BigNumber(this.Raw.dmq1, false); }
+			get { return new BigNumber(Raw.dmq1, false); }
 			set
 			{
-				rsa_st raw = this.Raw;
+				var raw = Raw;
 				raw.dmq1 = Native.BN_dup(value.Handle);
-				this.Raw = raw;
+				Raw = raw;
 			}
 		}
 
@@ -308,12 +308,12 @@
 		/// </summary>
 		public BigNumber IQmodP
 		{
-			get { return new BigNumber(this.Raw.iqmp, false); }
+			get { return new BigNumber(Raw.iqmp, false); }
 			set
 			{
-				rsa_st raw = this.Raw;
+				var raw = Raw;
 				raw.iqmp = Native.BN_dup(value.Handle);
-				this.Raw = raw;
+				Raw = raw;
 			}
 		}
 
@@ -324,9 +324,9 @@
 		{
 			get
 			{
-				using (BIO bio = BIO.MemoryBuffer())
+				using (var bio = BIO.MemoryBuffer())
 				{
-					this.WritePublicKey(bio);
+					WritePublicKey(bio);
 					return bio.ReadString();
 				}
 			}
@@ -339,9 +339,9 @@
 		{
 			get
 			{
-				using (BIO bio = BIO.MemoryBuffer())
+				using (var bio = BIO.MemoryBuffer())
 				{
-					this.WritePrivateKey(bio, null, null, null);
+					WritePrivateKey(bio, null, null, null);
 					return bio.ReadString();
 				}
 			}
@@ -358,8 +358,8 @@
 		/// <param name="arg"></param>
 		public void GenerateKeys(int bits, BigNumber e, BigNumber.GeneratorHandler callback, object arg)
 		{
-			this.thunk = new BigNumber.GeneratorThunk(callback, arg);
-			Native.ExpectSuccess(Native.RSA_generate_key_ex(this.ptr, bits, e.Handle, this.thunk.CallbackStruct));
+			thunk = new BigNumber.GeneratorThunk(callback, arg);
+			Native.ExpectSuccess(Native.RSA_generate_key_ex(ptr, bits, e.Handle, thunk.CallbackStruct));
 		}
 
 		/// <summary>
@@ -370,14 +370,16 @@
 		/// <returns></returns>
 		public byte[] PublicEncrypt(byte[] msg, Padding padding)
 		{
-			byte[] ret = new byte[this.Size];
-			int len = Native.ExpectSuccess(Native.RSA_public_encrypt(msg.Length, msg, ret, this.ptr, (int)padding));
+			var ret = new byte[Size];
+			var len = Native.ExpectSuccess(Native.RSA_public_encrypt(msg.Length, msg, ret, ptr, (int)padding));
+
 			if (len != ret.Length)
 			{
-				byte[] tmp = new byte[len];
+				var tmp = new byte[len];
 				Buffer.BlockCopy(ret, 0, tmp, 0, len);
 				return tmp;
 			}
+
 			return ret;
 		}
 
@@ -408,14 +410,16 @@
 		/// <returns></returns>
 		public byte[] PublicDecrypt(byte[] msg, Padding padding)
 		{
-			byte[] ret = new byte[this.Size];
-			int len = Native.ExpectSuccess(Native.RSA_public_decrypt(msg.Length, msg, ret, this.ptr, (int)padding));
+			var ret = new byte[Size];
+			var len = Native.ExpectSuccess(Native.RSA_public_decrypt(msg.Length, msg, ret, ptr, (int)padding));
+
 			if (len != ret.Length)
 			{
-				byte[] tmp = new byte[len];
+				var tmp = new byte[len];
 				Buffer.BlockCopy(ret, 0, tmp, 0, len);
 				return tmp;
 			}
+
 			return ret;
 		}
 
@@ -427,14 +431,16 @@
 		/// <returns></returns>
 		public byte[] PrivateDecrypt(byte[] msg, Padding padding)
 		{
-			byte[] ret = new byte[this.Size];
-			int len = Native.ExpectSuccess(Native.RSA_private_decrypt(msg.Length, msg, ret, this.ptr, (int)padding));
+			var ret = new byte[this.Size];
+			var len = Native.ExpectSuccess(Native.RSA_private_decrypt(msg.Length, msg, ret, ptr, (int)padding));
+
 			if (len != ret.Length)
 			{
-				byte[] tmp = new byte[len];
+				var tmp = new byte[len];
 				Buffer.BlockCopy(ret, 0, tmp, 0, len);
 				return tmp;
 			}
+
 			return ret;
 		}
 
@@ -444,7 +450,7 @@
 		/// <param name="bio"></param>
 		public void WritePublicKey(BIO bio)
 		{
-			Native.ExpectSuccess(Native.PEM_write_bio_RSA_PUBKEY(bio.Handle, this.ptr));
+			Native.ExpectSuccess(Native.PEM_write_bio_RSA_PUBKEY(bio.Handle, ptr));
 		}
 
 		/// <summary>
@@ -473,7 +479,7 @@
 		/// <returns></returns>
 		public bool Check()
 		{
-			int ret = Native.ExpectSuccess(Native.RSA_check_key(this.ptr));
+			var ret = Native.ExpectSuccess(Native.RSA_check_key(ptr));
 			return ret == 1;
 		}
 
@@ -483,11 +489,18 @@
 		/// <param name="bio"></param>
 		public override void Print(BIO bio)
 		{
-			Native.ExpectSuccess(Native.RSA_print(bio.Handle, this.ptr, 0));
-		}
+			Native.ExpectSuccess(Native.RSA_print(bio.Handle, ptr, 0));
+		}
+
+		#endregion
+
+        public uint Sign(int type, byte[] m, byte[] sigret)
+        {
+            uint siglen; // = (uint)sig.Length;
+            Native.ExpectSuccess(Native.RSA_sign(type, m, (uint)m.Length, sigret, out siglen, this.ptr));
+            return siglen;
+        }
 
-		#endregion
-
 		#region IDisposable Members
 
 		/// <summary>
@@ -494,13 +507,18 @@
 		/// Calls RSA_free()
 		/// </summary>
 		protected override void OnDispose() {
-			Native.RSA_free(this.ptr);
+			Native.RSA_free(ptr);
 		}
 
 		#endregion
 
+		internal override void AddRef()
+		{
+			Native.RSA_up_ref(ptr);
+		}
+
 		#region Fields
 		private BigNumber.GeneratorThunk thunk = null;
 		#endregion
 	}
-}
\ No newline at end of file
+}
Index: ManagedOpenSsl/ManagedOpenSsl-2010.csproj
===================================================================
--- ManagedOpenSsl/ManagedOpenSsl-2010.csproj	(revision 47839)
+++ ManagedOpenSsl/ManagedOpenSsl-2010.csproj	(revision 47851)
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+﻿<?xml version="1.0" encoding="utf-8"?>
 <Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
@@ -15,7 +15,7 @@
     <OldToolsVersion>3.5</OldToolsVersion>
     <UpgradeBackupLocation>
     </UpgradeBackupLocation>
-    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <PublishUrl>publish\</PublishUrl>
     <Install>true</Install>
     <InstallFrom>Disk</InstallFrom>
@@ -31,29 +31,31 @@
     <IsWebBootstrapper>false</IsWebBootstrapper>
     <UseApplicationTrust>false</UseApplicationTrust>
     <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile>Client</TargetFrameworkProfile>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
     <DebugType>full</DebugType>
     <Optimize>false</Optimize>
-    <OutputPath>..\bin\Debug\</OutputPath>
+    <OutputPath>..\bin\</OutputPath>
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
-    <DocumentationFile>..\bin\Debug\ManagedOpenSsl.XML</DocumentationFile>
-    <PlatformTarget>x86</PlatformTarget>
+    <DocumentationFile>
+    </DocumentationFile>
+    <PlatformTarget>AnyCPU</PlatformTarget>
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
-    <OutputPath>..\bin\Release\</OutputPath>
+    <OutputPath>..\bin\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-    <DocumentationFile>..\bin\Release\ManagedOpenSsl.XML</DocumentationFile>
-    <PlatformTarget>x86</PlatformTarget>
+    <WarningLevel>0</WarningLevel>
+    <PlatformTarget>AnyCPU</PlatformTarget>
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <DocumentationFile>..\bin\ManagedOpenSsl.XML</DocumentationFile>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x64' ">
     <DebugSymbols>true</DebugSymbols>
@@ -72,7 +74,7 @@
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|x64' ">
     <OutputPath>bin\x64\Release\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
-    <DocumentationFile>..\ManagedOpenSsl.XML</DocumentationFile>
+    <DocumentationFile>bin\x64\Release\ManagedOpenSsl.XML</DocumentationFile>
     <Optimize>true</Optimize>
     <DebugType>pdbonly</DebugType>
     <PlatformTarget>x64</PlatformTarget>
@@ -82,13 +84,35 @@
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>bin\x86\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DocumentationFile>..\ManagedOpenSsl.XML</DocumentationFile>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
+    <OutputPath>bin\x86\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <DocumentationFile>bin\x86\Release\ManagedOpenSsl.XML</DocumentationFile>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
   <ItemGroup>
+    <Reference Include="AlphaFS2">
+      <HintPath>..\..\..\..\Applications\production\MPManager3\References_Release\AlphaFS2.dll</HintPath>
+    </Reference>
     <Reference Include="System" />
-    <Reference Include="System.Data" />
-    <Reference Include="System.Xml" />
   </ItemGroup>
   <ItemGroup>
     <Compile Include="Core\Asn1DateTime.cs" />
+    <Compile Include="Core\Asn1Encoding.cs" />
     <Compile Include="Core\Asn1String.cs" />
     <Compile Include="Core\Base.cs" />
     <Compile Include="Core\BIO.cs" />
@@ -95,8 +119,17 @@
     <Compile Include="Core\Asn1Integer.cs" />
     <Compile Include="Core\Crypto.cs" />
     <Compile Include="Core\MemoryTracker.cs" />
+    <Compile Include="Core\Threading.cs" />
     <Compile Include="Crypto\Cipher.cs" />
+    <Compile Include="Crypto\Micropross_SpeciaWrapper.cs" />
     <Compile Include="Properties\AssemblyInfo.cs" />
+    <Compile Include="SSL\AlpnException.cs" />
+    <Compile Include="SSL\ConnectionEnd.cs" />
+    <Compile Include="SSL\Extensions\Alpn.cs" />
+    <Compile Include="SSL\Extensions\EnumExtensions.cs" />
+    <Compile Include="SSL\Extensions\Errors.cs" />
+    <Compile Include="SSL\Extensions\SNI.cs" />
+    <Compile Include="SSL\Protocols.cs" />
     <Compile Include="X509\Configuration.cs" />
     <Compile Include="Crypto\CryptoKey.cs" />
     <Compile Include="Crypto\DH.cs" />
@@ -181,8 +214,9 @@
   <Target Name="AfterBuild">
   </Target>
   -->
-  <ItemGroup>
-    <Folder Include="SSL\" />
-    <Folder Include="Crypto\EC\" />
-  </ItemGroup>
+  <ItemGroup />
+  <PropertyGroup>
+    <PostBuildEvent>xcopy /Y "$(SolutionDir)native\windows\x86\libeay32.dll" "$(TargetDir)"
+xcopy /Y "$(SolutionDir)native\windows\x86\ssleay32.dll" "$(TargetDir)"</PostBuildEvent>
+  </PropertyGroup>
 </Project>
\ No newline at end of file
Index: ManagedOpenSsl/X509/Configuration.cs
===================================================================
--- ManagedOpenSsl/X509/Configuration.cs	(revision 47839)
+++ ManagedOpenSsl/X509/Configuration.cs	(revision 47851)
@@ -23,11 +23,10 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
 using System;
-using System.Collections.Generic;
+using System.Runtime.InteropServices;
 using System.Text;
-using System.Runtime.InteropServices;
-using OpenSSL.Core;
 
 namespace OpenSSL.X509
 {
@@ -88,8 +87,8 @@
 		/// </summary>
 		public void SetNoDB()
 		{
-			int db_offset = (int)Marshal.OffsetOf(typeof(X509V3_CTX), "db");
-			IntPtr db_param = new IntPtr((int)this.ptr + db_offset);
+			var db_offset = (int)Marshal.OffsetOf(typeof(X509V3_CTX), "db");
+			var db_param = new IntPtr((int)ptr + db_offset);
 			Marshal.WriteIntPtr(db_param, IntPtr.Zero);
 		}
 
@@ -99,7 +98,7 @@
 		/// <param name="cfg"></param>
 		public void SetConfiguration(Configuration cfg)
 		{
-			Native.X509V3_set_nconf(this.ptr, cfg.Handle);
+			Native.X509V3_set_nconf(ptr, cfg.Handle);
 		}
 
 		#endregion
@@ -111,7 +110,7 @@
 		/// </summary>
 		protected override void OnDispose()
 		{
-			Native.OPENSSL_free(this.ptr);
+			Native.OPENSSL_free(ptr);
 		}
 
 		#endregion
@@ -139,7 +138,7 @@
 		public Configuration(string filename)
 			: this()
 		{
-			this.Load(filename);
+			Load(filename);
 		}
 
 		#endregion
@@ -152,8 +151,8 @@
 		/// <param name="filename"></param>
 		public void Load(string filename)
 		{
-			int eline = 0;
-			Native.ExpectSuccess(Native.NCONF_load(this.ptr, filename, ref eline));
+			var eline = 0;
+			Native.ExpectSuccess(Native.NCONF_load(ptr, filename, ref eline));
 		}
 
 		/// <summary>
@@ -170,7 +169,7 @@
 			X509Certificate subject,
 			X509Request request)
 		{
-			using (X509V3Context ctx = new X509V3Context(issuer, subject, request))
+			using (var ctx = new X509V3Context(issuer, subject, request))
 			{
 				ctx.SetConfiguration(this);
 				Native.ExpectSuccess(Native.X509V3_EXT_add_nconf(
@@ -190,7 +189,7 @@
 		/// </summary>
 		protected override void OnDispose()
 		{
-			Native.NCONF_free(this.ptr);
+			Native.NCONF_free(ptr);
 		}
 
 		#endregion
Index: ManagedOpenSsl/X509/Identity.cs
===================================================================
--- ManagedOpenSsl/X509/Identity.cs	(revision 47839)
+++ ManagedOpenSsl/X509/Identity.cs	(revision 47851)
@@ -23,9 +23,6 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
 using OpenSSL.Crypto;
 
 namespace OpenSSL.X509
@@ -55,7 +52,7 @@
 		/// </summary>
 		public CryptoKey PublicKey
 		{
-			get { return this.cert.PublicKey; }
+			get { return cert.PublicKey; }
 		}
 
 		/// <summary>
@@ -63,7 +60,7 @@
 		/// </summary>
 		public CryptoKey PrivateKey
 		{
-			get { return this.key; }
+			get { return key; }
 		}
 
 		/// <summary>
@@ -71,7 +68,7 @@
 		/// </summary>
 		public X509Certificate Certificate
 		{
-			get { return this.cert; }
+			get { return cert; }
 		}
 		#endregion
 
@@ -83,24 +80,24 @@
 		/// <returns></returns>
 		public X509Request CreateRequest(string name)
 		{
-            return CreateRequest(name, MessageDigest.DSS1);
+			return CreateRequest(name, MessageDigest.DSS1);
 		}
 
-        /// <summary>
-        /// Create a X509Request for this identity, using the specified name and digest.
-        /// </summary>
-        /// <param name="name"></param>
-        /// <param name="digest"></param>
-        /// <returns></returns>
-        public X509Request CreateRequest(string name, MessageDigest digest)
-        {
-            X509Name subject = new X509Name(name);
-            X509Request request = new X509Request(2, subject, this.key);
+		/// <summary>
+		/// Create a X509Request for this identity, using the specified name and digest.
+		/// </summary>
+		/// <param name="name"></param>
+		/// <param name="digest"></param>
+		/// <returns></returns>
+		public X509Request CreateRequest(string name, MessageDigest digest)
+		{
+			var subject = new X509Name(name);
+			var request = new X509Request(2, subject, key);
 
-            request.Sign(key, digest);
+			request.Sign(key, digest);
 
-            return request;
-        }
+			return request;
+		}
 
 		/// <summary>
 		/// Verify that the specified chain can be trusted.
@@ -110,8 +107,8 @@
 		/// <returns></returns>
 		public bool VerifyResponse(X509Chain chain, out string error)
 		{
-            this.cert = chain[0];
-			X509Store store = new X509Store(chain);
+			cert = chain[0];
+			var store = new X509Store(chain);
 			return store.Verify(cert, out error);
 		}
 		#endregion
Index: ManagedOpenSsl/X509/PKCS12.cs
===================================================================
--- ManagedOpenSsl/X509/PKCS12.cs	(revision 47839)
+++ ManagedOpenSsl/X509/PKCS12.cs	(revision 47851)
@@ -23,11 +23,10 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
+using OpenSSL.Crypto;
 using System;
-using System.Text;
 using System.Runtime.InteropServices;
-using OpenSSL.Core;
-using OpenSSL.Crypto;
 
 namespace OpenSSL.X509
 {
@@ -36,17 +35,6 @@
 	/// </summary>
 	public class PKCS12 : Base
 	{
-		#region PKCS12 structure
-
-		[StructLayout(LayoutKind.Sequential)]
-		struct _PKCS12
-		{
-			public IntPtr version;     //ASN1_INTEGER *version;
-			public IntPtr mac;         //PKCS12_MAC_DATA *mac;
-			public IntPtr authsafes;   //PKCS7 *authsafes;
-		}
-		#endregion
-
 		/// <summary>
 		/// Password-Based Encryption (from PKCS #5)
 		/// </summary>
@@ -105,7 +93,7 @@
 			/// </summary>
 			SHA1_RC2_40 = 149
 		}
-		
+
 		/// <summary>
 		/// This is a non standard extension that is only currently interpreted by MSIE
 		/// </summary>
@@ -115,12 +103,12 @@
 			/// omit the flag from the private key
 			/// </summary>
 			KEY_DEFAULT = 0,
-		
+
 			/// <summary>
 			/// the key can be used for signing only
 			/// </summary>
 			KEY_SIG = 0x80,
-		
+
 			/// <summary>
 			/// the key can be used for signing and encryption
 			/// </summary>
@@ -137,7 +125,8 @@
 		/// <param name="cert"></param>
 		/// <param name="ca"></param>
 		public PKCS12(string password, CryptoKey key, X509Certificate cert, Stack<X509Certificate> ca) :
-			base(Create(password, null, key, cert, ca, PBE.Default, PBE.Default, 0, KeyType.KEY_DEFAULT), true) {
+			base(Create(password, null, key, cert, ca, PBE.Default, PBE.Default, 0, KeyType.KEY_DEFAULT), true)
+		{
 			Init(password);
 		}
 
@@ -153,31 +142,49 @@
 		/// <param name="certPbe">How to encrypt the certificate</param>
 		/// <param name="iterations"># of iterations during encryption</param>
 		/// <param name="keyType"></param>
-		public PKCS12(string password, string name, CryptoKey key, X509Certificate cert, Stack<X509Certificate> ca, PBE keyPbe, PBE certPbe, int iterations, KeyType keyType) :
-			base(Create(password, name, key, cert, ca, keyPbe, certPbe, iterations, keyType), true) {
+		public PKCS12(
+			string password,
+			string name,
+			CryptoKey key,
+			X509Certificate cert,
+			Stack<X509Certificate> ca,
+			PBE keyPbe,
+			PBE certPbe,
+			int iterations,
+			KeyType keyType) :
+			base(Create(password, name, key, cert, ca, keyPbe, certPbe, iterations, keyType), true)
+		{
 			Init(password);
 		}
 
 		private static IntPtr Create(
-			string password, 
-			string name, 
-			CryptoKey key, 
+			string password,
+			string name,
+			CryptoKey key,
 			X509Certificate cert,
 			Stack<X509Certificate> ca,
 			PBE keyPbe,
 			PBE certPbe,
 			int iterations,
-			KeyType keyType) {
+			KeyType keyType)
+		{
+			if (key == null)
+				throw new ArgumentException("Key cannot be null", "key");
+			if (cert == null)
+				throw new ArgumentException("Certificate cannot be null", "cert");
+			if (ca == null)
+				throw new ArgumentException("Certificate chain cannot be null", "ca");
+
 			return Native.ExpectNonNull(Native.PKCS12_create(
-				password, 
-				name, 
-				key.Handle, 
-				cert.Handle, 
-				ca.Handle, 
+				password,
+				name,
+				key.Handle,
+				cert.Handle,
+				ca.Handle,
 				(int)keyPbe,
 				(int)certPbe,
-				iterations, 
-				1, 
+				iterations,
+				1,
 				(int)keyType));
 		}
 
@@ -187,33 +194,34 @@
 		/// <param name="bio"></param>
 		/// <param name="password"></param>
 		public PKCS12(BIO bio, string password)
-			: base(Native.ExpectNonNull(Native.d2i_PKCS12_bio(bio.Handle, IntPtr.Zero)), true) {
+			: base(
+				Native.ExpectNonNull(Native.d2i_PKCS12_bio(bio.Handle, IntPtr.Zero)),
+				true)
+		{
 			Init(password);
 		}
 
-		private void Init(string password) {
+		private void Init(string password)
+		{
 			IntPtr cert;
 			IntPtr pkey;
 			IntPtr cacerts;
 
 			// Parse the PKCS12 object and get privatekey, cert, cacerts if available
-			Native.ExpectSuccess(Native.PKCS12_parse(this.ptr, password, out pkey, out cert, out cacerts));
+			Native.ExpectSuccess(Native.PKCS12_parse(ptr, password, out pkey, out cert, out cacerts));
 
-			if (cert != IntPtr.Zero) {
-				this.certificate = new X509Certificate(cert, true);
-				if (pkey != IntPtr.Zero) {
-					this.privateKey = new CryptoKey(pkey, true);
-
-					// We have a private key, assign it to the cert
-					this.certificate.PrivateKey = this.privateKey.CopyRef();
-				}
+			if (cert != IntPtr.Zero)
+			{
+				certificate = new X509Certificate(cert, pkey);
 			}
 
-			if (cacerts != IntPtr.Zero) {
-				this.caCertificates = new Stack<X509Certificate>(cacerts, true);
+			if (cacerts != IntPtr.Zero)
+			{
+				caCertificates = new Stack<X509Certificate>(cacerts, true);
 			}
-			else {
-				this.caCertificates = new Stack<X509Certificate>();
+			else
+			{
+				caCertificates = new Stack<X509Certificate>();
 			}
 		}
 
@@ -223,8 +231,9 @@
 		/// Calls i2d_PKCS12_bio()
 		/// </summary>
 		/// <param name="bio"></param>
-		public void Write(BIO bio) {
-			Native.ExpectSuccess(Native.i2d_PKCS12_bio(bio.Handle, this.Handle));
+		public void Write(BIO bio)
+		{
+			Native.ExpectSuccess(Native.i2d_PKCS12_bio(bio.Handle, Handle));
 		}
 
 		#region Properties
@@ -236,31 +245,13 @@
 		{
 			get
 			{
-				if (certificate != null)
-				{
-					X509Certificate cert = this.certificate.CopyRef();
-					if (privateKey != null)
-						cert.PrivateKey = this.privateKey.CopyRef();
-					return cert;
-				}
-				return null;
+				if (certificate == null)
+					return null;
+				return certificate.CopyRef();
 			}
 		}
 
 		/// <summary>
-		/// Returns the PrivateKey
-		/// </summary>
-		public CryptoKey PrivateKey
-		{
-			get
-			{
-				if (privateKey != null)
-					return this.privateKey.CopyRef();
-				return null;
-			}
-		}
-
-		/// <summary>
 		/// Returns a stack of CA Certificates
 		/// </summary>
 		public Stack<X509Certificate> CACertificates
@@ -282,25 +273,23 @@
 				certificate.Dispose();
 				certificate = null;
 			}
-			if (privateKey != null)
-			{
-				privateKey.Dispose();
-				privateKey = null;
-			}
+
 			if (caCertificates != null)
 			{
 				caCertificates.Dispose();
 				caCertificates = null;
 			}
-			Native.PKCS12_free(this.ptr);
+
+			Native.PKCS12_free(ptr);
 		}
 
 		#endregion
 
 		#region Fields
-		private CryptoKey privateKey;
+
 		private X509Certificate certificate;
 		private Stack<X509Certificate> caCertificates;
+
 		#endregion
 	}
 }
Index: ManagedOpenSsl/X509/PKCS7.cs
===================================================================
--- ManagedOpenSsl/X509/PKCS7.cs	(revision 47839)
+++ ManagedOpenSsl/X509/PKCS7.cs	(revision 47851)
@@ -23,11 +23,9 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Runtime.InteropServices;
-using OpenSSL.Core;
 
 namespace OpenSSL.X509
 {
@@ -117,22 +115,22 @@
 		#region Properties
 
 		/// <summary>
-		/// Extracts the X509Chain of certifcates from the internal PKCS7 structure
+		/// Extracts the X509Chain of certificates from the internal PKCS7 structure
 		/// </summary>
 		public X509Chain Certificates
 		{
 			get
 			{
-				if (this.stack == null)
+				if (stack == null)
 				{
-					int type = Native.OBJ_obj2nid(this.raw.type);
+					var type = Native.OBJ_obj2nid(raw.type);
 					switch (type)
 					{
 						case NID_pkcs7_signed:
-							this.stack = GetStackFromSigned();
+							stack = GetStackFromSigned();
 							break;
 						case NID_pkcs7_signedAndEnveloped:
-							this.stack = GetStackFromSignedAndEnveloped();
+							stack = GetStackFromSignedAndEnveloped();
 							break;
 						default:
 							throw new NotSupportedException();
@@ -141,15 +139,16 @@
 
 				// Can we remove this and just use a Chain to begin with?
 				X509Chain chain = null;
-				if (this.stack != null)
+				if (stack != null)
 				{
 					chain = new X509Chain();
 					// We have a stack of certificates, build the chain object and return
-					foreach (X509Certificate cert in this.stack)
+					foreach (var cert in stack)
 					{
 						chain.Add(cert);
 					}
 				}
+
 				return chain;
 			}
 		}
@@ -160,13 +159,13 @@
 
 		private Core.Stack<X509Certificate> GetStackFromSigned()
 		{
-			PKCS7_SIGNED signed = (PKCS7_SIGNED)Marshal.PtrToStructure(raw.ptr, typeof(PKCS7_SIGNED));
+			var signed = (PKCS7_SIGNED)Marshal.PtrToStructure(raw.ptr, typeof(PKCS7_SIGNED));
 			return new Core.Stack<X509Certificate>(signed.cert, false);
 		}
 
 		private Core.Stack<X509Certificate> GetStackFromSignedAndEnveloped()
 		{
-			PKCS7_SIGN_ENVELOPE envelope = (PKCS7_SIGN_ENVELOPE)Marshal.PtrToStructure(raw.ptr, typeof(PKCS7_SIGN_ENVELOPE));
+			var envelope = (PKCS7_SIGN_ENVELOPE)Marshal.PtrToStructure(raw.ptr, typeof(PKCS7_SIGN_ENVELOPE));
 			return new Core.Stack<X509Certificate>(envelope.cert, false);
 		}
 
@@ -179,12 +178,12 @@
 		/// </summary>
 		protected override void OnDispose()
 		{
-			Native.PKCS7_free(this.ptr);
+			Native.PKCS7_free(ptr);
 		}
 
 		internal override void OnNewHandle(IntPtr ptr)
 		{
-			this.raw = (_PKCS7)Marshal.PtrToStructure(ptr, typeof(_PKCS7));
+			raw = (_PKCS7)Marshal.PtrToStructure(ptr, typeof(_PKCS7));
 		}
 
 		#endregion
Index: ManagedOpenSsl/X509/VerifyResult.cs
===================================================================
--- ManagedOpenSsl/X509/VerifyResult.cs	(revision 47839)
+++ ManagedOpenSsl/X509/VerifyResult.cs	(revision 47851)
@@ -23,10 +23,7 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-	
+
 namespace OpenSSL.X509
 {
 	/// <summary>
@@ -203,5 +200,4 @@
 		/// </summary>
 		X509_V_ERR_APPLICATION_VERIFICATION = 50
 	}
-
 }
Index: ManagedOpenSsl/X509/X509Certificate.cs
===================================================================
--- ManagedOpenSsl/X509/X509Certificate.cs	(revision 47839)
+++ ManagedOpenSsl/X509/X509Certificate.cs	(revision 47851)
@@ -23,12 +23,10 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
+using OpenSSL.Crypto;
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Runtime.InteropServices;
-using OpenSSL.Core;
-using OpenSSL.Crypto;
 
 namespace OpenSSL.X509
 {
@@ -35,23 +33,46 @@
 	/// <summary>
 	/// Wraps the X509 object
 	/// </summary>
-	public class X509Certificate : BaseCopyableRef<X509Certificate>, IComparable<X509Certificate>, IStackable
+	public class X509Certificate : BaseReferenceImpl, IComparable<X509Certificate>, IStackable
 	{
 		#region Initialization
+
 		internal X509Certificate(IStack stack, IntPtr ptr)
 			: base(ptr, true)
-		{ }
+		{
+		}
 
 		internal X509Certificate(IntPtr ptr, bool owner)
 			: base(ptr, owner)
-		{ }
+		{
+		}
 
+		internal X509Certificate(IntPtr ptr, IntPtr pkey)
+			: base(ptr, true)
+		{
+			if (pkey != IntPtr.Zero)
+			{
+				privateKey = new CryptoKey(pkey, true);
+			}
+		}
+
+		private X509Certificate(X509Certificate other)
+			: base(other.Handle, true)
+		{
+			AddRef();
+			if (other.privateKey != null)
+			{
+				privateKey = other.privateKey.CopyRef();
+			}
+		}
+
 		/// <summary>
 		/// Calls X509_new()
 		/// </summary>
 		public X509Certificate()
 			: base(Native.ExpectNonNull(Native.X509_new()), true)
-		{ }
+		{
+		}
 
 		/// <summary>
 		/// Calls PEM_read_bio_X509()
@@ -58,8 +79,11 @@
 		/// </summary>
 		/// <param name="bio"></param>
 		public X509Certificate(BIO bio)
-			: base(Native.ExpectNonNull(Native.PEM_read_bio_X509(bio.Handle, IntPtr.Zero, null, IntPtr.Zero)), true)
-		{ }
+			: base(
+				Native.ExpectNonNull(Native.PEM_read_bio_X509(bio.Handle, IntPtr.Zero, null, IntPtr.Zero)),
+				true)
+		{
+		}
 
 		/// <summary>
 		/// Factory method that returns a X509 using d2i_X509_bio()
@@ -80,8 +104,9 @@
 		/// <returns></returns>
 		public static X509Certificate FromPKCS7_PEM(BIO bio)
 		{
-			PKCS7 pkcs7 = PKCS7.FromPEM(bio);
-			X509Chain chain = pkcs7.Certificates;
+			var pkcs7 = PKCS7.FromPEM(bio);
+			var chain = pkcs7.Certificates;
+
 			if (chain != null && chain.Count > 0)
 			{
 				return new X509Certificate(chain[0].Handle, false);
@@ -99,12 +124,14 @@
 		/// <returns></returns>
 		public static X509Certificate FromPKCS7_DER(BIO bio)
 		{
-			PKCS7 pkcs7 = PKCS7.FromDER(bio);
-			X509Chain chain = pkcs7.Certificates;
+			var pkcs7 = PKCS7.FromDER(bio);
+			var chain = pkcs7.Certificates;
+
 			if (chain != null && chain.Count > 0)
 			{
 				return new X509Certificate(chain[0].Handle, false);
 			}
+
 			return null;
 		}
 
@@ -116,7 +143,7 @@
 		/// <returns></returns>
 		public static X509Certificate FromPKCS12(BIO bio, string password)
 		{
-			using (PKCS12 p12 = new PKCS12(bio, password))
+			using (var p12 = new PKCS12(bio, password))
 			{
 				return p12.Certificate;
 			}
@@ -140,13 +167,13 @@
 			DateTime end)
 			: this()
 		{
-			this.Version = 2;
-			this.SerialNumber = serial;
-			this.Subject = subject;
-			this.Issuer = issuer;
-			this.PublicKey = pubkey;
-			this.NotBefore = start;
-			this.NotAfter = end;
+			Version = 2;
+			SerialNumber = serial;
+			Subject = subject;
+			Issuer = issuer;
+			PublicKey = pubkey;
+			NotBefore = start;
+			NotAfter = end;
 		}
 
 		#endregion
@@ -154,6 +181,7 @@
 		#region Raw Structures
 
 		#region X509_VAL
+
 		[StructLayout(LayoutKind.Sequential)]
 		private struct X509_VAL
 		{
@@ -160,9 +188,11 @@
 			public IntPtr notBefore;
 			public IntPtr notAfter;
 		}
+
 		#endregion
 
 		#region X509_CINF
+
 		[StructLayout(LayoutKind.Sequential)]
 		private struct X509_CINF
 		{
@@ -176,10 +206,13 @@
 			public IntPtr issuerUID;
 			public IntPtr subjectUID;
 			public IntPtr extensions;
+			public Asn1Encoding enc;
 		}
+
 		#endregion
 
 		#region X509
+
 		[StructLayout(LayoutKind.Sequential)]
 		private struct X509
 		{
@@ -189,10 +222,14 @@
 			public int valid;
 			public int references;
 			public IntPtr name;
+
 			#region CRYPTO_EX_DATA ex_data
+
 			public IntPtr ex_data_sk;
 			public int ex_data_dummy;
+
 			#endregion
+
 			public int ex_pathlen;
 			public int ex_pcpathlen;
 			public uint ex_flags;
@@ -202,6 +239,9 @@
 			public IntPtr skid;
 			public IntPtr akid;
 			public IntPtr policy_cache;
+			public IntPtr crldp;
+			public IntPtr altname;
+			public IntPtr nc;
 			public IntPtr rfc3779_addr;
 			public IntPtr rfc3779_asid;
 			[MarshalAs(UnmanagedType.ByValArray, SizeConst = Native.SHA_DIGEST_LENGTH)]
@@ -208,24 +248,26 @@
 			public byte[] sha1_hash;
 			public IntPtr aux;
 		}
+
 		#endregion
 
 		#endregion
 
 		#region Properties
+
 		private X509 Raw
 		{
-			get { return (X509)Marshal.PtrToStructure(this.ptr, typeof(X509)); }
+			get { return (X509)Marshal.PtrToStructure(ptr, typeof(X509)); }
 		}
 
 		private X509_CINF RawCertInfo
 		{
-			get { return (X509_CINF)Marshal.PtrToStructure(this.Raw.cert_info, typeof(X509_CINF)); }
+			get { return (X509_CINF)Marshal.PtrToStructure(Raw.cert_info, typeof(X509_CINF)); }
 		}
 
 		private X509_VAL RawValidity
 		{
-			get { return (X509_VAL)Marshal.PtrToStructure(this.RawCertInfo.validity, typeof(X509_VAL)); }
+			get { return (X509_VAL)Marshal.PtrToStructure(RawCertInfo.validity, typeof(X509_VAL)); }
 		}
 
 		/// <summary>
@@ -236,8 +278,8 @@
 			get
 			{
 				// Get the native pointer for the subject name
-				IntPtr name_ptr = Native.ExpectNonNull(Native.X509_get_subject_name(this.ptr));
-				X509Name ret = new X509Name(name_ptr, true);
+				var name_ptr = Native.ExpectNonNull(Native.X509_get_subject_name(this.ptr));
+				var ret = new X509Name(name_ptr, true);
 				// Duplicate the native pointer, as the X509_get_subject_name returns a pointer
 				// that is owned by the X509 object
 				ret.AddRef();
@@ -251,14 +293,15 @@
 		/// </summary>
 		public X509Name Issuer
 		{
-			get 
+			get
 			{
-				IntPtr name_ptr = Native.ExpectNonNull(Native.X509_get_issuer_name(this.ptr));
-				X509Name name = new X509Name(name_ptr, true);
+				var name_ptr = Native.ExpectNonNull(Native.X509_get_issuer_name(ptr));
+				var name = new X509Name(name_ptr, true);
 				name.AddRef();
+
 				return name;
 			}
-			set { Native.ExpectSuccess(Native.X509_set_issuer_name(this.ptr, value.Handle)); }
+			set { Native.ExpectSuccess(Native.X509_set_issuer_name(ptr, value.Handle)); }
 		}
 
 		/// <summary>
@@ -266,12 +309,12 @@
 		/// </summary>
 		public int SerialNumber
 		{
-			get { return Asn1Integer.ToInt32(Native.X509_get_serialNumber(this.ptr)); }
+			get { return Asn1Integer.ToInt32(Native.X509_get_serialNumber(ptr)); }
 			set
 			{
-				using (Asn1Integer asnInt = new Asn1Integer(value))
+				using (var asnInt = new Asn1Integer(value))
 				{
-					Native.ExpectSuccess(Native.X509_set_serialNumber(this.ptr, asnInt.Handle));
+					Native.ExpectSuccess(Native.X509_set_serialNumber(ptr, asnInt.Handle));
 				}
 			}
 		}
@@ -281,12 +324,12 @@
 		/// </summary>
 		public DateTime NotBefore
 		{
-			get { return Asn1DateTime.ToDateTime(this.RawValidity.notBefore); }
+			get { return Asn1DateTime.ToDateTime(RawValidity.notBefore); }
 			set
 			{
-				using (Asn1DateTime asnDateTime = new Asn1DateTime(value))
+				using (var asnDateTime = new Asn1DateTime(value))
 				{
-					Native.ExpectSuccess(Native.X509_set_notBefore(this.ptr, asnDateTime.Handle));
+					Native.ExpectSuccess(Native.X509_set_notBefore(ptr, asnDateTime.Handle));
 				}
 			}
 		}
@@ -296,12 +339,12 @@
 		/// </summary>
 		public DateTime NotAfter
 		{
-			get { return Asn1DateTime.ToDateTime(this.RawValidity.notAfter); }
+			get { return Asn1DateTime.ToDateTime(RawValidity.notAfter); }
 			set
 			{
-				using (Asn1DateTime asnDateTime = new Asn1DateTime(value))
+				using (var asnDateTime = new Asn1DateTime(value))
 				{
-					Native.ExpectSuccess(Native.X509_set_notAfter(this.ptr, asnDateTime.Handle));
+					Native.ExpectSuccess(Native.X509_set_notAfter(ptr, asnDateTime.Handle));
 				}
 			}
 		}
@@ -311,8 +354,8 @@
 		/// </summary>
 		public int Version
 		{
-			get { return Native.ASN1_INTEGER_get(this.RawCertInfo.version); }
-			set { Native.ExpectSuccess(Native.X509_set_version(this.ptr, value)); }
+			get { return Native.ASN1_INTEGER_get(RawCertInfo.version); }
+			set { Native.ExpectSuccess(Native.X509_set_version(ptr, value)); }
 		}
 
 		/// <summary>
@@ -320,13 +363,13 @@
 		/// </summary>
 		public CryptoKey PublicKey
 		{
-			get 
+			get
 			{
 				// X509_get_pubkey() will increment the refcount internally
-				IntPtr key_ptr = Native.ExpectNonNull(Native.X509_get_pubkey(this.ptr));
+				var key_ptr = Native.ExpectNonNull(Native.X509_get_pubkey(ptr));
 				return new CryptoKey(key_ptr, true);
 			}
-			set { Native.ExpectSuccess(Native.X509_set_pubkey(this.ptr, value.Handle)); }
+			set { Native.ExpectSuccess(Native.X509_set_pubkey(ptr, value.Handle)); }
 		}
 
 		/// <summary>
@@ -343,16 +386,28 @@
 		/// </summary>
 		public CryptoKey PrivateKey
 		{
-			get { return privateKey.CopyRef(); }
+			get
+			{
+				if (privateKey == null)
+					return null;
+				return privateKey.CopyRef();
+			}
 			set
 			{
-				if (CheckPrivateKey(value))
+				if (value == null)
 				{
-					privateKey = value.CopyRef();
+					privateKey = null;
 				}
 				else
 				{
-					throw new ArgumentException("Private key doesn't correspond to the this certificate");
+					if (CheckPrivateKey(value))
+					{
+						privateKey = value.CopyRef();
+					}
+					else
+					{
+						throw new ArgumentException("Private key doesn't correspond to the this certificate");
+					}
 				}
 			}
 		}
@@ -375,18 +430,32 @@
 		/// <summary>
 		/// Returns the DER formatted byte array for this object
 		/// </summary>
-		public byte[] DER {
-			get {
-				using (BIO bio = BIO.MemoryBuffer()) {
-					this.Write_DER(bio);
+		public byte[] DER
+		{
+			get
+			{
+				using (var bio = BIO.MemoryBuffer())
+				{
+					Write_DER(bio);
 					return bio.ReadBytes((int)bio.NumberWritten).Array;
 				}
 			}
 		}
+
 		#endregion
 
 		#region Methods
+
 		/// <summary>
+		/// Returns a copy of this object.
+		/// </summary>
+		/// <returns></returns>
+		public X509Certificate CopyRef()
+		{
+			return new X509Certificate(this);
+		}
+
+		/// <summary>
 		/// Calls X509_sign()
 		/// </summary>
 		/// <param name="pkey"></param>
@@ -393,7 +462,7 @@
 		/// <param name="digest"></param>
 		public void Sign(CryptoKey pkey, MessageDigest digest)
 		{
-			if (Native.X509_sign(this.ptr, pkey.Handle, digest.Handle) == 0)
+			if (Native.X509_sign(ptr, pkey.Handle, digest.Handle) == 0)
 				throw new OpenSslException();
 		}
 
@@ -404,7 +473,7 @@
 		/// <returns></returns>
 		public bool CheckPrivateKey(CryptoKey pkey)
 		{
-			return Native.X509_check_private_key(this.ptr, pkey.Handle) == 1;
+			return Native.X509_check_private_key(ptr, pkey.Handle) == 1;
 		}
 
 		/// <summary>
@@ -415,7 +484,7 @@
 		/// <returns></returns>
 		public bool CheckTrust(int id, int flags)
 		{
-			return Native.X509_check_trust(this.ptr, id, flags) == 1;
+			return Native.X509_check_trust(ptr, id, flags) == 1;
 		}
 
 		/// <summary>
@@ -425,9 +494,11 @@
 		/// <returns></returns>
 		public bool Verify(CryptoKey pkey)
 		{
-			int ret = Native.X509_verify(this.ptr, pkey.Handle);
+			var ret = Native.X509_verify(ptr, pkey.Handle);
+
 			if (ret < 0)
 				throw new OpenSslException();
+
 			return ret == 1;
 		}
 
@@ -439,8 +510,10 @@
 		/// <returns></returns>
 		public ArraySegment<byte> Digest(IntPtr type, byte[] digest)
 		{
-			uint len = (uint)digest.Length;
-			Native.ExpectSuccess(Native.X509_digest(this.ptr, type, digest, ref len));
+			var len = (uint)digest.Length;
+
+			Native.ExpectSuccess(Native.X509_digest(ptr, type, digest, ref len));
+
 			return new ArraySegment<byte>(digest, 0, (int)len);
 		}
 
@@ -452,8 +525,10 @@
 		/// <returns></returns>
 		public ArraySegment<byte> DigestPublicKey(IntPtr type, byte[] digest)
 		{
-			uint len = (uint)digest.Length;
-			Native.ExpectSuccess(Native.X509_pubkey_digest(this.ptr, type, digest, ref len));
+			var len = (uint)digest.Length;
+
+			Native.ExpectSuccess(Native.X509_pubkey_digest(ptr, type, digest, ref len));
+
 			return new ArraySegment<byte>(digest, 0, (int)len);
 		}
 
@@ -463,7 +538,7 @@
 		/// <param name="bio"></param>
 		public void Write(BIO bio)
 		{
-			Native.ExpectSuccess(Native.PEM_write_bio_X509(bio.Handle, this.ptr));
+			Native.ExpectSuccess(Native.PEM_write_bio_X509(bio.Handle, ptr));
 		}
 
 		/// <summary>
@@ -470,8 +545,9 @@
 		/// Calls i2d_X509_bio()
 		/// </summary>
 		/// <param name="bio"></param>
-		public void Write_DER(BIO bio) {
-			Native.ExpectSuccess(Native.i2d_X509_bio(bio.Handle, this.ptr));
+		public void Write_DER(BIO bio)
+		{
+			Native.ExpectSuccess(Native.i2d_X509_bio(bio.Handle, ptr));
 		}
 
 		/// <summary>
@@ -480,7 +556,7 @@
 		/// <param name="bio"></param>
 		public override void Print(BIO bio)
 		{
-			Native.ExpectSuccess(Native.X509_print(bio.Handle, this.ptr));
+			Native.ExpectSuccess(Native.X509_print(bio.Handle, ptr));
 		}
 
 		/// <summary>
@@ -491,7 +567,7 @@
 		/// <returns></returns>
 		public X509Request CreateRequest(CryptoKey pkey, MessageDigest digest)
 		{
-			return new X509Request(Native.ExpectNonNull(Native.X509_to_X509_REQ(this.ptr, pkey.Handle, digest.Handle)), true);
+			return new X509Request(Native.ExpectNonNull(Native.X509_to_X509_REQ(ptr, pkey.Handle, digest.Handle)), true);
 		}
 
 		/// <summary>
@@ -500,7 +576,7 @@
 		/// <param name="ext"></param>
 		public void AddExtension(X509Extension ext)
 		{
-			Native.ExpectSuccess(Native.X509_add_ext(this.ptr, ext.Handle, -1));
+			Native.ExpectSuccess(Native.X509_add_ext(ptr, ext.Handle, -1));
 		}
 
 		/// <summary>
@@ -512,7 +588,7 @@
 		/// <param name="flags"></param>
 		public void AddExtension(string name, byte[] value, int crit, uint flags)
 		{
-			Native.ExpectSuccess(Native.X509_add1_ext_i2d(this.ptr, Native.TextToNID(name), value, crit, flags));
+			Native.ExpectSuccess(Native.X509_add1_ext_i2d(ptr, Native.TextToNID(name), value, crit, flags));
 		}
 
 		/// <summary>
@@ -526,7 +602,7 @@
 				{
 					return new Core.Stack<X509Extension>(RawCertInfo.extensions, false);
 				}
-				return null;
+				return new Core.Stack<X509Extension>();
 			}
 		}
 
@@ -536,7 +612,7 @@
 		/// <param name="sk_ext"></param>
 		public void AddExtensions(Core.Stack<X509Extension> sk_ext)
 		{
-			foreach (X509Extension ext in sk_ext)
+			foreach (var ext in sk_ext)
 			{
 				AddExtension(ext);
 			}
@@ -545,12 +621,14 @@
 		#endregion
 
 		#region Overrides
+
 		/// <summary>
 		/// Calls X509_free()
 		/// </summary>
 		protected override void OnDispose()
 		{
-			Native.X509_free(this.ptr);
+			Native.X509_free(ptr);
+
 			if (privateKey != null)
 			{
 				privateKey.Dispose();
@@ -565,10 +643,12 @@
 		/// <returns></returns>
 		public override bool Equals(object obj)
 		{
-			X509Certificate rhs = obj as X509Certificate;
+			var rhs = obj as X509Certificate;
+
 			if (rhs == null)
 				return false;
-			return this.CompareTo(rhs) == 0;
+
+			return CompareTo(rhs) == 0;
 		}
 
 		/// <summary>
@@ -577,7 +657,7 @@
 		/// <returns></returns>
 		public override int GetHashCode()
 		{
-			return this.Issuer.OneLine.GetHashCode() ^ this.SerialNumber;
+			return Issuer.OneLine.GetHashCode() ^ SerialNumber;
 		}
 
 		internal override CryptoLockTypes LockType
@@ -601,13 +681,15 @@
 		/// <returns></returns>
 		public int CompareTo(X509Certificate other)
 		{
-			return Native.X509_cmp(this.ptr, other.ptr);
+			return Native.X509_cmp(ptr, other.ptr);
 		}
 
 		#endregion
 
 		#region Fields
+
 		private CryptoKey privateKey;
+
 		#endregion
 	}
 }
Index: ManagedOpenSsl/X509/X509CertificateAuthority.cs
===================================================================
--- ManagedOpenSsl/X509/X509CertificateAuthority.cs	(revision 47839)
+++ ManagedOpenSsl/X509/X509CertificateAuthority.cs	(revision 47851)
@@ -23,15 +23,15 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Crypto;
 using System;
-using System.Collections.Generic;
 using System.IO;
 using System.Threading;
-using OpenSSL.Crypto;
+using System.Collections.Generic;
 
 namespace OpenSSL.X509
 {
-    /// <summary>
+	/// <summary>
 	/// Used for generating sequence numbers by the CertificateAuthority
 	/// </summary>
 	public interface ISequenceNumber
@@ -51,6 +51,7 @@
 	public class FileSerialNumber : ISequenceNumber
 	{
 		private string path;
+
 		/// <summary>
 		/// Constructs a FileSerialNumber. The path specifies where 
 		/// the serial number should be read and written to.
@@ -62,6 +63,7 @@
 		}
 
 		#region ISequenceNumber Members
+
 		/// <summary>
 		/// Implements the Next() method of the ISequenceNumber interface.
 		/// The sequence number is read from a file, incremented, 
@@ -86,7 +88,7 @@
 					}
 				}
 
-				using(StreamWriter sr = new StreamWriter(serialFile.FullName))
+				using (StreamWriter sr = new StreamWriter(serialFile.FullName))
 				{
 					sr.Write(serial.ToString());
 				}
@@ -94,6 +96,7 @@
 				return serial;
 			}
 		}
+
 		#endregion
 	}
 
@@ -107,7 +110,10 @@
 		/// <summary>
 		/// Construct a SimpleSerialNumber with the initial sequence number set to 0.
 		/// </summary>
-		public SimpleSerialNumber() { this.seq = 0; }
+		public SimpleSerialNumber()
+		{
+			seq = 0;
+		}
 
 		/// <summary>
 		/// Construct a SimpleSerialNumber with the initial sequence number
@@ -114,7 +120,10 @@
 		/// set to the value specified by the seed parameter.
 		/// </summary>
 		/// <param name="seed"></param>
-		public SimpleSerialNumber(int seed) { this.seq = seed; }
+		public SimpleSerialNumber(int seed)
+		{
+			seq = seed;
+		}
 
 		#region ISequenceNumber Members
 
@@ -159,107 +168,110 @@
 			TimeSpan validity)
 		{
 			CryptoKey key;
-			using (DSA dsa = new DSA(true))
+			using (var dsa = new DSA(true))
 			{
 				key = new CryptoKey(dsa);
 				// Dispose the DSA key, the CryptoKey assignment increments the reference count
 			}
-			X509Certificate cert = new X509Certificate(
-				seq.Next(),
-				subject,
-				subject,
-                key,
-				start,
-				start + validity);
 
-			if(cfg != null)
+			var cert = new X509Certificate(
+				           seq.Next(),
+				           subject,
+				           subject,
+				           key,
+				           start,
+				           start + validity);
+
+			if (cfg != null)
 				cfg.ApplyExtensions("v3_ca", cert, cert, null);
 
 			cert.Sign(key, MessageDigest.DSS1);
 
-			return new X509CertificateAuthority(cert, key, seq, cfg);
+			return new X509CertificateAuthority(cert, key, seq);
 		}
 
-        /// <summary>
-        /// Factory method that creates a X509CertificateAuthority instance with
-        /// an internal self signed certificate
-        /// </summary>
-        /// <param name="cfg"></param>
-        /// <param name="seq"></param>
-        /// <param name="key"></param>
-        /// <param name="digest"></param>
-        /// <param name="subject"></param>
-        /// <param name="start"></param>
-        /// <param name="validity"></param>
-        /// <returns></returns>
-        public static X509CertificateAuthority SelfSigned(
-            Configuration cfg,
-            ISequenceNumber seq,
-            CryptoKey key,
-            MessageDigest digest,
-            X509Name subject,
-            DateTime start,
-            TimeSpan validity)
-        {
-            X509Certificate cert = new X509Certificate(
-                seq.Next(),
-                subject,
-                subject,
-                key,
-                start,
-                start + validity);
+		/// <summary>
+		/// Factory method that creates a X509CertificateAuthority instance with
+		/// an internal self signed certificate
+		/// </summary>
+		/// <param name="cfg"></param>
+		/// <param name="seq"></param>
+		/// <param name="key"></param>
+		/// <param name="digest"></param>
+		/// <param name="subject"></param>
+		/// <param name="start"></param>
+		/// <param name="validity"></param>
+		/// <returns></returns>
+		public static X509CertificateAuthority SelfSigned(
+			Configuration cfg,
+			ISequenceNumber seq,
+			CryptoKey key,
+			MessageDigest digest,
+			X509Name subject,
+			DateTime start,
+			TimeSpan validity)
+		{
+			var cert = new X509Certificate(
+				           seq.Next(),
+				           subject,
+				           subject,
+				           key,
+				           start,
+				           start + validity);
 
-            if (cfg != null)
-                cfg.ApplyExtensions("v3_ca", cert, cert, null);
+			if (cfg != null)
+				cfg.ApplyExtensions("v3_ca", cert, cert, null);
 
-            cert.Sign(key, digest);
+			cert.Sign(key, digest);
 
-            return new X509CertificateAuthority(cert, key, seq, cfg);
-        }
+			return new X509CertificateAuthority(cert, key, seq);
+		}
 
-        /// <summary>
-        /// Factory method that creates a X509CertificateAuthority instance with
-        /// an internal self signed certificate. This method allows creation without
-        /// the need for the Configuration file, X509V3Extensions may be added
-        /// with the X509V3ExtensionList parameter
-        /// </summary>
-        /// <param name="seq"></param>
-        /// <param name="key"></param>
-        /// <param name="digest"></param>
-        /// <param name="subject"></param>
-        /// <param name="start"></param>
-        /// <param name="validity"></param>
-        /// <param name="extensions"></param>
-        /// <returns></returns>
-        public static X509CertificateAuthority SelfSigned(
-            ISequenceNumber seq,
-            CryptoKey key,
-            MessageDigest digest,
-            X509Name subject,
-            DateTime start,
-            TimeSpan validity,
-            X509V3ExtensionList extensions)
-        {
-            X509Certificate cert = new X509Certificate(
-                seq.Next(),
-                subject,
-                subject,
-                key,
-                start,
-                start + validity);
+		/// <summary>
+		/// Factory method that creates a X509CertificateAuthority instance with
+		/// an internal self signed certificate. This method allows creation without
+		/// the need for the Configuration file, X509V3Extensions may be added
+		/// with the X509V3ExtensionList parameter
+		/// </summary>
+		/// <param name="seq"></param>
+		/// <param name="key"></param>
+		/// <param name="digest"></param>
+		/// <param name="subject"></param>
+		/// <param name="start"></param>
+		/// <param name="validity"></param>
+		/// <param name="extensions"></param>
+		/// <returns></returns>
+		public static X509CertificateAuthority SelfSigned(
+			ISequenceNumber seq,
+			CryptoKey key,
+			MessageDigest digest,
+			X509Name subject,
+			DateTime start,
+			TimeSpan validity,
+			IEnumerable<X509V3ExtensionValue> extensions)
+		{
+			var cert = new X509Certificate(
+				           seq.Next(),
+				           subject,
+				           subject,
+				           key,
+				           start,
+				           start + validity);
 
-            if (null != extensions)
-            {
-                foreach (X509V3ExtensionValue extValue in extensions)
-                {
-                    X509Extension ext = new X509Extension(cert, cert, extValue.Name, extValue.IsCritical, extValue.Value);
-                    cert.AddExtension(ext);
-                }
-            }
+			if (extensions != null)
+			{
+				foreach (var extValue in extensions)
+				{
+					using (var ext = new X509Extension(cert, cert, extValue.Name, extValue.IsCritical, extValue.Value))
+					{
+						cert.AddExtension(ext);
+					}
+				}
+			}
 
-            cert.Sign(key, digest);
+			cert.Sign(key, digest);
 
-            return new X509CertificateAuthority(cert, key, seq, null);
+			return new X509CertificateAuthority(cert, key, seq);
 		}
 
 		#endregion
@@ -272,15 +284,14 @@
 		/// <param name="caCert"></param>
 		/// <param name="caKey"></param>
 		/// <param name="serial"></param>
-		/// <param name="cfg"></param>
-		public X509CertificateAuthority(X509Certificate caCert, CryptoKey caKey, ISequenceNumber serial, Configuration cfg)
+		public X509CertificateAuthority(X509Certificate caCert, CryptoKey caKey, ISequenceNumber serial)
 		{
 			if (!caCert.CheckPrivateKey(caKey))
 				throw new Exception("The specified CA Private Key does match the specified CA Certificate");
+
 			this.caCert = caCert;
 			this.caKey = caKey;
 			this.serial = serial;
-			this.cfg = cfg;
 		}
 
 		#endregion
@@ -292,7 +303,7 @@
 		/// </summary>
 		public X509Certificate Certificate
 		{
-			get { return this.caCert; }
+			get { return caCert; }
 		}
 
 		/// <summary>
@@ -300,7 +311,7 @@
 		/// </summary>
 		public CryptoKey Key
 		{
-			get { return this.caKey; }
+			get { return caKey; }
 		}
 
 		#endregion
@@ -308,49 +319,64 @@
 		#region Methods
 
 		/// <summary>
-		/// Process and X509Request. This includes creating a new X509Certificate
+		/// Process an X509Request. This includes creating a new X509Certificate
 		/// and signing this certificate with this CA's private key.
 		/// </summary>
 		/// <param name="request"></param>
-		/// <param name="startTime"></param>
-		/// <param name="endTime"></param>
+		/// <param name="startTime"></param>
+		/// <param name="endTime"></param>
+		/// <param name="cfg"></param>
+		/// <param name="section"></param>
 		/// <returns></returns>
-		public X509Certificate ProcessRequest(X509Request request, DateTime startTime, DateTime endTime)
+		public X509Certificate ProcessRequest(
+			X509Request request, 
+			DateTime startTime, 
+			DateTime endTime,
+			Configuration cfg,
+			string section)
 		{
-            return ProcessRequest(request, startTime, endTime, MessageDigest.DSS1);
+			return ProcessRequest(request, startTime, endTime, cfg, section, MessageDigest.DSS1);
 		}
 
-        /// <summary>
-        /// Process and X509Request. This includes creating a new X509Certificate
-        /// and signing this certificate with this CA's private key.
-        /// </summary>
-        /// <param name="request"></param>
-        /// <param name="startTime"></param>
-        /// <param name="endTime"></param>
-        /// <param name="digest"></param>
-        /// <returns></returns>
-        public X509Certificate ProcessRequest(X509Request request, DateTime startTime, DateTime endTime, MessageDigest digest)
-        {
-            //using (CryptoKey pkey = request.PublicKey)
-            //{
-            //    if (!request.Verify(pkey))
-            //        throw new Exception("Request signature validation failed");
-            //}
+		/// <summary>
+		/// Process an X509Request. This includes creating a new X509Certificate
+		/// and signing this certificate with this CA's private key.
+		/// </summary>
+		/// <param name="request"></param>
+		/// <param name="startTime"></param>
+		/// <param name="endTime"></param>
+		/// <param name="cfg"></param>
+		/// <param name="section"></param>
+		/// <param name="digest"></param>
+		/// <returns></returns>
+		public X509Certificate ProcessRequest(
+			X509Request request,
+			DateTime startTime,
+			DateTime endTime,
+			Configuration cfg,
+			string section,
+			MessageDigest digest)
+		{
+//			using (var pkey = request.PublicKey)
+//			{
+//				if (!request.Verify(pkey))
+//					throw new Exception("Request signature validation failed");
+//			}
 
-            X509Certificate cert = new X509Certificate(
-                serial.Next(),
-                request.Subject,
-                this.caCert.Subject,
-                request.PublicKey,
-                startTime,
-                endTime);
+			var cert = new X509Certificate(
+				           serial.Next(),
+				           request.Subject,
+				           this.caCert.Subject,
+				           request.PublicKey,
+				           startTime,
+				           endTime);
 
-            if (this.cfg != null)
-                this.cfg.ApplyExtensions("v3_ca", this.caCert, cert, request);
+			if (cfg != null)
+				cfg.ApplyExtensions(section, caCert, cert, request);
 
-            cert.Sign(this.caKey, digest);
+			cert.Sign(caKey, digest);
 
-            return cert;
+			return cert;
 		}
 
 		#endregion
@@ -362,32 +388,27 @@
 		/// </summary>
 		public void Dispose()
 		{
-			if (this.caKey != null)
+			if (caKey != null)
 			{
-				this.caKey.Dispose();
-				this.caKey = null;
+				caKey.Dispose();
+				caKey = null;
 			}
 
-			if (this.caCert != null)
+			if (caCert != null)
 			{
-				this.caCert.Dispose();
-				this.caCert = null;
+				caCert.Dispose();
+				caCert = null;
 			}
-
-			if (this.cfg != null)
-			{
-				this.cfg.Dispose();
-				this.cfg = null;
-			}
 		}
 
 		#endregion
 
 		#region Fields
+
 		private X509Certificate caCert;
 		private CryptoKey caKey;
 		private ISequenceNumber serial;
-		private Configuration cfg;
+
 		#endregion
 	}
 }
Index: ManagedOpenSsl/X509/X509CertificateInfo.cs
===================================================================
--- ManagedOpenSsl/X509/X509CertificateInfo.cs	(revision 47839)
+++ ManagedOpenSsl/X509/X509CertificateInfo.cs	(revision 47851)
@@ -23,16 +23,14 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
+using OpenSSL.Crypto;
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Runtime.InteropServices;
-using OpenSSL.Core;
-using OpenSSL.Crypto;
 
 namespace OpenSSL.X509
 {
-	internal class X509CertificateInfo : BaseReferenceType, IStackable
+	internal class X509CertificateInfo : BaseReference, IStackable
 	{
 		#region X509_INFO
 		[StructLayout(LayoutKind.Sequential)]
@@ -65,8 +63,9 @@
 		{
 			get
 			{
-				X509Certificate ret = new X509Certificate(this.raw.x509, true);
+				var ret = new X509Certificate(raw.x509, true);
 				ret.AddRef();
+
 				return ret;
 			}
 		}
@@ -75,8 +74,9 @@
 		{
 			get
 			{
-				CryptoKey ret = new CryptoKey(this.raw.x_pkey, true);
+				var ret = new CryptoKey(raw.x_pkey, true);
 				ret.AddRef();
+
 				return ret;
 			}
 		}
@@ -87,24 +87,19 @@
 
 		internal override void OnNewHandle(IntPtr ptr)
 		{
-			this.raw = (X509_INFO)Marshal.PtrToStructure(this.ptr, typeof(X509_INFO));
+			raw = (X509_INFO)Marshal.PtrToStructure(this.ptr, typeof(X509_INFO));
 		}
 
 		protected override void OnDispose()
 		{
-			Native.X509_INFO_free(this.ptr);
+			Native.X509_INFO_free(ptr);
 		}
 
-		internal override CryptoLockTypes LockType
+		internal override void AddRef()
 		{
-			get { return CryptoLockTypes.CRYPTO_LOCK_X509_INFO; }
+			Native.X509_INFO_up_ref(ptr);
 		}
 
-		internal override Type RawReferenceType
-		{
-			get { return typeof(X509_INFO); }
-		}
-
 		#endregion
 
 		#region Fields
@@ -111,5 +106,4 @@
 		private X509_INFO raw;
 		#endregion
 	}
-
 }
Index: ManagedOpenSsl/X509/X509Chain.cs
===================================================================
--- ManagedOpenSsl/X509/X509Chain.cs	(revision 47839)
+++ ManagedOpenSsl/X509/X509Chain.cs	(revision 47851)
@@ -23,11 +23,9 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
 using System;
 using System.Collections.Generic;
-using System.Text;
-using System.Runtime.InteropServices;
-using OpenSSL.Core;
 
 namespace OpenSSL.X509
 {
@@ -50,17 +48,20 @@
 		/// <param name="bio"></param>
 		public X509Chain(BIO bio)
 		{
-			IntPtr sk = Native.ExpectNonNull(Native.PEM_X509_INFO_read_bio(bio.Handle, IntPtr.Zero, null, IntPtr.Zero));
-			using (Core.Stack<X509CertificateInfo> stack = new Core.Stack<X509CertificateInfo>(sk, true))
+			var sk = Native.ExpectNonNull(
+				Native.PEM_X509_INFO_read_bio(bio.Handle, IntPtr.Zero, null, IntPtr.Zero)
+			);
+
+			using (var stack = new Core.Stack<X509CertificateInfo>(sk, true))
 			{
 				while (stack.Count > 0)
 				{
-					using (X509CertificateInfo xi = stack.Shift())
+					using (var xi = stack.Shift())
 					{
-						X509Certificate cert = xi.Certificate;
+						var cert = xi.Certificate;
 						if (cert != null)
 						{
-							this.Add(cert);
+							Add(cert);
 						}
 					}
 				}
@@ -86,14 +87,18 @@
 		/// <returns></returns>
 		public X509Certificate FindByIssuerAndSerial(X509Name issuer, int serial)
 		{
-			using (Asn1Integer asnInt = new Asn1Integer(serial))
+			using (var asnInt = new Asn1Integer(serial))
 			{
-				IntPtr ptr = Native.X509_find_by_issuer_and_serial(this.ptr, issuer.Handle, asnInt.Handle);
+				var ptr = Native.X509_find_by_issuer_and_serial(this.ptr, issuer.Handle, asnInt.Handle);
+
 				if (ptr == IntPtr.Zero)
 					return null;
-				X509Certificate cert = new X509Certificate(ptr, true);
+				
+				var cert = new X509Certificate(ptr, true);
+				
 				// Increase the reference count for the native pointer
 				cert.AddRef();
+				
 				return cert;
 			}
 		}
@@ -105,12 +110,16 @@
 		/// <returns></returns>
 		public X509Certificate FindBySubject(X509Name subject)
 		{
-			IntPtr ptr = Native.X509_find_by_subject(this.ptr, subject.Handle);
+			var ptr = Native.X509_find_by_subject(this.ptr, subject.Handle);
+
 			if (ptr == IntPtr.Zero)
 				return null;
-			X509Certificate cert = new X509Certificate(ptr, true);
+			
+			var cert = new X509Certificate(ptr, true);
+			
 			// Increase the reference count for the native pointer
 			cert.AddRef();
+			
 			return cert;
 		}
 		#endregion
@@ -133,16 +142,17 @@
 		/// <param name="bio"></param>
 		public X509List(BIO bio)
 		{
-			IntPtr sk = Native.ExpectNonNull(
+			var sk = Native.ExpectNonNull(
 				Native.PEM_X509_INFO_read_bio(bio.Handle, IntPtr.Zero, null, IntPtr.Zero));
-			using (Core.Stack<X509CertificateInfo> stack = new Core.Stack<X509CertificateInfo>(sk, true))
+
+			using (var stack = new Core.Stack<X509CertificateInfo>(sk, true))
 			{
 				while (stack.Count > 0)
 				{
-					using (X509CertificateInfo xi = stack.Shift())
+					using (var xi = stack.Shift())
 					{
 						if (xi.Certificate != null)
-							this.Add(xi.Certificate);
+							Add(xi.Certificate);
 					}
 				}
 			}
@@ -163,11 +173,12 @@
 		/// <param name="der"></param>
 		public X509List(byte[] der)
 		{
-			BIO bio = new BIO(der);
+			var bio = new BIO(der);
+			
 			while (bio.NumberRead < der.Length)
 			{
-				X509Certificate x509 = X509Certificate.FromDER(bio);
-				this.Add(x509);
+				var x509 = X509Certificate.FromDER(bio);
+				Add(x509);
 			}
 		}
 		#endregion
Index: ManagedOpenSsl/X509/X509Extension.cs
===================================================================
--- ManagedOpenSsl/X509/X509Extension.cs	(revision 47839)
+++ ManagedOpenSsl/X509/X509Extension.cs	(revision 47851)
@@ -23,11 +23,9 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
 using System;
 using System.Collections.Generic;
-using System.Text;
-using System.Runtime.InteropServices;
-using OpenSSL.Core;
 
 namespace OpenSSL.X509
 {
@@ -34,7 +32,7 @@
 	/// <summary>
 	/// Wraps the X509_EXTENSION object
 	/// </summary>
-	public class X509Extension : BaseValueType, IStackable
+	public class X509Extension : BaseValue, IStackable
 	{
 		#region Initialization
 
@@ -60,9 +58,9 @@
 		public X509Extension(X509Certificate issuer, X509Certificate subject, string name, bool critical, string value)
 			: base(IntPtr.Zero, true)
 		{
-			using (X509V3Context ctx = new X509V3Context(issuer, subject, null))
+			using (var ctx = new X509V3Context(issuer, subject, null))
 			{
-				this.ptr = Native.ExpectNonNull(Native.X509V3_EXT_conf_nid(IntPtr.Zero, ctx.Handle, Native.TextToNID(name), value));
+				ptr = Native.ExpectNonNull(Native.X509V3_EXT_conf_nid(IntPtr.Zero, ctx.Handle, Native.TextToNID(name), value));
 			}
 		}
 
@@ -75,7 +73,7 @@
 		/// </summary>
 		public string Name
 		{
-			get { return Native.OBJ_nid2ln(this.NID); }
+			get { return Native.StaticString(Native.OBJ_nid2ln(NID)); }
 		}
 
 		/// <summary>
@@ -86,9 +84,11 @@
 			get
 			{
 				// Don't free the obj_ptr
-				IntPtr obj_ptr = Native.X509_EXTENSION_get_object(this.ptr);
+				var obj_ptr = Native.X509_EXTENSION_get_object(ptr);
+
 				if (obj_ptr != IntPtr.Zero)
 					return Native.OBJ_obj2nid(obj_ptr);
+
 				return 0;
 			}
 		}
@@ -100,7 +100,7 @@
 		{
 			get
 			{
-				int nCritical = Native.X509_EXTENSION_get_critical(this.ptr);
+				var nCritical = Native.X509_EXTENSION_get_critical(ptr);
 				return (nCritical == 1);
 			}
 		}
@@ -112,7 +112,7 @@
 		{
 			get
 			{
-				using (Asn1String str = new Asn1String(Native.X509_EXTENSION_get_data(this.ptr), false))
+				using (var str = new Asn1String(Native.X509_EXTENSION_get_data(ptr), false))
 				{
 					return str.Data;
 				}
@@ -128,7 +128,7 @@
 		/// </summary>
 		protected override void OnDispose()
 		{
-			Native.X509_EXTENSION_free(this.ptr);
+			Native.X509_EXTENSION_free(ptr);
 		}
 
 		/// <summary>
@@ -137,7 +137,7 @@
 		/// <param name="bio"></param>
 		public override void Print(BIO bio)
 		{
-			Native.X509V3_EXT_print(bio.Handle, this.ptr, 0, 0);
+			Native.X509V3_EXT_print(bio.Handle, ptr, 0, 0);
 		}
 
 		/// <summary>
@@ -146,7 +146,7 @@
 		/// <returns></returns>
 		internal override IntPtr DuplicateHandle()
 		{
-			return Native.X509_EXTENSION_dup(this.ptr);
+			return Native.X509_EXTENSION_dup(ptr);
 		}
 
 		#endregion
@@ -191,7 +191,7 @@
 		/// </summary>
 		public string Value
 		{
-			get { return this.value; }
+			get { return value; }
 		}
 
 		#endregion
@@ -202,12 +202,4 @@
 		private string name;
 		#endregion
 	}
-
-	/// <summary>
-	/// Dictionary for X509 v3 extensions - Name, Value 
-	/// </summary>
-	public class X509V3ExtensionList : List<X509V3ExtensionValue>
-	{
-	}
-
 }
Index: ManagedOpenSsl/X509/X509Name.cs
===================================================================
--- ManagedOpenSsl/X509/X509Name.cs	(revision 47839)
+++ ManagedOpenSsl/X509/X509Name.cs	(revision 47851)
@@ -23,11 +23,10 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
+using OpenSSL.Crypto;
 using System;
-using System.Collections.Generic;
 using System.Text;
-using OpenSSL.Core;
-using OpenSSL.Crypto;
 
 namespace OpenSSL.X509
 {
@@ -34,7 +33,7 @@
 	/// <summary>
 	/// Encapsulates the X509_NAME_* functions
 	/// </summary>
-	public class X509Name : BaseValueType, IComparable<X509Name>, IStackable
+	public class X509Name : BaseValue, IComparable<X509Name>, IStackable
 	{
 		#region Initialization
 		internal X509Name(IntPtr ptr, bool owner) 
@@ -71,19 +70,21 @@
 			if (str.IndexOf('/') == -1 &&
 				str.IndexOf('=') == -1)
 			{
-				this.Common = str;
+				Common = str;
 				return;
 			}
 
-			string[] parts = str.Split('/');
-			foreach (string part in parts)
+			var parts = str.Split('/');
+			foreach (var part in parts)
 			{
 				if (part == "")
 					continue;
-				string[] nv = part.Split('=');
-				string name = nv[0];
-				string value = nv[1];
-				this.AddEntryByName(name, value);
+
+				var nv = part.Split('=');
+				var name = nv[0];
+				var value = nv[1];
+
+				AddEntryByName(name, value);
 			}
 		}
 
@@ -100,12 +101,12 @@
 
 		#region Properties
 
-        /// <summary>
+		/// <summary>
 		/// Returns X509_NAME_oneline()
 		/// </summary>
 		public string OneLine
 		{
-			get { return Native.PtrToStringAnsi(Native.X509_NAME_oneline(this.ptr, null, 0), true);	 }
+			get { return Native.PtrToStringAnsi(Native.X509_NAME_oneline(ptr, null, 0), true);	 }
 		}
 		
 		/// <summary>
@@ -113,8 +114,8 @@
 		/// </summary>
 		public string Common
 		{
-			get { return this.GetTextByName("CN"); }
-			set { this.AddEntryByName("CN", value); }
+			get { return GetTextByName("CN"); }
+			set { AddEntryByName("CN", value); }
 		}
 
 		/// <summary>
@@ -122,8 +123,8 @@
 		/// </summary>
 		public string Country
 		{
-			get { return this.GetTextByName("C"); }
-			set { this.AddEntryByName("C", value); }
+			get { return GetTextByName("C"); }
+			set { AddEntryByName("C", value); }
 		}
 
 		/// <summary>
@@ -131,8 +132,8 @@
 		/// </summary>
 		public string Locality
 		{
-			get { return this.GetTextByName("L"); }
-			set { this.AddEntryByName("L", value); }
+			get { return GetTextByName("L"); }
+			set { AddEntryByName("L", value); }
 		}
 
 		/// <summary>
@@ -140,8 +141,8 @@
 		/// </summary>
 		public string StateOrProvince
 		{
-			get { return this.GetTextByName("ST"); }
-			set { this.AddEntryByName("ST", value); }
+			get { return GetTextByName("ST"); }
+			set { AddEntryByName("ST", value); }
 		}
 
 		/// <summary>
@@ -149,8 +150,8 @@
 		/// </summary>
 		public string Organization
 		{
-			get { return this.GetTextByName("O"); }
-			set { this.AddEntryByName("O", value); }
+			get { return GetTextByName("O"); }
+			set { AddEntryByName("O", value); }
 		}
 
 		/// <summary>
@@ -158,8 +159,8 @@
 		/// </summary>
 		public string OrganizationUnit
 		{
-			get { return this.GetTextByName("OU"); }
-			set { this.AddEntryByName("OU", value); }
+			get { return GetTextByName("OU"); }
+			set { AddEntryByName("OU", value); }
 		}
 
 		/// <summary>
@@ -167,8 +168,8 @@
 		/// </summary>
 		public string Given
 		{
-			get { return this.GetTextByName("G"); }
-			set { this.AddEntryByName("G", value); }
+			get { return GetTextByName("G"); }
+			set { AddEntryByName("G", value); }
 		}
 
 		/// <summary>
@@ -176,8 +177,8 @@
 		/// </summary>
 		public string Surname
 		{
-			get { return this.GetTextByName("S"); }
-			set { this.AddEntryByName("S", value); }
+			get { return GetTextByName("S"); }
+			set { AddEntryByName("S", value); }
 		}
 
 		/// <summary>
@@ -185,8 +186,8 @@
 		/// </summary>
 		public string Initials
 		{
-			get { return this.GetTextByName("I"); }
-			set { this.AddEntryByName("I", value); }
+			get { return GetTextByName("I"); }
+			set { AddEntryByName("I", value); }
 		}
 
 		/// <summary>
@@ -194,8 +195,8 @@
 		/// </summary>
 		public string UniqueIdentifier
 		{
-			get { return this.GetTextByName("UID"); }
-			set { this.AddEntryByName("UID", value); }
+			get { return GetTextByName("UID"); }
+			set { AddEntryByName("UID", value); }
 		}
 
 		/// <summary>
@@ -203,8 +204,8 @@
 		/// </summary>
 		public string SerialNumber
 		{
-			get { return this.GetTextByName("SN"); }
-			set { this.AddEntryByName("SN", value); }
+			get { return GetTextByName("SN"); }
+			set { AddEntryByName("SN", value); }
 		}
 
 		/// <summary>
@@ -212,8 +213,8 @@
 		/// </summary>
 		public string Title
 		{
-			get { return this.GetTextByName("T"); }
-			set { this.AddEntryByName("T", value); }
+			get { return GetTextByName("T"); }
+			set { AddEntryByName("T", value); }
 		}
 
 		/// <summary>
@@ -221,8 +222,8 @@
 		/// </summary>
 		public string Description
 		{
-			get { return this.GetTextByName("D"); }
-			set { this.AddEntryByName("D", value); }
+			get { return GetTextByName("D"); }
+			set { AddEntryByName("D", value); }
 		}
 
 		/// <summary>
@@ -230,8 +231,8 @@
 		/// </summary>
 		public string X509
 		{
-			get { return this.GetTextByName("X509"); }
-			set { this.AddEntryByName("X509", value); }
+			get { return GetTextByName("X509"); }
+			set { AddEntryByName("X509", value); }
 		}
 
 		/// <summary>
@@ -239,7 +240,7 @@
 		/// </summary>
 		public int Count
 		{
-			get { return Native.X509_NAME_entry_count(this.ptr); }
+			get { return Native.X509_NAME_entry_count(ptr); }
 		}
 
 		/// <summary>
@@ -249,8 +250,8 @@
 		/// <returns></returns>
 		public string this[string name]
 		{
-			get { return this.GetTextByName(name); }
-			set { this.AddEntryByName(name, value); }
+			get { return GetTextByName(name); }
+			set { AddEntryByName(name, value); }
 		}
 
 		/// <summary>
@@ -278,7 +279,7 @@
 		/// <param name="value"></param>
 		public void AddEntryByName(string name, string value)
 		{
-			this.AddEntryByNid(Native.TextToNID(name), value);
+			AddEntryByNid(Native.TextToNID(name), value);
 		}
 
 		/// <summary>
@@ -288,9 +289,10 @@
 		/// <param name="value"></param>
 		public void AddEntryByNid(int nid, string value)
 		{
-			byte[] buf = Encoding.ASCII.GetBytes(value);
+			var buf = Encoding.ASCII.GetBytes(value);
+			
 			Native.ExpectSuccess(Native.X509_NAME_add_entry_by_NID(
-				this.ptr,
+				ptr,
 				nid,
 				Native.MBSTRING_ASC,
 				buf,
@@ -306,13 +308,15 @@
 		/// <returns></returns>
 		public string GetTextByNid(int nid)
 		{
-			if (this.GetIndexByNid(nid, -1) == -1)
+			if (GetIndexByNid(nid, -1) == -1)
 				return null;
 
-			byte[] buf = new byte[1024];
-			int len = Native.X509_NAME_get_text_by_NID(this.ptr, nid, buf, buf.Length);
+			var buf = new byte[1024];
+			var len = Native.X509_NAME_get_text_by_NID(ptr, nid, buf, buf.Length);
+
 			if (len <= 0)
 				throw new OpenSslException();
+			
 			return Encoding.ASCII.GetString(buf, 0, len);
 		}
 
@@ -324,7 +328,7 @@
 		/// <returns></returns>
 		public string GetTextByName(string name)
 		{
-			return this.GetTextByNid(Native.TextToNID(name));
+			return GetTextByNid(Native.TextToNID(name));
 		}
 
 		/// <summary>
@@ -335,11 +339,13 @@
 		/// <returns></returns>
 		public int GetIndexByNid(int nid, int lastpos)
 		{
-			int ret = Native.X509_NAME_get_index_by_NID(this.ptr, nid, lastpos);
+			var ret = Native.X509_NAME_get_index_by_NID(ptr, nid, lastpos);
+
 			if (ret == lastpos)
 				return lastpos;
 			if (ret < 0)
 				throw new OpenSslException();
+
 			return ret;
 		}
 
@@ -361,7 +367,7 @@
 		/// <returns></returns>
 		public int IndexOf(string name)
 		{
-			return this.IndexOf(name, -1);
+			return IndexOf(name, -1);
 		}
 
 		/// <summary>
@@ -371,7 +377,7 @@
 		/// <returns></returns>
 		public bool Contains(string name)
 		{
-			return this.IndexOf(name) >= 0;
+			return IndexOf(name) >= 0;
 		}
 
 		/// <summary>
@@ -382,9 +388,10 @@
 		/// <returns></returns>
 		public ArraySegment<byte> Digest(MessageDigest type, int cbSize)
 		{
-			byte[] buf = new byte[cbSize];
-			uint len = (uint)cbSize;
+			var buf = new byte[cbSize];
+			var len = (uint)cbSize;
 			Native.ExpectSuccess(Native.X509_NAME_digest(this.ptr, type.Handle, buf, ref len));
+			
 			return new ArraySegment<byte>(buf, 0, (int)len);
 		}
 
@@ -399,7 +406,8 @@
 				Native.ASN1_STRFLGS_ESC_QUOTE | 
 				Native.XN_FLAG_SEP_COMMA_PLUS | 
 				Native.XN_FLAG_FN_SN;
-			int ret = Native.X509_NAME_print_ex(bio.Handle, this.Handle, 0, flags);
+			
+			var ret = Native.X509_NAME_print_ex(bio.Handle, Handle, 0, flags);
 			if (ret <= 0)
 				throw new OpenSslException();
 		}
@@ -413,12 +421,12 @@
 		/// </summary>
 		protected override void OnDispose()
 		{
-			Native.X509_NAME_free(this.ptr);
+			Native.X509_NAME_free(ptr);
 		}
 
 		internal override IntPtr DuplicateHandle()
 		{
-			return Native.X509_NAME_dup(this.ptr);
+			return Native.X509_NAME_dup(ptr);
 		}
 
 		/// <summary>
@@ -426,11 +434,12 @@
 		/// </summary>
 		public override bool Equals(object rhs)
 		{
-			X509Name other = rhs as X509Name;
+			var other = rhs as X509Name;
+
 			if(other == null)
 				return false;
 
-			return this.CompareTo(other) == 0;
+			return CompareTo(other) == 0;
 		}
 
 		/// <summary>
@@ -452,7 +461,7 @@
 		/// <returns></returns>
 		public int CompareTo(X509Name other)
 		{
-			return Native.X509_NAME_cmp(this.ptr, other.ptr);
+			return Native.X509_NAME_cmp(ptr, other.ptr);
 		}
 
 		#endregion
Index: ManagedOpenSsl/X509/X509Object.cs
===================================================================
--- ManagedOpenSsl/X509/X509Object.cs	(revision 47839)
+++ ManagedOpenSsl/X509/X509Object.cs	(revision 47851)
@@ -23,12 +23,10 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
+using OpenSSL.Crypto;
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Runtime.InteropServices;
-using OpenSSL.Core;
-using OpenSSL.Crypto;
 
 namespace OpenSSL.X509
 {
@@ -35,7 +33,7 @@
 	/// <summary>
 	/// Wraps the X509_OBJECT: a glorified union
 	/// </summary>
-	public class X509Object : Base, IStackable
+	public class X509Object : BaseReference, IStackable
 	{
 		#region X509_OBJECT
 		const int X509_LU_RETRY = -1;
@@ -74,6 +72,7 @@
 			{
 				if (raw.type == X509_LU_X509)
 					return new X509Certificate(raw.ptr, false);
+
 				return null;
 			}
 		}
@@ -87,6 +86,7 @@
 			{
 				if (raw.type == X509_LU_PKEY)
 					return new CryptoKey(raw.ptr, false);
+
 				return null;
 			}
 		}
@@ -102,7 +102,7 @@
 		/// </summary>
 		internal override void AddRef()
 		{
-			Native.X509_OBJECT_up_ref_count(this.ptr);
+			Native.X509_OBJECT_up_ref_count(ptr);
 		}
 
 		/// <summary>
@@ -110,12 +110,12 @@
 		/// </summary>
 		protected override void OnDispose()
 		{
-			Native.X509_OBJECT_free_contents(this.ptr);
+			Native.X509_OBJECT_free_contents(ptr);
 		}
 
 		internal override void OnNewHandle(IntPtr ptr)
 		{
-			this.raw = (X509_OBJECT)Marshal.PtrToStructure(this.ptr, typeof(X509_OBJECT));
+			raw = (X509_OBJECT)Marshal.PtrToStructure(this.ptr, typeof(X509_OBJECT));
 		}
 
 		#endregion
Index: ManagedOpenSsl/X509/X509Request.cs
===================================================================
--- ManagedOpenSsl/X509/X509Request.cs	(revision 47839)
+++ ManagedOpenSsl/X509/X509Request.cs	(revision 47851)
@@ -23,12 +23,10 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
+using OpenSSL.Crypto;
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Runtime.InteropServices;
-using OpenSSL.Core;
-using OpenSSL.Crypto;
 
 namespace OpenSSL.X509
 {
@@ -38,17 +36,20 @@
 	public class X509Request : Base
 	{
 		#region Initialization
+
 		/// <summary>
 		/// Calls X509_REQ_new()
 		/// </summary>
-		public X509Request() 
+		public X509Request()
 			: base(Native.ExpectNonNull(Native.X509_REQ_new()), true)
-		{ }
-		
-		internal X509Request(IntPtr ptr, bool owner) 
-			: base(ptr, owner) 
-		{ }
+		{
+		}
 
+		internal X509Request(IntPtr ptr, bool owner)
+			: base(ptr, owner)
+		{
+		}
+
 		/// <summary>
 		/// Calls X509_REQ_new() and then initializes version, subject, and key.
 		/// </summary>
@@ -58,9 +59,9 @@
 		public X509Request(int version, X509Name subject, CryptoKey key)
 			: this()
 		{
-			this.Version = version;
-			this.Subject = subject;
-			this.PublicKey = key;
+			Version = version;
+			Subject = subject;
+			PublicKey = key;
 		}
 
 		/// <summary>
@@ -69,7 +70,8 @@
 		/// <param name="bio"></param>
 		public X509Request(BIO bio)
 			: base(Native.ExpectNonNull(Native.PEM_read_bio_X509_REQ(bio.Handle, IntPtr.Zero, null, IntPtr.Zero)), true)
-		{ }
+		{
+		}
 
 		/// <summary>
 		/// Creates a X509_REQ from a PEM formatted string.
@@ -77,26 +79,34 @@
 		/// <param name="pem"></param>
 		public X509Request(string pem)
 			: this(new BIO(pem))
-		{ }
+		{
+		}
+
 		#endregion
 
 		#region X509_REQ_INFO
+
 		[StructLayout(LayoutKind.Sequential)]
 		private struct X509_REQ_INFO
 		{
 			#region ASN1_ENCODING enc;
+
 			public IntPtr enc_enc;
 			public int enc_len;
 			public int enc_modified;
+
 			#endregion
+
 			public IntPtr version;
 			public IntPtr subject;
 			public IntPtr pubkey;
 			public IntPtr attributes;
 		}
+
 		#endregion
 
 		#region X509_REQ
+
 		[StructLayout(LayoutKind.Sequential)]
 		private struct X509_REQ
 		{
@@ -105,26 +115,28 @@
 			public IntPtr signature;
 			public int references;
 		}
+
 		#endregion
 
 		#region Properties
+
 		private X509_REQ Raw
 		{
-			get { return (X509_REQ)Marshal.PtrToStructure(this.ptr, typeof(X509_REQ)); }
+			get { return (X509_REQ)Marshal.PtrToStructure(ptr, typeof(X509_REQ)); }
 		}
 
 		private X509_REQ_INFO RawInfo
 		{
-			get { return (X509_REQ_INFO)Marshal.PtrToStructure(this.Raw.req_info, typeof(X509_REQ_INFO)); }
+			get { return (X509_REQ_INFO)Marshal.PtrToStructure(Raw.req_info, typeof(X509_REQ_INFO)); }
 		}
-		
+
 		/// <summary>
 		/// Accessor to the version field. The settor calls X509_REQ_set_version().
 		/// </summary>
 		public int Version
 		{
-			get { return Native.ASN1_INTEGER_get(this.RawInfo.version); }
-			set { Native.ExpectSuccess(Native.X509_REQ_set_version(this.ptr, value)); }
+			get { return Native.ASN1_INTEGER_get(RawInfo.version); }
+			set { Native.ExpectSuccess(Native.X509_REQ_set_version(ptr, value)); }
 		}
 
 		/// <summary>
@@ -132,8 +144,8 @@
 		/// </summary>
 		public CryptoKey PublicKey
 		{
-			get { return new CryptoKey(Native.ExpectNonNull(Native.X509_REQ_get_pubkey(this.ptr)), true); }
-			set { Native.ExpectSuccess(Native.X509_REQ_set_pubkey(this.ptr, value.Handle)); }
+			get { return new CryptoKey(Native.ExpectNonNull(Native.X509_REQ_get_pubkey(ptr)), true); }
+			set { Native.ExpectSuccess(Native.X509_REQ_set_pubkey(ptr, value.Handle)); }
 		}
 
 		/// <summary>
@@ -141,8 +153,8 @@
 		/// </summary>
 		public X509Name Subject
 		{
-			get { return new X509Name(Native.X509_NAME_dup(this.RawInfo.subject), true); }
-			set { Native.ExpectSuccess(Native.X509_REQ_set_subject_name(this.ptr, value.Handle)); }
+			get { return new X509Name(Native.X509_NAME_dup(RawInfo.subject), true); }
+			set { Native.ExpectSuccess(Native.X509_REQ_set_subject_name(ptr, value.Handle)); }
 		}
 
 		/// <summary>
@@ -152,16 +164,19 @@
 		{
 			get
 			{
-				using (BIO bio = BIO.MemoryBuffer())
+				using (var bio = BIO.MemoryBuffer())
 				{
-					this.Write(bio);
+					Write(bio);
+
 					return bio.ReadString();
 				}
 			}
 		}
+
 		#endregion
 
 		#region Methods
+
 		/// <summary>
 		/// Sign this X509Request using the supplied key and digest.
 		/// </summary>
@@ -169,7 +184,7 @@
 		/// <param name="digest"></param>
 		public void Sign(CryptoKey pkey, MessageDigest digest)
 		{
-			if (Native.X509_REQ_sign(this.ptr, pkey.Handle, digest.Handle) == 0)
+			if (Native.X509_REQ_sign(ptr, pkey.Handle, digest.Handle) == 0)
 				throw new OpenSslException();
 		}
 
@@ -180,18 +195,25 @@
 		/// <returns></returns>
 		public bool Verify(CryptoKey pkey)
 		{
-			int ret = Native.X509_REQ_verify(this.ptr, pkey.Handle);
+			int ret = Native.X509_REQ_verify(ptr, pkey.Handle);
+
 			if (ret < 0)
 				throw new OpenSslException();
+
 			return ret == 1;
 		}
 
-		//public ArraySegment<byte> Digest(IntPtr type, byte[] digest)
-		//{
-		//    uint len = (uint)digest.Length;
-		//    Native.ExpectSuccess(Native.X509_REQ_digest(this.ptr, type, digest, ref len));
-		//    return new ArraySegment<byte>(digest, 0, (int)len);
-		//}
+		/// <summary>
+		/// Digest the specified type and digest.
+		/// </summary>
+		/// <param name="type">Type.</param>
+		/// <param name="digest">Digest.</param>
+		public ArraySegment<byte> Digest(IntPtr type, byte[] digest)
+		{
+			uint len = (uint)digest.Length;
+			Native.ExpectSuccess(Native.X509_REQ_digest(this.ptr, type, digest, ref len));
+			return new ArraySegment<byte>(digest, 0, (int)len);
+		}
 
 		/// <summary>
 		/// Calls X509_REQ_print()
@@ -199,7 +221,7 @@
 		/// <param name="bio"></param>
 		public override void Print(BIO bio)
 		{
-			Native.ExpectSuccess(Native.X509_REQ_print(bio.Handle, this.ptr));
+			Native.ExpectSuccess(Native.X509_REQ_print(bio.Handle, ptr));
 		}
 
 		/// <summary>
@@ -208,7 +230,7 @@
 		/// <param name="bio"></param>
 		public void Write(BIO bio)
 		{
-			Native.ExpectSuccess(Native.PEM_write_bio_X509_REQ(bio.Handle, this.ptr));
+			Native.ExpectSuccess(Native.PEM_write_bio_X509_REQ(bio.Handle, ptr));
 		}
 
 		/// <summary>
@@ -219,8 +241,9 @@
 		/// <returns></returns>
 		public X509Certificate CreateCertificate(int days, CryptoKey pkey)
 		{
-			return new X509Certificate(Native.ExpectNonNull(Native.X509_REQ_to_X509(this.ptr, days, pkey.Handle)), true);
+			return new X509Certificate(Native.ExpectNonNull(Native.X509_REQ_to_X509(ptr, days, pkey.Handle)), true);
 		}
+
 		#endregion
 
 		#region Overrides Members
@@ -228,8 +251,9 @@
 		/// <summary>
 		/// Calls X509_REQ_free()
 		/// </summary>
-		protected override void OnDispose() {
-			Native.X509_REQ_free(this.ptr);
+		protected override void OnDispose()
+		{
+			Native.X509_REQ_free(ptr);
 		}
 
 		#endregion
Index: ManagedOpenSsl/X509/X509Store.cs
===================================================================
--- ManagedOpenSsl/X509/X509Store.cs	(revision 47839)
+++ ManagedOpenSsl/X509/X509Store.cs	(revision 47851)
@@ -23,11 +23,9 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Runtime.InteropServices;
-using OpenSSL.Core;
 
 namespace OpenSSL.X509
 {
@@ -34,31 +32,27 @@
 	/// <summary>
 	/// Wraps the X509_STORE object
 	/// </summary>
-	public class X509Store : BaseReferenceType
+	public class X509Store : BaseReferenceImpl
 	{
 		#region X509_STORE
 		[StructLayout(LayoutKind.Sequential)]
 		struct X509_STORE
 		{
-			/* The following is a cache of trusted certs */
-			public int cache; 	/* if true, stash any hits */
-			public IntPtr objs;    //STACK_OF(X509_OBJECT) *objs;	/* Cache of all objects */
-
-			/* These are external lookup methods */
-			public IntPtr get_cert_methods;    //STACK_OF(X509_LOOKUP) *get_cert_methods;
-
-			public IntPtr param;   // X509_VERIFY_PARAM* param;
-
-			/* Callbacks for various operations */
-			public IntPtr verify;  //int (*verify)(X509_STORE_CTX *ctx);	/* called to verify a certificate */
-			public IntPtr verify_cb;   //int (*verify_cb)(int ok,X509_STORE_CTX *ctx);	/* error callback */
-			public IntPtr get_issuer;  //int (*get_issuer)(X509 **issuer, X509_STORE_CTX *ctx, X509 *x);	/* get issuers cert from ctx */
-			public IntPtr check_issued;    //int (*check_issued)(X509_STORE_CTX *ctx, X509 *x, X509 *issuer); /* check issued */
-			public IntPtr check_revocation;    //int (*check_revocation)(X509_STORE_CTX *ctx); /* Check revocation status of chain */
-			public IntPtr get_crl; //int (*get_crl)(X509_STORE_CTX *ctx, X509_CRL **crl, X509 *x); /* retrieve CRL */
-			public IntPtr check_crl;   //int (*check_crl)(X509_STORE_CTX *ctx, X509_CRL *crl); /* Check CRL validity */
-			public IntPtr cert_crl;    //int (*cert_crl)(X509_STORE_CTX *ctx, X509_CRL *crl, X509 *x); /* Check certificate against CRL */
-			public IntPtr cleanup; //int (*cleanup)(X509_STORE_CTX *ctx);
+			public int cache;
+			public IntPtr objs;
+			public IntPtr get_cert_methods;
+			public IntPtr param;
+			public IntPtr verify;
+			public IntPtr verify_cb;
+			public IntPtr get_issuer;
+			public IntPtr check_issued;
+			public IntPtr check_revocation;
+			public IntPtr get_crl;
+			public IntPtr check_crl;
+			public IntPtr cert_crl;
+			public IntPtr lookup_certs;
+			public IntPtr lookup_crls;
+			public IntPtr cleanup;
 			#region CRYPTO_EX_DATA ex_data;
 			public IntPtr ex_data_sk;
 			public int ex_data_dummy;
@@ -94,7 +88,7 @@
 		{ }
 
 		/// <summary>
-		/// Calls X509_STORE_new() and then adds the specified chaing as trusted.
+		/// Calls X509_STORE_new() and then adds the specified chain as trusted.
 		/// </summary>
 		/// <param name="chain"></param>
 		/// <param name="takeOwnership"></param>
@@ -101,9 +95,9 @@
 		public X509Store(X509Chain chain, bool takeOwnership)
 			: base(Native.ExpectNonNull(Native.X509_STORE_new()), takeOwnership)
 		{
-			foreach (X509Certificate cert in chain)
+			foreach (var cert in chain)
 			{
-				this.AddTrusted(cert);
+				AddTrusted(cert);
 			}
 		}
 
@@ -118,9 +112,8 @@
 		{
 			get
 			{
-				X509_STORE raw = (X509_STORE)Marshal.PtrToStructure(this.ptr, typeof(X509_STORE));
-				Core.Stack<X509Object> stack = new Core.Stack<X509Object>(raw.objs, false);
-				return stack;
+				var raw = (X509_STORE)Marshal.PtrToStructure(ptr, typeof(X509_STORE));
+				return new Core.Stack<X509Object>(raw.objs, false);
 			}
 		}
 
@@ -129,8 +122,8 @@
 		/// </summary>
 		public X509Chain Untrusted
 		{
-			get { return this.untrusted; }
-			set { this.untrusted = value; }
+			get { return untrusted; }
+			set { untrusted = value; }
 		}
 
 		#endregion
@@ -145,16 +138,18 @@
 		/// <returns></returns>
 		public bool Verify(X509Certificate cert, out string error)
 		{
-			using (X509StoreContext ctx = new X509StoreContext())
+			using (var ctx = new X509StoreContext())
 			{
-				ctx.Init(this, cert, this.untrusted);
+				ctx.Init(this, cert, untrusted);
 				if (ctx.Verify())
 				{
 					error = "";
 					return true;
 				}
+
 				error = ctx.ErrorString;
 			}
+
 			return false;
 		}
 
@@ -164,7 +159,7 @@
 		/// <param name="chain"></param>
 		public void AddTrusted(X509Chain chain)
 		{
-			foreach (X509Certificate cert in chain)
+			foreach (var cert in chain)
 			{
 				AddTrusted(cert);
 			}
@@ -177,7 +172,7 @@
 		public void AddTrusted(X509Certificate cert)
 		{
 			// Don't Addref here -- X509_STORE_add_cert increases the refcount of the certificate pointer
-			Native.ExpectSuccess(Native.X509_STORE_add_cert(this.ptr, cert.Handle));
+			Native.ExpectSuccess(Native.X509_STORE_add_cert(ptr, cert.Handle));
 		}
 
 		/// <summary>
@@ -186,7 +181,7 @@
 		/// <param name="cert"></param>
 		public void AddUntrusted(X509Certificate cert)
 		{
-			this.untrusted.Add(cert);
+			untrusted.Add(cert);
 		}
 
 		#endregion
@@ -198,11 +193,11 @@
 		/// </summary>
 		protected override void OnDispose()
 		{
-			Native.X509_STORE_free(this.ptr);
-			if (this.untrusted != null)
+			Native.X509_STORE_free(ptr);
+			if (untrusted != null)
 			{
-				this.untrusted.Dispose();
-				this.untrusted = null;
+				untrusted.Dispose();
+				untrusted = null;
 			}
 		}
 
Index: ManagedOpenSsl/X509/X509StoreContext.cs
===================================================================
--- ManagedOpenSsl/X509/X509StoreContext.cs	(revision 47839)
+++ ManagedOpenSsl/X509/X509StoreContext.cs	(revision 47851)
@@ -23,11 +23,9 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
+using OpenSSL.Core;
 using System;
-using System.Collections.Generic;
-using System.Text;
 using System.Runtime.InteropServices;
-using OpenSSL.Core;
 
 namespace OpenSSL.X509
 {
@@ -36,61 +34,19 @@
 	/// </summary>
 	public class X509StoreContext : Base
 	{
-		#region X509_STORE_CONTEXT
-		[StructLayout(LayoutKind.Sequential)]
-		struct X509_STORE_CONTEXT
-		{
-			public IntPtr ctx;
-			public int current_method;
-			public IntPtr cert;
-			public IntPtr untrusted;
-			public int purpose;
-			public int trust;
-#if PocketPC
-            public uint check_time;
-#else
-			public long check_time;
-#endif
-			public uint flags;
-			public IntPtr other_ctx;
-			public IntPtr verify;
-			public IntPtr verify_cb;
-			public IntPtr get_issuer;
-			public IntPtr check_issued;
-			public IntPtr check_revocation;
-			public IntPtr get_crl;
-			public IntPtr check_crl;
-			public IntPtr cert_crl;
-			public IntPtr cleanup;
-			public int depth;
-			public int valid;
-			public int last_untrusted;
-			public IntPtr chain;
-			public int error_depth;
-			public int error;
-			public IntPtr current_cert;
-			public IntPtr current_issuer;
-			public IntPtr current_crl;
-			#region CRYPTO_EX_DATA ex_data;
-			public IntPtr ex_data_sk;
-			public int ex_data_dummy;
-			#endregion
-		}
-		#endregion
+		#region Initialization
 
-		#region Initialization
 		/// <summary>
 		/// Calls X509_STORE_CTX_new()
 		/// </summary>
-		public X509StoreContext()
-			: base(Native.ExpectNonNull(Native.X509_STORE_CTX_new()), true)
+		public X509StoreContext() : base(Native.ExpectNonNull(Native.X509_STORE_CTX_new()), true)
 		{
 		}
 
-		internal X509StoreContext(IntPtr ptr, bool isOwner)
-			: base(ptr, isOwner)
+		internal X509StoreContext(IntPtr ptr, bool isOwner) : base(ptr, isOwner)
 		{
 		}
+
 		#endregion
 
 		#region Properties
@@ -102,7 +58,7 @@
 		{
 			get
 			{
-				IntPtr cert = Native.X509_STORE_CTX_get_current_cert(this.ptr);
+				var cert = Native.X509_STORE_CTX_get_current_cert(ptr);
 				return new X509Certificate(cert, false);
 			}
 		}
@@ -112,7 +68,7 @@
 		/// </summary>
 		public int ErrorDepth
 		{
-			get { return Native.X509_STORE_CTX_get_error_depth(this.ptr); }
+			get { return Native.X509_STORE_CTX_get_error_depth(ptr); }
 		}
 
 		/// <summary>
@@ -120,8 +76,8 @@
 		/// </summary>
 		public int Error
 		{
-			get { return Native.X509_STORE_CTX_get_error(this.ptr); }
-			set { Native.X509_STORE_CTX_set_error(this.ptr, value); }
+			get { return Native.X509_STORE_CTX_get_error(ptr); }
+			set { Native.X509_STORE_CTX_set_error(ptr, value); }
 		}
 
 		/// <summary>
@@ -129,7 +85,7 @@
 		/// </summary>
 		public X509Store Store
 		{
-			get { return new X509Store(this.Raw.ctx, false); }
+			get { return new X509Store(Native.X509_STORE_CTX_get0_store(Handle), false); }
 		}
 
 		/// <summary>
@@ -137,16 +93,13 @@
 		/// </summary>
 		public string ErrorString
 		{
-			get { return Native.PtrToStringAnsi(Native.X509_verify_cert_error_string(this.Raw.error), false); }
+			get { return Native.PtrToStringAnsi(Native.X509_verify_cert_error_string(Error), false); }
 		}
 
-		private X509_STORE_CONTEXT Raw
-		{
-			get { return (X509_STORE_CONTEXT)Marshal.PtrToStructure(this.ptr, typeof(X509_STORE_CONTEXT)); }
-		}
 		#endregion
 
 		#region Methods
+
 		/// <summary>
 		/// Calls X509_STORE_CTX_init()
 		/// </summary>
@@ -156,7 +109,7 @@
 		public void Init(X509Store store, X509Certificate cert, X509Chain uchain)
 		{
 			Native.ExpectSuccess(Native.X509_STORE_CTX_init(
-				this.ptr,
+				ptr,
 				store.Handle,
 				cert != null ? cert.Handle : IntPtr.Zero,
 				uchain.Handle));
@@ -168,9 +121,11 @@
 		/// <returns></returns>
 		public bool Verify()
 		{
-			int ret = Native.X509_verify_cert(this.ptr);
+			var ret = Native.X509_verify_cert(ptr);
+
 			if (ret < 0)
 				throw new OpenSslException();
+
 			return ret == 1;
 		}
 
@@ -183,7 +138,7 @@
 		/// </summary>
 		protected override void OnDispose()
 		{
-			Native.X509_STORE_CTX_free(this.ptr);
+			Native.X509_STORE_CTX_free(ptr);
 		}
 
 		#endregion
Index: cli/Program.cs
===================================================================
--- cli/Program.cs	(revision 47839)
+++ cli/Program.cs	(revision 47851)
@@ -25,13 +25,10 @@
 
 using System;
 using System.Collections.Generic;
+using Alphaleonis.Win32.Filesystem;
 using System.Text;
-using OpenSSL;
-using System.IO;
-using System.Runtime.InteropServices;
 using OpenSSL.Core;
 using OpenSSL.Crypto;
-
 namespace OpenSSL.CLI
 {
 	interface ICommand
Index: cli/cli-2010.csproj
===================================================================
--- cli/cli-2010.csproj	(revision 47839)
+++ cli/cli-2010.csproj	(revision 47851)
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+﻿<?xml version="1.0" encoding="utf-8"?>
 <Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
@@ -15,7 +15,7 @@
     <OldToolsVersion>3.5</OldToolsVersion>
     <UpgradeBackupLocation>
     </UpgradeBackupLocation>
-    <TargetFrameworkVersion>v2.0</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.0</TargetFrameworkVersion>
     <PublishUrl>publish\</PublishUrl>
     <Install>true</Install>
     <InstallFrom>Disk</InstallFrom>
@@ -31,26 +31,27 @@
     <IsWebBootstrapper>false</IsWebBootstrapper>
     <UseApplicationTrust>false</UseApplicationTrust>
     <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile>Client</TargetFrameworkProfile>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
     <DebugType>full</DebugType>
     <Optimize>false</Optimize>
-    <OutputPath>..\bin\Debug\</OutputPath>
+    <OutputPath>..\bin\</OutputPath>
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
-    <PlatformTarget>x86</PlatformTarget>
+    <PlatformTarget>AnyCPU</PlatformTarget>
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
-    <OutputPath>..\bin\Release\</OutputPath>
+    <OutputPath>..\bin\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
-    <PlatformTarget>x86</PlatformTarget>
+    <PlatformTarget>AnyCPU</PlatformTarget>
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|x64' ">
@@ -78,10 +79,29 @@
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
     <WarningLevel>4</WarningLevel>
   </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>bin\x86\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
+    <OutputPath>bin\x86\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
   <ItemGroup>
+    <Reference Include="AlphaFS2">
+      <HintPath>..\..\..\..\Applications\production\MPManager3\References_Release\AlphaFS2.dll</HintPath>
+    </Reference>
     <Reference Include="System" />
-    <Reference Include="System.Data" />
-    <Reference Include="System.Xml" />
   </ItemGroup>
   <ItemGroup>
     <Compile Include="Properties\AssemblyInfo.cs" />
@@ -118,6 +138,9 @@
       <Install>true</Install>
     </BootstrapperPackage>
   </ItemGroup>
+  <ItemGroup>
+    <None Include="app.config" />
+  </ItemGroup>
   <Import Project="$(MSBuildBinPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
Index: cli/CmdCipher.cs
===================================================================
--- cli/CmdCipher.cs	(revision 47839)
+++ cli/CmdCipher.cs	(revision 47851)
@@ -1,10 +1,10 @@
 ﻿using System;
-using System.Collections.Generic;
-using System.Text;
-using System.IO;
+using System.Text;
+using Alphaleonis.Win32.Filesystem;
 using OpenSSL.Core;
 using OpenSSL.Crypto;
 
+
 namespace OpenSSL.CLI {
 	class CmdCipher : ICommand {
 		OptionParser options = new OptionParser();
Index: cli/CmdGenDH.cs
===================================================================
--- cli/CmdGenDH.cs	(revision 47839)
+++ cli/CmdGenDH.cs	(revision 47851)
@@ -23,11 +23,8 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-using System.IO;
-using OpenSSL;
+using System;
+using Alphaleonis.Win32.Filesystem;
 using OpenSSL.Crypto;
 
 namespace OpenSSL.CLI
Index: cli/CmdGenRSA.cs
===================================================================
--- cli/CmdGenRSA.cs	(revision 47839)
+++ cli/CmdGenRSA.cs	(revision 47851)
@@ -23,11 +23,8 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-using System.Runtime.InteropServices;
-using System.IO;
+using System;
+using Alphaleonis.Win32.Filesystem;
 using OpenSSL.Core;
 using OpenSSL.Crypto;
 
Index: cli/CmdRSA.cs
===================================================================
--- cli/CmdRSA.cs	(revision 47839)
+++ cli/CmdRSA.cs	(revision 47851)
@@ -23,10 +23,8 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-using System.IO;
+using System;
+using Alphaleonis.Win32.Filesystem;
 using OpenSSL.Core;
 using OpenSSL.Crypto;
 
Index: cli/CmdDH.cs
===================================================================
--- cli/CmdDH.cs	(revision 47839)
+++ cli/CmdDH.cs	(revision 47851)
@@ -23,13 +23,8 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-using System;
-using System.Collections.Generic;
-using System.Text;
-using OpenSSL;
-using System.Reflection;
-using System.Security.Permissions;
-using System.IO;
+using System;
+using System.IO;
 using OpenSSL.Core;
 using OpenSSL.Crypto;
 
Index: openssl.net-2010.sln
===================================================================
--- openssl.net-2010.sln	(revision 47839)
+++ openssl.net-2010.sln	(revision 47851)
@@ -1,6 +1,8 @@
 ﻿
-Microsoft Visual Studio Solution File, Format Version 11.00
-# Visual Studio 2010
+Microsoft Visual Studio Solution File, Format Version 12.00
+# Visual Studio 2013
+VisualStudioVersion = 12.0.40629.0
+MinimumVisualStudioVersion = 10.0.40219.1
 Project("{2150E333-8FDC-42A3-9474-1A3956D46DE8}") = "Project Files", "Project Files", "{0B96FB71-2BB0-48F8-B3E0-E3848A4F9E87}"
 	ProjectSection(SolutionItems) = preProject
 		CHANGES = CHANGES
@@ -7,10 +9,10 @@
 		COPYING = COPYING
 		INSTALL = INSTALL
 		LICENSE = LICENSE
+		Makefile = Makefile
 		README = README
 		release.cmd = release.cmd
 		TODO = TODO
-		Makefile = Makefile
 		update_web.sh = update_web.sh
 	EndProjectSection
 EndProject
@@ -28,22 +30,44 @@
 Global
 	GlobalSection(SolutionConfigurationPlatforms) = preSolution
 		Debug|Any CPU = Debug|Any CPU
+		Debug|x64 = Debug|x64
+		Debug|x86 = Debug|x86
 		Release|Any CPU = Release|Any CPU
+		Release|x64 = Release|x64
+		Release|x86 = Release|x86
 	EndGlobalSection
 	GlobalSection(ProjectConfigurationPlatforms) = postSolution
 		{73DCC218-655B-485F-8EAC-0CE5F2F7343D}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{73DCC218-655B-485F-8EAC-0CE5F2F7343D}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{73DCC218-655B-485F-8EAC-0CE5F2F7343D}.Debug|x64.ActiveCfg = Debug|x64
+		{73DCC218-655B-485F-8EAC-0CE5F2F7343D}.Debug|x64.Build.0 = Debug|x64
+		{73DCC218-655B-485F-8EAC-0CE5F2F7343D}.Debug|x86.ActiveCfg = Debug|x86
+		{73DCC218-655B-485F-8EAC-0CE5F2F7343D}.Debug|x86.Build.0 = Debug|x86
 		{73DCC218-655B-485F-8EAC-0CE5F2F7343D}.Release|Any CPU.ActiveCfg = Release|Any CPU
 		{73DCC218-655B-485F-8EAC-0CE5F2F7343D}.Release|Any CPU.Build.0 = Release|Any CPU
-		{779FA0D7-D7CB-4408-A94D-B5718F118894}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
-		{779FA0D7-D7CB-4408-A94D-B5718F118894}.Debug|Any CPU.Build.0 = Debug|Any CPU
-		{779FA0D7-D7CB-4408-A94D-B5718F118894}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{779FA0D7-D7CB-4408-A94D-B5718F118894}.Release|Any CPU.Build.0 = Release|Any CPU
+		{73DCC218-655B-485F-8EAC-0CE5F2F7343D}.Release|x64.ActiveCfg = Release|x64
+		{73DCC218-655B-485F-8EAC-0CE5F2F7343D}.Release|x64.Build.0 = Release|x64
+		{73DCC218-655B-485F-8EAC-0CE5F2F7343D}.Release|x86.ActiveCfg = Release|x86
+		{73DCC218-655B-485F-8EAC-0CE5F2F7343D}.Release|x86.Build.0 = Release|x86
 		{F50628FD-5AE4-4A16-A062-4687B2EAD7EE}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
 		{F50628FD-5AE4-4A16-A062-4687B2EAD7EE}.Debug|Any CPU.Build.0 = Debug|Any CPU
+		{F50628FD-5AE4-4A16-A062-4687B2EAD7EE}.Debug|x64.ActiveCfg = Debug|x64
+		{F50628FD-5AE4-4A16-A062-4687B2EAD7EE}.Debug|x86.ActiveCfg = Debug|x86
 		{F50628FD-5AE4-4A16-A062-4687B2EAD7EE}.Release|Any CPU.ActiveCfg = Release|Any CPU
-		{F50628FD-5AE4-4A16-A062-4687B2EAD7EE}.Release|Any CPU.Build.0 = Release|Any CPU
+		{F50628FD-5AE4-4A16-A062-4687B2EAD7EE}.Release|x64.ActiveCfg = Release|x64
+		{F50628FD-5AE4-4A16-A062-4687B2EAD7EE}.Release|x86.ActiveCfg = Release|x86
+		{779FA0D7-D7CB-4408-A94D-B5718F118894}.Debug|Any CPU.ActiveCfg = Debug|Any CPU
+		{779FA0D7-D7CB-4408-A94D-B5718F118894}.Debug|x64.ActiveCfg = Debug|x64
+		{779FA0D7-D7CB-4408-A94D-B5718F118894}.Debug|x86.ActiveCfg = Debug|x86
+		{779FA0D7-D7CB-4408-A94D-B5718F118894}.Debug|x86.Build.0 = Debug|x86
+		{779FA0D7-D7CB-4408-A94D-B5718F118894}.Release|Any CPU.ActiveCfg = Release|Any CPU
+		{779FA0D7-D7CB-4408-A94D-B5718F118894}.Release|x64.ActiveCfg = Release|x64
+		{779FA0D7-D7CB-4408-A94D-B5718F118894}.Release|x86.ActiveCfg = Release|x86
+		{779FA0D7-D7CB-4408-A94D-B5718F118894}.Release|x86.Build.0 = Release|x86
 	EndGlobalSection
+	GlobalSection(SolutionProperties) = preSolution
+		HideSolutionNode = FALSE
+	EndGlobalSection
 	GlobalSection(NestedProjects) = preSolution
 		{16576C0C-C834-416B-86B1-F89EAD9EFB8E} = {0B96FB71-2BB0-48F8-B3E0-E3848A4F9E87}
 	EndGlobalSection
@@ -50,7 +74,4 @@
 	GlobalSection(MonoDevelopProperties) = preSolution
 		StartupItem = test\UnitTests-2010.csproj
 	EndGlobalSection
-	GlobalSection(SolutionProperties) = preSolution
-		HideSolutionNode = FALSE
-	EndGlobalSection
 EndGlobal
Index: test/SourceForgeBugs.cs
===================================================================
--- test/SourceForgeBugs.cs	(revision 47839)
+++ test/SourceForgeBugs.cs	(revision 47851)
@@ -48,7 +48,7 @@
 			ArraySegment<byte> result = mb.ReadBytes(0);
 			Assert.AreEqual(0, result.Count);
 		}
-		
+
 		/// <summary>
 		/// WritePrivateKey fails with null Cipher type
 		/// </summary>
@@ -72,7 +72,7 @@
 		public void Bug3018093_1()
 		{
 			FileSerialNumber fsn = new FileSerialNumber("/does/not/exist");
-			int serial = fsn.Next();
+			fsn.Next();
 		}
 
 		/// <summary>
@@ -96,7 +96,7 @@
 			Assert.AreEqual(1, fsn2.Next());
 			Assert.AreEqual(2, fsn2.Next());
 		}
-		
+
 		[Test]
 		/// <summary>
 		/// Exception in encrypting less than 8 bytes with Blowfish_CBC
@@ -103,12 +103,35 @@
 		/// </summary>
 		public void Bug3066497()
 		{
-			CipherContext cc = new CipherContext(Cipher.Blowfish_CBC);
-			byte[] inputData = Encoding.UTF8.GetBytes("1234567");
-			byte[] key = Encoding.UTF8.GetBytes("secret!!");
-			byte[] iv = Encoding.UTF8.GetBytes("secret!!");
-			byte[] outputData = cc.Encrypt(inputData, key, iv);
+			using (var cc = new CipherContext(Cipher.Blowfish_CBC))
+			{
+				byte[] inputData = Encoding.UTF8.GetBytes("1234567");
+				byte[] key = Encoding.UTF8.GetBytes("secret!!");
+				byte[] iv = Encoding.UTF8.GetBytes("secret!!");
+				cc.Encrypt(inputData, key, iv);
+			}
 		}
+
+		/// <summary>
+		/// The BIO class, if initialized with byte[] or string, uses BIO_new_mem_buf.
+		/// http://linux.die.net/man/3/bio_new_mem_buf states 
+		/// "The supplied data is read directly from the supplied buffer: 
+		/// it is not copied first, so the supplied area of memory must be unchanged until the BIO is freed."
+		/// In the string case, the byte[] is not stored anywhere.
+		/// In the byte[] case, it is relying on the calling application to do the same.
+		/// This means that garbage collection could potentially collect the data behind the BIO.
+		/// </summary>
+		[Test]
+		public void Bug3524222()
+		{
+			byte[] pattern = { 1, 2, 3 };
+			byte[] buf = (byte[])pattern.Clone();
+			using (BIO bio = new BIO(buf))
+			{
+				buf[1] = 1;
+				Assert.AreEqual(pattern, bio.ReadBytes(3).Array);
+			}
+		}
 	}
 }
 
Index: test/TestBase.cs
===================================================================
--- test/TestBase.cs	(revision 47839)
+++ test/TestBase.cs	(revision 47851)
@@ -26,22 +26,31 @@
 using System;
 using NUnit.Framework;
 using OpenSSL.Core;
+using System.Reflection;
+using System.IO;
+using OpenSSL.X509;
 
 namespace UnitTests
 {
 	public class TestBase
-	{
+	{
 		[SetUp]
 		public virtual void Setup()
-		{
-			MemoryTracker.Start();
+		{
+			MemoryTracker.Start();
 		}
 
 		[TearDown]
 		public virtual void Teardown()
 		{
-			MemoryTracker.Finish();
-			Assert.AreEqual(0, MemoryTracker.Leaked);
+			//var errors = CryptoUtil.GetErrors();
+			//foreach (var err in errors)
+			//{
+			//	Console.WriteLine("ERROR: {0}", err);
+			//}
+
+			CollectionAssert.IsEmpty(MemoryTracker.Finish());
+//			CollectionAssert.IsEmpty(errors);
 		}
 	}
 }
Index: test/TestCryptoKey.cs
===================================================================
--- test/TestCryptoKey.cs	(revision 47839)
+++ test/TestCryptoKey.cs	(revision 47851)
@@ -23,12 +23,10 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-using System;
-using System.IO;
-using OpenSSL;
 using NUnit.Framework;
 using OpenSSL.Core;
 using OpenSSL.Crypto;
+using OpenSSL.Crypto.EC;
 
 namespace UnitTests
 {
@@ -38,82 +36,132 @@
 		[Test]
 		public void CanCreateAndDispose()
 		{
-			using (CryptoKey key = new CryptoKey())
+			using (new CryptoKey())
 			{
 			}
 		}
 
 		[Test]
-		public void CanCompare()
+		public void CanCompareRSA()
 		{
-			using (DSA dsa = new DSA(true))
+			using (var rsa = new RSA())
 			{
-				using (CryptoKey lhs = new CryptoKey(dsa))
+				rsa.GenerateKeys(1024, BigNumber.One, null, null);
+				using (var lhs = new CryptoKey(rsa))
 				{
 					Assert.AreEqual(lhs, lhs);
-					using (CryptoKey rhs = new CryptoKey(dsa))
+					using (var rhs = new CryptoKey(rsa))
 					{
 						Assert.AreEqual(lhs, rhs);
 					}
 
-					using (DSA dsa2 = new DSA(true))
+					using (var rsa2 = new RSA())
 					{
-						using (CryptoKey other = new CryptoKey(dsa2))
+						rsa2.GenerateKeys(1024, BigNumber.One, null, null);
+						using (var other = new CryptoKey(rsa2))
 						{
-							Assert.IsFalse(lhs == other);
+							Assert.AreNotEqual(lhs, other);
 						}
 					}
 				}
 			}
+		}
 
-			using (RSA rsa = new RSA())
+		[Test]
+		public void CanCompareDSA()
+		{
+			using (var dsa = new DSA(true))
+			using (var lhs = new CryptoKey(dsa))
 			{
-				rsa.GenerateKeys(1024, BigNumber.One, null, null);
-				using (CryptoKey lhs = new CryptoKey(rsa))
+				Assert.AreEqual(lhs, lhs);
+				using (var rhs = new CryptoKey(dsa))
 				{
+					Assert.AreEqual(lhs, rhs);
+				}
+
+				using (var dsa2 = new DSA(true))
+				using (var other = new CryptoKey(dsa2))
+				{
+					Assert.AreNotEqual(lhs, other);
+				}
+			}
+		}
+
+		[Test]
+		public void CanCompareDH()
+		{
+			using (var dh = new DH())
+			{
+				dh.GenerateKeys();
+
+				using (var lhs = new CryptoKey(dh))
+				{
 					Assert.AreEqual(lhs, lhs);
-					using (CryptoKey rhs = new CryptoKey(rsa))
+					using (var rhs = new CryptoKey(dh))
 					{
 						Assert.AreEqual(lhs, rhs);
 					}
 
-					using (RSA rsa2 = new RSA())
+					using (var dh2 = new DH(1, 5))
 					{
-						rsa2.GenerateKeys(1024, BigNumber.One, null, null);
-						using (CryptoKey other = new CryptoKey(rsa2))
+						dh2.GenerateKeys();
+						using (var other = new CryptoKey(dh2))
 						{
-							Assert.IsFalse(lhs == other);
+							Assert.AreNotEqual(lhs, other);
 						}
 					}
 				}
 			}
 		}
-	
+
 		[Test]
-		[Ignore("Not implemented yet")]
-		public void CanCreateFromPublicKey()
+		public void CanCompareEC()
 		{
-		}
+			using (var ec = Key.FromCurveName(Objects.NID.X9_62_prime256v1))
+			{
+				ec.GenerateKey();
 
-		[Test]
-		[Ignore("Not implemented yet")]
-		public void CanCreateFromPrivateKey()
-		{
+				using (var lhs = new CryptoKey(ec))
+				{
+					Assert.AreEqual(lhs, lhs);
+					using (var rhs = new CryptoKey(ec))
+					{
+						Assert.AreEqual(lhs, rhs);
+					}
+
+					using (var ec2 = Key.FromCurveName(Objects.NID.X9_62_prime256v1))
+					{
+						ec2.GenerateKey();
+
+						using (var other = new CryptoKey(ec2))
+						{
+							Assert.AreNotEqual(lhs, other);
+						}
+					}
+				}
+			}
 		}
 
 		[Test]
 		public void CanCreateFromDSA()
 		{
-			using (DSA dsa = new DSA(true))
+			using (var dsa = new DSA(true))
 			{
-				using (CryptoKey key = new CryptoKey(dsa))
+				using (var key = new CryptoKey(dsa))
 				{
 					Assert.AreEqual(CryptoKey.KeyType.DSA, key.Type);
 					Assert.AreEqual(dsa.Size, key.Size);
+					Assert.AreEqual(dsa.Handle, key.GetDSA().Handle);
 				}
+
+				using (var key = new CryptoKey())
+				{
+					key.Assign(dsa);
+					Assert.AreEqual(dsa.Handle, key.GetDSA().Handle);
+				}
 			}
 
-			using (CryptoKey key = new CryptoKey(new DSA(false)))
+			using (var key = new CryptoKey(new DSA(false)))
 			{
 				Assert.AreEqual(CryptoKey.KeyType.DSA, key.Type);
 			}
@@ -122,37 +170,84 @@
 		[Test]
 		public void CanCreateFromRSA()
 		{
-			using (RSA rsa = new RSA())
+			using (var rsa = new RSA())
 			{
 				rsa.GenerateKeys(1024, BigNumber.One, null, null);
-				using (CryptoKey key = new CryptoKey(rsa))
+				using (var key = new CryptoKey(rsa))
 				{
 					Assert.AreEqual(CryptoKey.KeyType.RSA, key.Type);
 					Assert.AreEqual(rsa.Size, key.Size);
+					Assert.AreEqual(rsa.Handle, key.GetRSA().Handle);
 				}
+
+				using (var key = new CryptoKey())
+				{
+					key.Assign(rsa);
+					Assert.AreEqual(rsa.Handle, key.GetRSA().Handle);
+				}
 			}
 		}
 
 		[Test]
+		public void CanCreateFromEC()
+		{
+			using (var ec = new Key())
+			{
+				using (var group = Group.FromCurveName(Objects.NID.X9_62_prime256v1))
+				{
+					ec.Group = group;
+				}
+				ec.GenerateKey();
+				using (var key = new CryptoKey(ec))
+				{
+					Assert.AreEqual(CryptoKey.KeyType.EC, key.Type);
+					Assert.AreEqual(ec.Size, key.Size);
+					Assert.AreEqual(ec.Handle, key.GetEC().Handle);
+				}
+
+				using (var key = new CryptoKey())
+				{
+					key.Assign(ec);
+					Assert.AreEqual(ec.Handle, key.GetEC().Handle);
+				}
+			}
+		}
+
+		[Test]
 		public void CanCreateFromDH()
 		{
-			using (DH dh = new DH())
+			using (var dh = new DH())
 			{
 				dh.GenerateKeys();
-				using (CryptoKey key = new CryptoKey(dh)) {
+
+				using (var key = new CryptoKey(dh))
+				{
 					Assert.AreEqual(CryptoKey.KeyType.DH, key.Type);
+					Assert.AreEqual(dh.Handle, key.GetDH().Handle);
 				}
+
+				using (var key = new CryptoKey())
+				{
+					key.Assign(dh);
+					Assert.AreEqual(dh.Handle, key.GetDH().Handle);
+				}
 			}
 		}
 
 		[Test]
 		[Ignore("Not implemented yet")]
-		public void CanAssign()
+		public void CanCreateFromPublicKey()
 		{
 		}
 
 		[Test]
 		[Ignore("Not implemented yet")]
+		public void CanCreateFromPrivateKey()
+		{
+		}
+
+		[Test]
+		[Ignore("Not implemented yet")]
 		public void CanWritePrivateKey()
 		{
 		}
Index: test/TestECDSA.cs
===================================================================
--- test/TestECDSA.cs	(revision 47839)
+++ test/TestECDSA.cs	(revision 47851)
@@ -23,14 +23,13 @@
 // (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE OF
 // THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
 
-using System;
 using NUnit.Framework;
 using OpenSSL.Core;
-using Random = OpenSSL.Core.Random;
-using System.Runtime.InteropServices;
 using OpenSSL.Crypto;
+using OpenSSL.Crypto.EC;
+using System;
 using System.Text;
-using OpenSSL.Crypto.EC;
+using Random = OpenSSL.Core.Random;
 
 namespace UnitTests
 {
@@ -37,18 +36,22 @@
 	[TestFixture]
 	public class TestECDSA : TestBase
 	{
-		private void x9_62_test_internal(Asn1Object obj, string r_in, string s_in) {
+		private void x9_62_test_internal(Asn1Object obj, string r_in, string s_in)
+		{
 			byte[] message = Encoding.ASCII.GetBytes("abc");
 			
-			using(MessageDigestContext md_ctx = new MessageDigestContext(MessageDigest.ECDSA)) {
+			using (MessageDigestContext md_ctx = new MessageDigestContext(MessageDigest.ECDSA))
+			{
 				byte[] digest = md_ctx.Digest(message);
 				
 				Console.Write("testing {0}: ", obj.ShortName);
 	
-				using(Key key = Key.FromCurveName(obj)) {
+				using (Key key = Key.FromCurveName(obj))
+				{
 					key.GenerateKey();
 					Console.Write(".");
-					using(DSASignature signature = key.Sign(digest)) {
+					using (DSASignature signature = key.Sign(digest))
+					{
 						Console.Write(".");
 						BigNumber r = BigNumber.FromDecimalString(r_in);
 						BigNumber s = BigNumber.FromDecimalString(s_in);
@@ -62,29 +65,31 @@
 			}
 			Console.WriteLine(" ok");
 		}
-		
+
 		[Test]
-		public void x9_62_tests() {
+		public void x9_62_tests()
+		{
 			Random.Seed("string to make the random number generator think it has entropy");
 
 			Console.WriteLine("some tests from X9.62");
 			
 			x9_62_test_internal(Objects.NID.X9_62_prime192v1, 
-			                    "3342403536405981729393488334694600415596881826869351677613", 
-			                    "5735822328888155254683894997897571951568553642892029982342");
+				"3342403536405981729393488334694600415596881826869351677613", 
+				"5735822328888155254683894997897571951568553642892029982342");
 			x9_62_test_internal(Objects.NID.X9_62_prime239v1, 
-			                    "308636143175167811492622547300668018854959378758531778147462058306432176", 
-			                    "323813553209797357708078776831250505931891051755007842781978505179448783");
+				"308636143175167811492622547300668018854959378758531778147462058306432176", 
+				"323813553209797357708078776831250505931891051755007842781978505179448783");
 			x9_62_test_internal(Objects.NID.X9_62_c2tnb191v1, 
-			                    "87194383164871543355722284926904419997237591535066528048", 
-			                    "308992691965804947361541664549085895292153777025772063598");
+				"87194383164871543355722284926904419997237591535066528048", 
+				"308992691965804947361541664549085895292153777025772063598");
 			x9_62_test_internal(Objects.NID.X9_62_c2tnb239v1, 
-			                    "21596333210419611985018340039034612628818151486841789642455876922391552", 
-			                    "197030374000731686738334997654997227052849804072198819102649413465737174");
+				"21596333210419611985018340039034612628818151486841789642455876922391552", 
+				"197030374000731686738334997654997227052849804072198819102649413465737174");
 		}
 
 		[Test]
-		public void test_builtin() {
+		public void test_builtin()
+		{
 			/* fill digest values with some random data */
 			byte[] digest = Random.PseudoBytes(20);
 			byte[] wrong_digest = Random.PseudoBytes(20);
@@ -97,18 +102,22 @@
 			BuiltinCurve[] curves = BuiltinCurve.Get();
 			
 			/* now create and verify a signature for every curve */
-			foreach (BuiltinCurve curve in curves) {
+			foreach (BuiltinCurve curve in curves)
+			{
 				if (curve.Object.NID == Objects.NID.ipsec4.NID)
 					continue;
 				
 				/* create new ecdsa key (== EC_KEY) */
-				using(Key eckey = new Key()) {
+				using (Key eckey = new Key())
+				{
 
-					using(Group group = Group.FromCurveName(curve.Object)) {
+					using (Group group = Group.FromCurveName(curve.Object))
+					{
 						eckey.Group = group;
 					}
 					
-					if (eckey.Group.Degree < 160) {
+					if (eckey.Group.Degree < 160)
+					{
 						/* drop the curve */ 
 						continue;
 					}
@@ -119,8 +128,10 @@
 					eckey.GenerateKey();
 					
 					/* create second key */
-					using(Key wrong_eckey = new Key()) {
-						using(Group group = Group.FromCurveName(curve.Object)) {
+					using (Key wrong_eckey = new Key())
+					{
+						using (Group group = Group.FromCurveName(curve.Object))
+						{
 							wrong_eckey.Group = group;
 						}
 						
@@ -133,11 +144,13 @@
 						
 						/* create signature */
 						byte[] signature = new byte[eckey.Size];
-						eckey.Sign(0, digest, signature);
+						var sigSize = eckey.Sign(0, digest, signature);
+						Array.Resize(ref signature, (int)sigSize);
 						Console.Write(".");
 						
 						/* verify signature */
-						Assert.IsTrue(eckey.Verify(0, digest, signature));
+						var verifyResult = eckey.Verify(0, digest, signature);
+						Assert.IsTrue(verifyResult);
 						Console.Write(".");
 						
 						/* verify signature with the wrong key */
@@ -155,4 +168,3 @@
 		}
 	}
 }
-
Index: test/TestRSA.cs
===================================================================
--- test/TestRSA.cs	(revision 47839)
+++ test/TestRSA.cs	(revision 47851)
@@ -255,7 +255,8 @@
 		private void TestKey(int v, RSA key)
 		{
 			byte[] ctext_ex = null;
-			switch (v % 3) {
+			switch (v % 3)
+			{
 				case 0: ctext_ex = Key1(key); break;
 				case 1: ctext_ex = Key2(key); break;
 				case 2: ctext_ex = Key3(key); break;
@@ -292,18 +293,22 @@
 			Assert.AreEqual(str2, str1);
 
 			Console.WriteLine("OAEP encryption/decryption ok!", v);
-			for (int n = 0; n < ctext.Length; ++n) {
+			for (int n = 0; n < ctext.Length; ++n)
+			{
 				byte saved = ctext[n];
-				for (byte b = 0; b < byte.MaxValue; ++b) {
+				for (byte b = 0; b < byte.MaxValue; ++b)
+				{
 					if (b == saved)
 						continue;
 
 					ctext[n] = b;
 					bool error = false;
-					try {
+					try
+					{
 						ptext = key.PrivateDecrypt(ctext, RSA.Padding.OAEP);
 					}
-					catch (Exception) {
+					catch (Exception)
+					{
 						error = true;
 					}
 					Assert.IsTrue(error, "Corrupt data decrypted!");
@@ -312,14 +317,19 @@
 		}
 
 		[Test]
-		public void TestCase()
+		[TestCase(0)]
+		[TestCase(1)]
+		[TestCase(2)]
+		[TestCase(3)]
+		[TestCase(4)]
+		[TestCase(5)]
+		public void TestCase(int v)
 		{
 			OpenSSL.Core.Random.Seed(rnd_seed);
 
-			for (int v = 0; v < 6; v++) {
-				using (RSA key = new RSA()) {
-					TestKey(v, key);
-				}
+			using (RSA key = new RSA())
+			{
+				TestKey(v, key);
 			}
 		}
 	}
Index: test/TestRandom.cs
===================================================================
--- test/TestRandom.cs	(revision 47839)
+++ test/TestRandom.cs	(revision 47851)
@@ -34,7 +34,6 @@
 		public void TestCase()
 		{
 			Console.WriteLine("Testing random");
-			int err = 0;
 
 			byte[] buf = OpenSSL.Core.Random.PseudoBytes(2500);
 
Index: test/TestX509.cs
===================================================================
--- test/TestX509.cs	(revision 47839)
+++ test/TestX509.cs	(revision 47851)
@@ -39,88 +39,109 @@
 	public class TestX509 : TestBase
 	{
 		[Test]
-		public void TestDefaultDSA() {
-			using (Configuration cfg = new Configuration("openssl.cnf")) {
+		public void TestDefaultDSA()
+		{
+			using (var cfg = new Configuration("openssl.cnf"))
+			{
 				// Test default DSA method
-				using (X509CertificateAuthority root = X509CertificateAuthority.SelfSigned(
-					cfg,
-					new SimpleSerialNumber(),
-					"Root1",
-					DateTime.Now,
-					TimeSpan.FromDays(365))) {
+				using (var root = X509CertificateAuthority.SelfSigned(
+					                  cfg,
+					                  new SimpleSerialNumber(),
+					                  "Root1",
+					                  DateTime.Now,
+					                  TimeSpan.FromDays(365)))
+				{
 					Console.WriteLine(root.Certificate);
 				}
 			}
 		}
-		
+
 		[Test]
-		public void TestRsaSha1() {
-			using (Configuration cfg = new Configuration("openssl.cnf")) {
+		public void TestRsaSha1()
+		{
+			using (Configuration cfg = new Configuration("openssl.cnf"))
+			{
 				// Test RSA/SHA1 with other SelfSigned method
 				BigNumber bn = 0x10001;
 				CryptoKey key;
-				using(RSA rsa = new RSA())
+
+				using (RSA rsa = new RSA())
 				{
 					rsa.GenerateKeys(2048, bn, OnGenerator, null);
 					key = new CryptoKey(rsa);
 					// rsa is assigned, we no longer need this instance
 				}
-				using (X509CertificateAuthority root = X509CertificateAuthority.SelfSigned(
-					cfg,
-					new SimpleSerialNumber(),
-					key,
-					MessageDigest.SHA1,
-					"Root1",
-					DateTime.Now,
-					TimeSpan.FromDays(365))) {
+
+				using (var root = X509CertificateAuthority.SelfSigned(
+					                  cfg,
+					                  new SimpleSerialNumber(),
+					                  key,
+					                  MessageDigest.SHA1,
+					                  "Root1",
+					                  DateTime.Now,
+					                  TimeSpan.FromDays(365)))
+				{
 					Console.WriteLine(root.Certificate);
 				}
 			}
 		}
-		
+
 		[Test]
-		public void TestWithoutCfg() {
+		public void TestWithoutCfg()
+		{
 			BigNumber bn = 0x10001;
 			CryptoKey key;
-			using (RSA rsa = new RSA()) {
+			using (RSA rsa = new RSA())
+			{
 				rsa.GenerateKeys(2048, bn, OnGenerator, null);
 				key = new CryptoKey(rsa);
 				// rsa is assigned, we no longer need this instance
 			}
 
-			X509V3ExtensionList extList = new X509V3ExtensionList();
-			extList.Add(new X509V3ExtensionValue("subjectKeyIdentifier", false, "hash"));
-			extList.Add(new X509V3ExtensionValue("authorityKeyIdentifier", false, "keyid:always,issuer:always"));
-			extList.Add(new X509V3ExtensionValue("basicConstraints", true, "critical,CA:true"));
-			extList.Add(new X509V3ExtensionValue("keyUsage", false, "cRLSign,keyCertSign"));
+			var extList = new List<X509V3ExtensionValue> {
+				new X509V3ExtensionValue("subjectKeyIdentifier", false, "hash"),
+				new X509V3ExtensionValue("authorityKeyIdentifier", false, "keyid:always,issuer:always"),
+				new X509V3ExtensionValue("basicConstraints", true, "critical,CA:true"),
+				new X509V3ExtensionValue("keyUsage", false, "cRLSign,keyCertSign"),
+			};
 
-			using (X509CertificateAuthority root = X509CertificateAuthority.SelfSigned(
-				new SimpleSerialNumber(),
-				key,
-				MessageDigest.SHA1,
-				"Root1",
-				DateTime.Now,
-				TimeSpan.FromDays(365),
-				extList)) {
+			using (var root = X509CertificateAuthority.SelfSigned(
+				                  new SimpleSerialNumber(),
+				                  key,
+				                  MessageDigest.SHA1,
+				                  "Root1",
+				                  DateTime.Now,
+				                  TimeSpan.FromDays(365),
+				                  extList))
+			{
 				Console.WriteLine(root.Certificate);
 				// Iterate the extensions
 				Console.WriteLine("X509v3 Extensions:");
-				using (OpenSSL.Core.Stack<X509Extension> ext_stack = root.Certificate.Extensions) {
-					foreach (X509Extension ext in ext_stack) {
-						Console.WriteLine("Name:{0}, IsCritical:{1}, Value:{2}", ext.Name, ext.IsCritical, ext);
-					}
+				foreach (var ext in root.Certificate.Extensions)
+				{
+					Console.WriteLine("Name:{0}, IsCritical:{1}, Value:{2}", ext.Name, ext.IsCritical, ext);
 				}
 			}
 		}
 
-		private static int OnGenerator(int p, int n, object arg) {
+		private static int OnGenerator(int p, int n, object arg)
+		{
 			TextWriter cout = Console.Error;
 
-			switch (p) {
-				case 0: cout.Write('.'); break;
-				case 1: cout.Write('+'); break;
-				case 2: cout.Write('*'); break;
-				case 3: cout.WriteLine(); break;
+			switch (p)
+			{
+			case 0:
+				cout.Write('.');
+				break;
+			case 1:
+				cout.Write('+');
+				break;
+			case 2:
+				cout.Write('*');
+				break;
+			case 3:
+				cout.WriteLine();
+				break;
 			}
 
 			return 1;
Index: test/TestX509Certificate.cs
===================================================================
--- test/TestX509Certificate.cs	(revision 47839)
+++ test/TestX509Certificate.cs	(revision 47851)
@@ -32,6 +32,7 @@
 using OpenSSL.X509;
 using System.Resources;
 using System.Reflection;
+using System.Collections.Generic;
 
 namespace UnitTests
 {
@@ -41,7 +42,8 @@
 		[Test]
 		public void CanCreateAndDispose()
 		{
-			using (X509Certificate cert = new X509Certificate()) {
+			using (var cert = new X509Certificate())
+			{
 				cert.PrintRefCount();
 			}
 		}
@@ -49,8 +51,10 @@
 		[Test]
 		public void CanLoadFromPEM()
 		{
-			using (BIO bio = new BIO(LoadString(Resources.CaCrt))) {
-				using (X509Certificate cert = new X509Certificate(bio)) {
+			using (var bio = new BIO(Util.LoadString(Resources.CaCrt)))
+			{
+				using (var cert = new X509Certificate(bio))
+				{
 					TestCert(cert, "CN=Root", "CN=Root", 1234);
 				}
 			}
@@ -59,8 +63,10 @@
 		[Test]
 		public void CanLoadFromDER()
 		{
-			using (BIO bio = new BIO(LoadBytes(Resources.CaDer))) {
-				using (X509Certificate cert = X509Certificate.FromDER(bio)) {
+			using (var bio = new BIO(Util.LoadBytes(Resources.CaDer)))
+			{
+				using (var cert = X509Certificate.FromDER(bio))
+				{
 					TestCert(cert, "CN=Root", "CN=Root", 1234);
 				}
 			}
@@ -69,8 +75,10 @@
 		[Test]
 		public void CanLoadFromPKCS7_PEM()
 		{
-			using (BIO bio = new BIO(LoadString(Resources.CaChainP7cPem))) {
-				using (X509Certificate cert = X509Certificate.FromPKCS7_PEM(bio)) {
+			using (var bio = new BIO(Util.LoadString(Resources.CaChainP7cPem)))
+			{
+				using (var cert = X509Certificate.FromPKCS7_PEM(bio))
+				{
 					TestCert(cert, "CN=Root", "CN=Root", 1234);
 				}
 			}
@@ -79,8 +87,10 @@
 		[Test]
 		public void CanLoadFromPKCS7_DER()
 		{
-			using (BIO bio = new BIO(LoadBytes(Resources.CaChainP7c))) {
-				using (X509Certificate cert = X509Certificate.FromPKCS7_DER(bio)) {
+			using (var bio = new BIO(Util.LoadBytes(Resources.CaChainP7c)))
+			{
+				using (var cert = X509Certificate.FromPKCS7_DER(bio))
+				{
 					TestCert(cert, "CN=Root", "CN=Root", 1234);
 				}
 			}
@@ -89,21 +99,23 @@
 		[Test]
 		public void CanLoadFromPCKS12()
 		{
-			using (BIO bio = new BIO(LoadBytes(Resources.ServerPfx))) {
-				using (X509Certificate cert = X509Certificate.FromPKCS12(bio, password)) {
-					TestCert(cert, "CN=localhost", "CN=Root", 1235);
-				}
+			using (var cert = Util.LoadPKCS12Certificate(Resources.ServerPfx, Resources.Password))
+			{
+				TestCert(cert, "CN=localhost", "CN=Root", 1235);
 			}
 		}
 
 		[Test]
-		public void CanCreatePKCS12() {
-			using (BIO bio = new BIO(LoadBytes(Resources.ServerPfx))) {
-				using (var pfx = new PKCS12(bio, password)) {
-					using (var new_pfx = new PKCS12(password, pfx.PrivateKey, pfx.Certificate, pfx.CACertificates)) {
-						TestCert(new_pfx.Certificate, "CN=localhost", "CN=Root", 1235);
-					}
-				}
+		public void CanCreatePKCS12()
+		{
+			using (var bio = new BIO(Util.LoadBytes(Resources.ServerPfx)))
+			using (var pfx = new PKCS12(bio, Resources.Password))
+			using (var new_pfx = new PKCS12(Resources.Password,
+									   pfx.Certificate.PrivateKey,
+									   pfx.Certificate,
+									   pfx.CACertificates))
+			{
+				TestCert(new_pfx.Certificate, "CN=localhost", "CN=Root", 1235);
 			}
 		}
 
@@ -110,15 +122,14 @@
 		[Test]
 		public void CanCreateWithArgs()
 		{
-			int serial = 101;
-			X509Name subject = new X509Name("CN=localhost");
-			X509Name issuer = new X509Name("CN=Root");
-
-			CryptoKey key = new CryptoKey(new DSA(true));
-			DateTime start = DateTime.Now;
-			DateTime end = start + TimeSpan.FromMinutes(10);
-
-			using (X509Certificate cert = new X509Certificate(serial, subject, issuer, key, start, end)) {
+			var serial = 101;
+			var start = DateTime.Now;
+			var end = start + TimeSpan.FromMinutes(10);
+			using (var subject = new X509Name("CN=localhost"))
+			using (var issuer = new X509Name("CN=Root"))
+			using (var key = new CryptoKey(new DSA(true)))
+			using (var cert = new X509Certificate(serial, subject, issuer, key, start, end))
+			{
 				Assert.AreEqual(subject, cert.Subject);
 				Assert.AreEqual(issuer, cert.Issuer);
 				Assert.AreEqual(serial, cert.SerialNumber);
@@ -132,20 +143,21 @@
 		[Test]
 		public void CanGetAndSetProperties()
 		{
-			int serial = 101;
-			X509Name subject = new X509Name("CN=localhost");
-			X509Name issuer = new X509Name("CN=Root");
-			DateTime start = DateTime.Now;
-			DateTime end = start + TimeSpan.FromMinutes(10);
+			var serial = 101;
+			var subject = new X509Name("CN=localhost");
+			var issuer = new X509Name("CN=Root");
+			var start = DateTime.Now;
+			var end = start + TimeSpan.FromMinutes(10);
 
-			CryptoKey key = new CryptoKey(new DSA(true));
-			int bits = key.Bits;
+			var key = new CryptoKey(new DSA(true));
+			var bits = key.Bits;
 
 			X509Name saveIssuer = null;
 			X509Name saveSubject = null;
 			CryptoKey savePublicKey = null;
 			CryptoKey savePrivateKey = null;
-			using (X509Certificate cert = new X509Certificate()) {
+			using (var cert = new X509Certificate())
+			{
 				cert.Subject = subject;
 				cert.Issuer = issuer;
 				cert.SerialNumber = serial;
@@ -180,10 +192,24 @@
 			}
 
 			// make sure that a property torn-off from the cert is still valid
-			Assert.AreEqual(subject, saveSubject);
-			Assert.AreEqual(issuer, saveIssuer);
-			Assert.AreEqual(bits, savePublicKey.Bits);
-			Assert.AreEqual(bits, savePrivateKey.Bits);
+			using (subject)
+			using (saveSubject)
+			{
+				Assert.AreEqual(subject, saveSubject);
+			}
+			using (issuer)
+			using (saveIssuer)
+			{
+				Assert.AreEqual(issuer, saveIssuer);
+			}
+			using (savePublicKey)
+			{
+				Assert.AreEqual(bits, savePublicKey.Bits);
+			}
+			using (savePrivateKey)
+			{
+				Assert.AreEqual(bits, savePrivateKey.Bits);
+			}
 		}
 
 		[Test]
@@ -190,11 +216,12 @@
 		[ExpectedException(typeof(ArgumentException))]
 		public void CannotSetUnmatchedPrivateKey()
 		{
-			DateTime start = DateTime.Now;
-			DateTime end = start + TimeSpan.FromMinutes(10);
-			CryptoKey key = new CryptoKey(new DSA(true));
-			using (X509Certificate cert = new X509Certificate(101, "CN=localhost", "CN=Root", key, start, end)) {
-				CryptoKey other = new CryptoKey(new DSA(true));
+			var start = DateTime.Now;
+			var end = start + TimeSpan.FromMinutes(10);
+			using (var key = new CryptoKey(new DSA(true)))
+			using (var cert = new X509Certificate(101, "CN=localhost", "CN=Root", key, start, end))
+			{
+				var other = new CryptoKey(new DSA(true));
 				cert.PrivateKey = other;
 			}
 		}
@@ -202,26 +229,31 @@
 		[Test]
 		public void CanCompare()
 		{
-			DateTime start = DateTime.Now;
-			DateTime end = start + TimeSpan.FromMinutes(10);
-			CryptoKey key = new CryptoKey(new DSA(true));
-			using (X509Certificate cert = new X509Certificate(101, "CN=localhost", "CN=Root", key, start, end)) {
+			var start = DateTime.Now;
+			var end = start + TimeSpan.FromMinutes(10);
+			using (var key = new CryptoKey(new DSA(true)))
+			using (var cert = new X509Certificate(101, "CN=localhost", "CN=Root", key, start, end))
+			{
 				Assert.AreEqual(cert, cert);
-				using (X509Certificate cert2 = new X509Certificate(101, "CN=localhost", "CN=Root", key, start, end)) {
+				using (var cert2 = new X509Certificate(101, "CN=localhost", "CN=Root", key, start, end))
+				{
 					Assert.AreEqual(cert, cert2);
 				}
 
-				using (X509Certificate cert2 = new X509Certificate(101, "CN=other", "CN=Root", key, start, end)) {
-					Assert.IsFalse(cert == cert2);
+				using (var cert2 = new X509Certificate(101, "CN=other", "CN=Root", key, start, end))
+				{
+					Assert.AreNotEqual(cert, cert2);
 				}
 
-				using (X509Certificate cert2 = new X509Certificate(101, "CN=localhost", "CN=other", key, start, end)) {
-					Assert.IsFalse(cert == cert2);
+				using (var cert2 = new X509Certificate(101, "CN=localhost", "CN=other", key, start, end))
+				{
+					Assert.AreNotEqual(cert, cert2);
 				}
 
-				CryptoKey otherKey = new CryptoKey(new DSA(true));
-				using (X509Certificate cert2 = new X509Certificate(101, "CN=localhost", "CN=Root", otherKey, start, end)) {
-					Assert.IsFalse(cert == cert2);
+				using (var otherKey = new CryptoKey(new DSA(true)))
+				using (var cert2 = new X509Certificate(101, "CN=localhost", "CN=Root", otherKey, start, end))
+				{
+					Assert.AreNotEqual(cert, cert2);
 				}
 			}
 		}
@@ -229,28 +261,30 @@
 		[Test]
 		public void CanGetAsPEM()
 		{
-			string data = LoadString(Resources.CaCrt);
-			using (BIO bio = new BIO(data)) {
-				string expected = data.Replace("\r\n", "\n");
-				using (X509Certificate cert = new X509Certificate(bio)) {
-					string pem = cert.PEM;
-					string text = cert.ToString();
+			var data = Util.LoadString(Resources.CaCrt);
+			var expected = data.Replace("\r\n", "\n");
+			using (var bio = new BIO(data))
+			using (var cert = new X509Certificate(bio))
+			{
+				var pem = cert.PEM;
+				var text = cert.ToString();
 
-					Assert.AreEqual(expected, text + pem);
-				}
+				Assert.AreEqual(expected, text + pem);
 			}
 		}
 
 		[Test]
-		public void CanSaveAsDER() {
-			byte[] data = LoadBytes(Resources.CaDer);
-			using (BIO bio = new BIO(data)) {
-				using (var cert = X509Certificate.FromDER(bio)) {
-					byte[] der = cert.DER;
-					Assert.AreEqual(data.Length, der.Length);
-					for (int i = 0; i < data.Length; i++) {
-						Assert.AreEqual(data[i], der[i]);
-					}
+		public void CanSaveAsDER()
+		{
+			var data = Util.LoadBytes(Resources.CaDer);
+			using (var bio = new BIO(data))
+			using (var cert = X509Certificate.FromDER(bio))
+			{
+				var der = cert.DER;
+				Assert.AreEqual(data.Length, der.Length);
+				for (var i = 0; i < data.Length; i++)
+				{
+					Assert.AreEqual(data[i], der[i]);
 				}
 			}
 		}
@@ -258,10 +292,11 @@
 		[Test]
 		public void CanSign()
 		{
-			DateTime start = DateTime.Now;
-			DateTime end = start + TimeSpan.FromMinutes(10);
-			CryptoKey key = new CryptoKey(new DSA(true));
-			using (X509Certificate cert = new X509Certificate(101, "CN=localhost", "CN=Root", key, start, end)) {
+			var start = DateTime.Now;
+			var end = start + TimeSpan.FromMinutes(10);
+			using (var key = new CryptoKey(new DSA(true)))
+			using (var cert = new X509Certificate(101, "CN=localhost", "CN=Root", key, start, end))
+			{
 				cert.Sign(key, MessageDigest.DSS1);
 			}
 		}
@@ -269,14 +304,17 @@
 		[Test]
 		public void CanCheckPrivateKey()
 		{
-			DateTime start = DateTime.Now;
-			DateTime end = start + TimeSpan.FromMinutes(10);
-			CryptoKey key = new CryptoKey(new DSA(true));
-			using (X509Certificate cert = new X509Certificate(101, "CN=localhost", "CN=Root", key, start, end)) {
+			var start = DateTime.Now;
+			var end = start + TimeSpan.FromMinutes(10);
+			using (var key = new CryptoKey(new DSA(true)))
+			using (var cert = new X509Certificate(101, "CN=localhost", "CN=Root", key, start, end))
+			{
 				Assert.AreEqual(true, cert.CheckPrivateKey(key));
 
-				CryptoKey other = new CryptoKey(new DSA(true));
-				Assert.AreEqual(false, cert.CheckPrivateKey(other));
+				using (var other = new CryptoKey(new DSA(true)))
+				{
+					Assert.AreEqual(false, cert.CheckPrivateKey(other));
+				}
 			}
 		}
 
@@ -289,15 +327,18 @@
 		[Test]
 		public void CanVerify()
 		{
-			DateTime start = DateTime.Now;
-			DateTime end = start + TimeSpan.FromMinutes(10);
-			CryptoKey key = new CryptoKey(new DSA(true));
-			using (X509Certificate cert = new X509Certificate(101, "CN=localhost", "CN=Root", key, start, end)) {
+			var start = DateTime.Now;
+			var end = start + TimeSpan.FromMinutes(10);
+			using (var key = new CryptoKey(new DSA(true)))
+			using (var cert = new X509Certificate(101, "CN=localhost", "CN=Root", key, start, end))
+			{
 				cert.Sign(key, MessageDigest.DSS1);
 				Assert.AreEqual(true, cert.Verify(key));
 
-				CryptoKey other = new CryptoKey(new DSA(true));
-				Assert.AreEqual(false, cert.Verify(other));
+				using (var other = new CryptoKey(new DSA(true)))
+				{
+					Assert.AreEqual(false, cert.Verify(other));
+				}
 			}
 		}
 
@@ -316,12 +357,13 @@
 		[Test]
 		public void CanCreateRequest()
 		{
-			DateTime start = DateTime.Now;
-			DateTime end = start + TimeSpan.FromMinutes(10);
-			CryptoKey key = new CryptoKey(new DSA(true));
-			using (X509Certificate cert = new X509Certificate(101, "CN=localhost", "CN=Root", key, start, end)) {
-				X509Request request = cert.CreateRequest(key, MessageDigest.DSS1);
-				Assert.AreEqual(true, request.Verify(key));
+			var start = DateTime.Now;
+			var end = start + TimeSpan.FromMinutes(10);
+			using (var key = new CryptoKey(new DSA(true)))
+			using (var cert = new X509Certificate(101, "CN=localhost", "CN=Root", key, start, end))
+			using (var request = cert.CreateRequest(key, MessageDigest.DSS1))
+			{
+				Assert.IsTrue(request.Verify(key));
 			}
 		}
 
@@ -328,23 +370,28 @@
 		[Test]
 		public void CanAddExtensions()
 		{
-			X509V3ExtensionList extList = new X509V3ExtensionList();
-			extList.Add(new X509V3ExtensionValue("subjectKeyIdentifier", false, "hash"));
-			extList.Add(new X509V3ExtensionValue("authorityKeyIdentifier", false, "keyid:always,issuer:always"));
-			extList.Add(new X509V3ExtensionValue("basicConstraints", true, "critical,CA:true"));
-			extList.Add(new X509V3ExtensionValue("keyUsage", false, "cRLSign,keyCertSign"));
+			var extList = new List<X509V3ExtensionValue> {
+				new X509V3ExtensionValue("subjectKeyIdentifier", false, "hash"),
+				new X509V3ExtensionValue("authorityKeyIdentifier", false, "keyid:always,issuer:always"),
+				new X509V3ExtensionValue("basicConstraints", true, "critical,CA:true"),
+				new X509V3ExtensionValue("keyUsage", false, "cRLSign,keyCertSign"),
+			};
 
-			DateTime start = DateTime.Now;
-			DateTime end = start + TimeSpan.FromMinutes(10);
-			CryptoKey key = new CryptoKey(new DSA(true));
-			using (X509Certificate cert = new X509Certificate(101, "CN=Root", "CN=Root", key, start, end)) {
-				foreach (X509V3ExtensionValue extValue in extList) {
-					using (X509Extension ext = new X509Extension(cert, cert, extValue.Name, extValue.IsCritical, extValue.Value)) {
+			var start = DateTime.Now;
+			var end = start + TimeSpan.FromMinutes(10);
+			using (var key = new CryptoKey(new DSA(true)))
+			using (var cert = new X509Certificate(101, "CN=Root", "CN=Root", key, start, end))
+			{
+				foreach (var extValue in extList)
+				{
+					using (var ext = new X509Extension(cert, cert, extValue.Name, extValue.IsCritical, extValue.Value))
+					{
 						cert.AddExtension(ext);
 					}
 				}
 
-				foreach (X509Extension ext in cert.Extensions) {
+				foreach (var ext in cert.Extensions)
+				{
 					Console.WriteLine(ext);
 				}
 
@@ -356,40 +403,7 @@
 		{
 			Assert.AreEqual(subject, cert.Subject.ToString());
 			Assert.AreEqual(issuer, cert.Issuer.ToString());
-			Assert.AreEqual(serial, cert.SerialNumber); 
+			Assert.AreEqual(serial, cert.SerialNumber);
 		}
-		
-		private string LoadString(string resourceId) {
-			using (Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(resourceId)) {
-				using (StreamReader reader = new StreamReader(stream)) {
-					return reader.ReadToEnd();
-				}
-			}
-		}
-		
-		private byte[] LoadBytes(string resourceId) {
-			using (Stream stream = Assembly.GetExecutingAssembly().GetManifestResourceStream(resourceId)) {
-				using (BinaryReader reader = new BinaryReader(stream)) {
-					return reader.ReadBytes((int)stream.Length);
-				}
-			}
-		}
-
-		static class Resources
-		{
-			public const string CaCrt = "UnitTests.certs.ca.crt";
-			public const string CaDer = "UnitTests.certs.ca.der";
-			public const string CaChainP7c = "UnitTests.certs.ca_chain.p7c";
-			public const string CaChainP7cPem = "UnitTests.certs.ca_chain.p7c.pem";
-			public const string CaChainPem = "UnitTests.certs.ca_chain.pem";
-			public const string ClientCrt = "UnitTests.certs.client.crt";
-			public const string ClientPfx = "UnitTests.certs.client.pfx";
-			public const string ClientKey = "UnitTests.certs.client.key";
-			public const string ServerCrt = "UnitTests.certs.server.crt";
-			public const string ServerPfx = "UnitTests.certs.server.pfx";
-			public const string ServerKey = "UnitTests.certs.server.key";
-		}
-
-		const string password = "p@ssw0rd";
 	}
 }
Index: test/UnitTests-2010.csproj
===================================================================
--- test/UnitTests-2010.csproj	(revision 47839)
+++ test/UnitTests-2010.csproj	(revision 47851)
@@ -1,4 +1,4 @@
-<?xml version="1.0" encoding="utf-8"?>
+﻿<?xml version="1.0" encoding="utf-8"?>
 <Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
   <PropertyGroup>
     <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
@@ -10,7 +10,7 @@
     <AppDesignerFolder>Properties</AppDesignerFolder>
     <RootNamespace>UnitTests</RootNamespace>
     <AssemblyName>UnitTests</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
+    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
     <FileAlignment>512</FileAlignment>
     <FileUpgradeFlags>
     </FileUpgradeFlags>
@@ -31,33 +31,85 @@
     <IsWebBootstrapper>false</IsWebBootstrapper>
     <UseApplicationTrust>false</UseApplicationTrust>
     <BootstrapperEnabled>true</BootstrapperEnabled>
+    <TargetFrameworkProfile />
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
     <DebugSymbols>true</DebugSymbols>
     <DebugType>full</DebugType>
     <Optimize>false</Optimize>
-    <OutputPath>..\bin\Debug\</OutputPath>
+    <OutputPath>..\bin\</OutputPath>
     <DefineConstants>DEBUG;TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
     <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
-    <PlatformTarget>x86</PlatformTarget>
+    <PlatformTarget>AnyCPU</PlatformTarget>
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <Prefer32Bit>false</Prefer32Bit>
   </PropertyGroup>
   <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
     <DebugType>pdbonly</DebugType>
     <Optimize>true</Optimize>
-    <OutputPath>..\bin\Release\</OutputPath>
+    <OutputPath>..\bin\</OutputPath>
     <DefineConstants>TRACE</DefineConstants>
     <ErrorReport>prompt</ErrorReport>
     <WarningLevel>4</WarningLevel>
     <DebugSymbols>true</DebugSymbols>
     <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
+    <PlatformTarget>AnyCPU</PlatformTarget>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <Prefer32Bit>false</Prefer32Bit>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x64'">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>bin\x64\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x64</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <Prefer32Bit>false</Prefer32Bit>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x64'">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>bin\x64\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x64</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <Prefer32Bit>false</Prefer32Bit>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Debug|x86'">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>bin\x86\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
+    <DebugType>full</DebugType>
     <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
     <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <Prefer32Bit>false</Prefer32Bit>
   </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Release|x86'">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>bin\x86\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
+    <Optimize>true</Optimize>
+    <DebugType>pdbonly</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <Prefer32Bit>false</Prefer32Bit>
+  </PropertyGroup>
   <ItemGroup>
-    <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL" />
+    <Reference Include="nunit.framework, Version=2.6.4.14350, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL">
+      <HintPath>..\packages\NUnit.2.6.4\lib\nunit.framework.dll</HintPath>
+      <Private>True</Private>
+    </Reference>
     <Reference Include="System" />
     <Reference Include="System.Core">
       <RequiredTargetFramework>3.5</RequiredTargetFramework>
@@ -69,6 +121,8 @@
     <Compile Include="Properties\AssemblyInfo.cs" />
     <Compile Include="SourceForgeBugs.cs" />
     <Compile Include="TestAES.cs" />
+    <Compile Include="TestBigNumber.cs" />
+    <Compile Include="TestCipher.cs" />
     <Compile Include="TestDH.cs" />
     <Compile Include="TestDSA.cs" />
     <Compile Include="TestRSA.cs" />
@@ -75,6 +129,8 @@
     <Compile Include="TestECDH.cs" />
     <Compile Include="TestECDSA.cs" />
     <Compile Include="TestCryptoKey.cs" />
+    <Compile Include="TestSSL.cs" />
+    <Compile Include="TestVersion.cs" />
     <Compile Include="TestX509Certificate.cs" />
     <Compile Include="TestBase.cs" />
     <Compile Include="TestHMAC.cs" />
@@ -84,15 +140,9 @@
     <Compile Include="TestSHA256.cs" />
     <Compile Include="TestSHA512.cs" />
     <Compile Include="TestX509.cs" />
-    <Compile Include="TestServer.cs" />
+    <Compile Include="Util.cs" />
   </ItemGroup>
   <ItemGroup>
-    <ProjectReference Include="..\ManagedOpenSsl\ManagedOpenSsl-2010.csproj">
-      <Project>{73DCC218-655B-485F-8EAC-0CE5F2F7343D}</Project>
-      <Name>ManagedOpenSsl-2010</Name>
-    </ProjectReference>
-  </ItemGroup>
-  <ItemGroup>
     <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
       <Visible>False</Visible>
       <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
@@ -121,11 +171,9 @@
     <None Include="openssl.cnf">
       <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
     </None>
+    <None Include="packages.config" />
   </ItemGroup>
   <ItemGroup>
-    <Folder Include="certs\" />
-  </ItemGroup>
-  <ItemGroup>
     <EmbeddedResource Include="certs\ca.crt" />
     <EmbeddedResource Include="certs\ca.der" />
     <EmbeddedResource Include="certs\ca.key" />
@@ -139,4 +187,10 @@
     <EmbeddedResource Include="certs\server.key" />
     <EmbeddedResource Include="certs\server.pfx" />
   </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\ManagedOpenSsl\ManagedOpenSsl-2010.csproj">
+      <Project>{73dcc218-655b-485f-8eac-0ce5f2f7343d}</Project>
+      <Name>ManagedOpenSsl-2010</Name>
+    </ProjectReference>
+  </ItemGroup>
 </Project>
\ No newline at end of file
Index: test/UnitTests.csproj
===================================================================
--- test/UnitTests.csproj	(revision 47839)
+++ test/UnitTests.csproj	(revision 47851)
@@ -1,66 +1,135 @@
-﻿<?xml version="1.0" encoding="utf-8"?>
-<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="3.5">
-  <PropertyGroup>
-    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
-    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
-    <ProductVersion>9.0.30729</ProductVersion>
-    <SchemaVersion>2.0</SchemaVersion>
-    <ProjectGuid>{779FA0D7-D7CB-4408-A94D-B5718F118894}</ProjectGuid>
-    <OutputType>Library</OutputType>
-    <AppDesignerFolder>Properties</AppDesignerFolder>
-    <RootNamespace>UnitTests</RootNamespace>
-    <AssemblyName>UnitTests</AssemblyName>
-    <TargetFrameworkVersion>v3.5</TargetFrameworkVersion>
-    <FileAlignment>512</FileAlignment>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
-    <DebugSymbols>true</DebugSymbols>
-    <DebugType>full</DebugType>
-    <Optimize>false</Optimize>
-    <OutputPath>..\bin\Debug\</OutputPath>
-    <DefineConstants>DEBUG;TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-    <OutputType>Library</OutputType>
-    <RootNamespace>UnitTests</RootNamespace>
-    <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
-    <PlatformTarget>x86</PlatformTarget>
-  </PropertyGroup>
-  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
-    <DebugType>pdbonly</DebugType>
-    <Optimize>true</Optimize>
-    <OutputPath>..\bin\Release\</OutputPath>
-    <DefineConstants>TRACE</DefineConstants>
-    <ErrorReport>prompt</ErrorReport>
-    <WarningLevel>4</WarningLevel>
-    <OutputType>Library</OutputType>
-    <DebugSymbols>true</DebugSymbols>
-    <RootNamespace>UnitTests</RootNamespace>
-    <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
-    <PlatformTarget>x86</PlatformTarget>
-  </PropertyGroup>
-  <ItemGroup>
-    <Reference Include="nunit.framework, Version=2.4.8.0, Culture=neutral, PublicKeyToken=96d09a1eb7f44a77, processorArchitecture=MSIL" />
-    <Reference Include="System" />
-    <Reference Include="System.Core">
-      <RequiredTargetFramework>3.5</RequiredTargetFramework>
-    </Reference>
-    <Reference Include="System.Data" />
-    <Reference Include="System.Xml" />
-  </ItemGroup>
-  <ItemGroup>
-    <Compile Include="BaseTest.cs" />
-    <Compile Include="CryptoKeyTest.cs" />
-    <Compile Include="X509CertificateTest.cs" />
-    <Compile Include="Properties\AssemblyInfo.cs" />
-  </ItemGroup>
-  <ItemGroup>
-    <ProjectReference Include="..\ManagedOpenSsl\ManagedOpenSsl-2008.csproj">
-      <Project>{73DCC218-655B-485F-8EAC-0CE5F2F7343D}</Project>
-      <Name>ManagedOpenSsl-2008</Name>
-    </ProjectReference>
-  </ItemGroup>
-  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
+﻿<?xml version="1.0" encoding="utf-8"?>
+<Project DefaultTargets="Build" xmlns="http://schemas.microsoft.com/developer/msbuild/2003" ToolsVersion="4.0">
+  <PropertyGroup>
+    <Configuration Condition=" '$(Configuration)' == '' ">Debug</Configuration>
+    <Platform Condition=" '$(Platform)' == '' ">AnyCPU</Platform>
+    <ProductVersion>8.0.30703</ProductVersion>
+    <SchemaVersion>2.0</SchemaVersion>
+    <ProjectGuid>{779FA0D7-D7CB-4408-A94D-B5718F118894}</ProjectGuid>
+    <OutputType>Library</OutputType>
+    <AppDesignerFolder>Properties</AppDesignerFolder>
+    <RootNamespace>UnitTests</RootNamespace>
+    <AssemblyName>UnitTests</AssemblyName>
+    <TargetFrameworkVersion>v4.5</TargetFrameworkVersion>
+    <FileAlignment>512</FileAlignment>
+    <FileUpgradeFlags>
+    </FileUpgradeFlags>
+    <OldToolsVersion>3.5</OldToolsVersion>
+    <UpgradeBackupLocation />
+    <PublishUrl>publish\</PublishUrl>
+    <Install>true</Install>
+    <InstallFrom>Disk</InstallFrom>
+    <UpdateEnabled>false</UpdateEnabled>
+    <UpdateMode>Foreground</UpdateMode>
+    <UpdateInterval>7</UpdateInterval>
+    <UpdateIntervalUnits>Days</UpdateIntervalUnits>
+    <UpdatePeriodically>false</UpdatePeriodically>
+    <UpdateRequired>false</UpdateRequired>
+    <MapFileExtensions>true</MapFileExtensions>
+    <ApplicationRevision>0</ApplicationRevision>
+    <ApplicationVersion>1.0.0.%2a</ApplicationVersion>
+    <IsWebBootstrapper>false</IsWebBootstrapper>
+    <UseApplicationTrust>false</UseApplicationTrust>
+    <BootstrapperEnabled>true</BootstrapperEnabled>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Debug|AnyCPU' ">
+    <DebugSymbols>true</DebugSymbols>
+    <DebugType>full</DebugType>
+    <Optimize>false</Optimize>
+    <OutputPath>..\bin\Debug\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
+    <PlatformTarget>x86</PlatformTarget>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+    <EnvironmentVariables>
+      <EnvironmentVariables>
+        <Variable name="DYLD_LIBRARY_PATH" value="/usr/local/Cellar/openssl/1.0.2c/lib" />
+      </EnvironmentVariables>
+    </EnvironmentVariables>
+    <ConsolePause>false</ConsolePause>
+  </PropertyGroup>
+  <PropertyGroup Condition=" '$(Configuration)|$(Platform)' == 'Release|AnyCPU' ">
+    <DebugType>pdbonly</DebugType>
+    <Optimize>true</Optimize>
+    <OutputPath>..\bin\Release\</OutputPath>
+    <DefineConstants>TRACE</DefineConstants>
+    <ErrorReport>prompt</ErrorReport>
+    <WarningLevel>4</WarningLevel>
+    <DebugSymbols>true</DebugSymbols>
+    <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
+    <PlatformTarget>x86</PlatformTarget>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <PropertyGroup Condition="'$(Configuration)|$(Platform)' == 'Trace|AnyCPU'">
+    <DebugSymbols>true</DebugSymbols>
+    <OutputPath>..\bin\Trace\</OutputPath>
+    <DefineConstants>DEBUG;TRACE</DefineConstants>
+    <CheckForOverflowUnderflow>true</CheckForOverflowUnderflow>
+    <DebugType>full</DebugType>
+    <PlatformTarget>x86</PlatformTarget>
+    <ErrorReport>prompt</ErrorReport>
+    <CodeAnalysisRuleSet>AllRules.ruleset</CodeAnalysisRuleSet>
+  </PropertyGroup>
+  <ItemGroup>
+    <Reference Include="nunit.framework">
+      <HintPath>..\packages\NUnit.2.6.4\lib\nunit.framework.dll</HintPath>
+    </Reference>
+    <Reference Include="System" />
+    <Reference Include="System.Core" />
+    <Reference Include="System.Data" />
+    <Reference Include="System.Xml" />
+  </ItemGroup>
+  <ItemGroup>
+    <Compile Include="Properties\AssemblyInfo.cs" />
+    <Compile Include="SourceForgeBugs.cs" />
+    <Compile Include="TestAES.cs" />
+    <Compile Include="TestDH.cs" />
+    <Compile Include="TestDSA.cs" />
+    <Compile Include="TestRSA.cs" />
+    <Compile Include="TestECDH.cs" />
+    <Compile Include="TestECDSA.cs" />
+    <Compile Include="TestCryptoKey.cs" />
+    <Compile Include="TestX509Certificate.cs" />
+    <Compile Include="TestBase.cs" />
+    <Compile Include="TestHMAC.cs" />
+    <Compile Include="TestRandom.cs" />
+    <Compile Include="TestSHA.cs" />
+    <Compile Include="TestSHA1.cs" />
+    <Compile Include="TestSHA256.cs" />
+    <Compile Include="TestSHA512.cs" />
+    <Compile Include="TestX509.cs" />
+    <Compile Include="TestCipher.cs" />
+    <Compile Include="TestVersion.cs" />
+    <Compile Include="TestBigNumber.cs" />
+    <Compile Include="TestSSL.cs" />
+    <Compile Include="Util.cs" />
+  </ItemGroup>
+  <ItemGroup>
+    <ProjectReference Include="..\ManagedOpenSsl\ManagedOpenSsl.csproj">
+      <Project>{73DCC218-655B-485F-8EAC-0CE5F2F7343D}</Project>
+      <Name>ManagedOpenSsl</Name>
+    </ProjectReference>
+  </ItemGroup>
+  <ItemGroup>
+    <BootstrapperPackage Include="Microsoft.Net.Client.3.5">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1 Client Profile</ProductName>
+      <Install>false</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Net.Framework.3.5.SP1">
+      <Visible>False</Visible>
+      <ProductName>.NET Framework 3.5 SP1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+    <BootstrapperPackage Include="Microsoft.Windows.Installer.3.1">
+      <Visible>False</Visible>
+      <ProductName>Windows Installer 3.1</ProductName>
+      <Install>true</Install>
+    </BootstrapperPackage>
+  </ItemGroup>
+  <Import Project="$(MSBuildToolsPath)\Microsoft.CSharp.targets" />
   <!-- To modify your build process, add your task inside one of the targets below and uncomment it. 
        Other similar extension points exist, see Microsoft.Common.targets.
   <Target Name="BeforeBuild">
@@ -67,5 +136,28 @@
   </Target>
   <Target Name="AfterBuild">
   </Target>
-  -->
-</Project>
+  -->
+  <ItemGroup>
+    <None Include="openssl.cnf">
+      <CopyToOutputDirectory>PreserveNewest</CopyToOutputDirectory>
+    </None>
+    <None Include="packages.config" />
+  </ItemGroup>
+  <ItemGroup>
+    <Service Include="{82A7F48D-3B50-4B1E-B82E-3ADA8210C358}" />
+  </ItemGroup>
+  <ItemGroup>
+    <EmbeddedResource Include="certs\ca.crt" />
+    <EmbeddedResource Include="certs\ca.der" />
+    <EmbeddedResource Include="certs\ca.key" />
+    <EmbeddedResource Include="certs\ca_chain.p7c" />
+    <EmbeddedResource Include="certs\ca_chain.p7c.pem" />
+    <EmbeddedResource Include="certs\ca_chain.pem" />
+    <EmbeddedResource Include="certs\client.crt" />
+    <EmbeddedResource Include="certs\client.key" />
+    <EmbeddedResource Include="certs\client.pfx" />
+    <EmbeddedResource Include="certs\server.crt" />
+    <EmbeddedResource Include="certs\server.key" />
+    <EmbeddedResource Include="certs\server.pfx" />
+  </ItemGroup>
+</Project>
\ No newline at end of file
Index: test/certs/ca.crt
===================================================================
--- test/certs/ca.crt	(revision 47839)
+++ test/certs/ca.crt	(revision 47851)
@@ -2,7 +2,7 @@
     Data:
         Version: 3 (0x2)
         Serial Number: 1234 (0x4d2)
-        Signature Algorithm: sha1WithRSAEncryption
+    Signature Algorithm: sha1WithRSAEncryption
         Issuer: CN=Root
         Validity
             Not Before: May 13 18:59:46 2009 GMT
@@ -61,35 +61,35 @@
             X509v3 Key Usage: 
                 Certificate Sign, CRL Sign
     Signature Algorithm: sha1WithRSAEncryption
-        64:0f:26:68:90:97:08:0e:5a:5a:d4:7b:fb:59:4b:9d:1e:c7:
-        a0:c1:96:e6:7b:88:ad:af:2f:d7:71:4c:64:ba:e7:a6:51:59:
-        a5:cf:e5:77:a8:c1:4e:d2:67:51:88:aa:f2:fc:9b:a1:67:c2:
-        fb:68:55:cd:2d:53:3a:f7:c8:f0:07:bc:00:7e:ec:f3:fc:6a:
-        41:3c:0d:3a:0f:e4:91:70:84:9f:2c:a3:88:23:12:9b:06:a8:
-        09:6b:e7:e9:ee:2e:e8:49:12:53:85:66:b5:0a:5f:6c:b8:69:
-        25:c9:33:cb:b4:e7:48:41:c1:e3:1e:e9:c3:73:a6:c2:ec:9d:
-        a5:fc:26:b2:b6:35:db:d6:ba:b1:45:d3:8d:5e:85:52:ef:f5:
-        31:68:c6:43:f7:08:96:e2:49:df:8d:1d:03:56:cd:6e:a2:71:
-        87:d7:c0:05:af:f7:15:65:bf:76:e8:8a:a3:a1:b3:2f:14:e6:
-        68:dd:42:a9:b6:c6:8c:b7:b5:9f:df:68:75:ed:1a:bf:be:0f:
-        21:7c:5a:e6:55:13:76:1b:c1:0f:8f:cd:78:43:22:70:bb:34:
-        be:0f:94:d9:6c:1e:b2:09:1d:6c:cd:7b:ff:2e:54:6a:dc:ee:
-        8e:eb:e8:eb:a2:fb:22:35:5b:b2:5c:c9:4c:de:c9:fa:3a:56:
-        3f:21:28:f4:11:d3:0e:51:2b:03:74:a3:41:f2:f0:b0:5b:7e:
-        dc:2d:a5:06:42:05:19:48:38:23:eb:88:88:0a:9c:8f:f2:c4:
-        04:54:31:ed:9a:fa:30:c6:8b:f0:b2:ca:25:18:f7:79:89:d4:
-        31:2c:97:f5:4c:72:bf:40:00:80:44:27:dd:3e:5e:94:78:8e:
-        59:ad:24:bb:cd:7c:ea:dd:c3:1c:5d:11:2e:56:9e:d1:bb:3b:
-        7a:7e:14:5d:68:20:9c:f8:f0:1a:5a:7a:ab:7a:93:92:b3:b3:
-        f2:ff:82:9f:73:a1:a5:1a:7f:ca:7c:91:84:8b:d7:f8:9b:a1:
-        e2:64:80:7b:4d:ef:4b:0e:27:f6:b9:f5:80:e6:06:f9:1a:b1:
-        26:f9:87:cb:13:4e:88:dd:86:da:60:c4:0e:2f:13:9d:ed:d0:
-        65:e6:e7:c6:b2:f6:0e:80:d8:4e:38:7a:b6:bc:2c:6f:ef:1d:
-        c4:79:f3:9b:9a:ee:98:3d:25:7f:0c:74:74:98:eb:cf:fd:26:
-        fe:0e:2f:18:43:33:22:02:63:13:e7:d0:c1:48:c0:b0:4b:d7:
-        0e:ba:bd:2e:39:4b:47:c8:74:dd:24:3b:a5:85:18:f5:46:19:
-        a4:8f:b7:f7:dd:35:f6:8f:e4:2c:7f:f6:6f:e2:c4:c2:cb:52:
-        b6:59:a8:93:02:1f:6a:ee
+         64:0f:26:68:90:97:08:0e:5a:5a:d4:7b:fb:59:4b:9d:1e:c7:
+         a0:c1:96:e6:7b:88:ad:af:2f:d7:71:4c:64:ba:e7:a6:51:59:
+         a5:cf:e5:77:a8:c1:4e:d2:67:51:88:aa:f2:fc:9b:a1:67:c2:
+         fb:68:55:cd:2d:53:3a:f7:c8:f0:07:bc:00:7e:ec:f3:fc:6a:
+         41:3c:0d:3a:0f:e4:91:70:84:9f:2c:a3:88:23:12:9b:06:a8:
+         09:6b:e7:e9:ee:2e:e8:49:12:53:85:66:b5:0a:5f:6c:b8:69:
+         25:c9:33:cb:b4:e7:48:41:c1:e3:1e:e9:c3:73:a6:c2:ec:9d:
+         a5:fc:26:b2:b6:35:db:d6:ba:b1:45:d3:8d:5e:85:52:ef:f5:
+         31:68:c6:43:f7:08:96:e2:49:df:8d:1d:03:56:cd:6e:a2:71:
+         87:d7:c0:05:af:f7:15:65:bf:76:e8:8a:a3:a1:b3:2f:14:e6:
+         68:dd:42:a9:b6:c6:8c:b7:b5:9f:df:68:75:ed:1a:bf:be:0f:
+         21:7c:5a:e6:55:13:76:1b:c1:0f:8f:cd:78:43:22:70:bb:34:
+         be:0f:94:d9:6c:1e:b2:09:1d:6c:cd:7b:ff:2e:54:6a:dc:ee:
+         8e:eb:e8:eb:a2:fb:22:35:5b:b2:5c:c9:4c:de:c9:fa:3a:56:
+         3f:21:28:f4:11:d3:0e:51:2b:03:74:a3:41:f2:f0:b0:5b:7e:
+         dc:2d:a5:06:42:05:19:48:38:23:eb:88:88:0a:9c:8f:f2:c4:
+         04:54:31:ed:9a:fa:30:c6:8b:f0:b2:ca:25:18:f7:79:89:d4:
+         31:2c:97:f5:4c:72:bf:40:00:80:44:27:dd:3e:5e:94:78:8e:
+         59:ad:24:bb:cd:7c:ea:dd:c3:1c:5d:11:2e:56:9e:d1:bb:3b:
+         7a:7e:14:5d:68:20:9c:f8:f0:1a:5a:7a:ab:7a:93:92:b3:b3:
+         f2:ff:82:9f:73:a1:a5:1a:7f:ca:7c:91:84:8b:d7:f8:9b:a1:
+         e2:64:80:7b:4d:ef:4b:0e:27:f6:b9:f5:80:e6:06:f9:1a:b1:
+         26:f9:87:cb:13:4e:88:dd:86:da:60:c4:0e:2f:13:9d:ed:d0:
+         65:e6:e7:c6:b2:f6:0e:80:d8:4e:38:7a:b6:bc:2c:6f:ef:1d:
+         c4:79:f3:9b:9a:ee:98:3d:25:7f:0c:74:74:98:eb:cf:fd:26:
+         fe:0e:2f:18:43:33:22:02:63:13:e7:d0:c1:48:c0:b0:4b:d7:
+         0e:ba:bd:2e:39:4b:47:c8:74:dd:24:3b:a5:85:18:f5:46:19:
+         a4:8f:b7:f7:dd:35:f6:8f:e4:2c:7f:f6:6f:e2:c4:c2:cb:52:
+         b6:59:a8:93:02:1f:6a:ee
 -----BEGIN CERTIFICATE-----
 MIIFEzCCAvugAwIBAgICBNIwDQYJKoZIhvcNAQEFBQAwDzENMAsGA1UEAxMEUm9v
 dDAeFw0wOTA1MTMxODU5NDZaFw0xMDA1MTMxODU5NDZaMA8xDTALBgNVBAMTBFJv
Index: test/openssl.cnf
===================================================================
--- test/openssl.cnf	(revision 47839)
+++ test/openssl.cnf	(revision 47851)
@@ -49,3 +49,8 @@
 
 # This really needs to be in place for it to be a proxy certificate.
 #proxyCertInfo=critical,language:id-ppl-anyLanguage,pathlen:3,policy:foo
+
+[ tls_server ]
+
+[ tls_client ]
+
Index: release.cmd
===================================================================
--- release.cmd	(revision 47839)
+++ release.cmd	(revision 47851)
@@ -7,6 +7,7 @@
 copy %SRC%\ManagedOpenSsl.xml %TGT%
 copy %SRC%\libeay32.dll %TGT%
 copy %SRC%\ssleay32.dll %TGT%
+copy %SRC%\test.exe %TGT%
 copy "%SRC%\openssl+.exe" %TGT%
 
 copy "COPYING" %TGT%
